(()=>{"use strict";var __webpack_require__={};(()=>{__webpack_require__.d=(exports,definition)=>{for(var key in definition){if(__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)){Object.defineProperty(exports,key,{enumerable:true,get:definition[key]})}}}})();(()=>{__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop)})();(()=>{__webpack_require__.r=exports=>{if(typeof Symbol!=="undefined"&&Symbol.toStringTag){Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"})}Object.defineProperty(exports,"__esModule",{value:true})}})();var __webpack_exports__={};__webpack_require__.r(__webpack_exports__);__webpack_require__.d(__webpack_exports__,{runTest:()=>runTest});var check_error_namespaceObject={};__webpack_require__.r(check_error_namespaceObject);__webpack_require__.d(check_error_namespaceObject,{compatibleConstructor:()=>compatibleConstructor,compatibleInstance:()=>compatibleInstance,compatibleMessage:()=>compatibleMessage,getConstructorName:()=>getConstructorName,getMessage:()=>getMessage});var utils_namespaceObject={};__webpack_require__.r(utils_namespaceObject);__webpack_require__.d(utils_namespaceObject,{op:()=>addChainableMethod,Zg:()=>addMethod,hm:()=>addProperty,Lq:()=>check_error_namespaceObject,DI:()=>compareByInspect,J_:()=>deep_eql,Jt:()=>flag_flag,HX:()=>getActual,I4:()=>getMessage_getMessage,mG:()=>getName,F5:()=>getOperator,Iq:()=>getOwnEnumerableProperties,aM:()=>getPathInfo,i5:()=>pathval_hasProperty,Nn:()=>inspect_inspect,yr:()=>isNaN_isNaN,kf:()=>isNumeric,gd:()=>utils_isRegExp,Qz:()=>objDisplay,IQ:()=>overwriteChainableMethod,tx:()=>overwriteMethod,rM:()=>overwriteProperty,yH:()=>proxify,t6:()=>test,Nk:()=>transferFlags,NW:()=>type_detect_type});function isErrorInstance(obj){return obj instanceof Error||Object.prototype.toString.call(obj)==="[object Error]"}function isRegExp(obj){return Object.prototype.toString.call(obj)==="[object RegExp]"}function compatibleInstance(thrown,errorLike){return isErrorInstance(errorLike)&&thrown===errorLike}function compatibleConstructor(thrown,errorLike){if(isErrorInstance(errorLike)){return thrown.constructor===errorLike.constructor||thrown instanceof errorLike.constructor}else if((typeof errorLike==="object"||typeof errorLike==="function")&&errorLike.prototype){return thrown.constructor===errorLike||thrown instanceof errorLike}return false}function compatibleMessage(thrown,errMatcher){const comparisonString=typeof thrown==="string"?thrown:thrown.message;if(isRegExp(errMatcher)){return errMatcher.test(comparisonString)}else if(typeof errMatcher==="string"){return comparisonString.indexOf(errMatcher)!==-1}return false}function getConstructorName(errorLike){let constructorName=errorLike;if(isErrorInstance(errorLike)){constructorName=errorLike.constructor.name}else if(typeof errorLike==="function"){constructorName=errorLike.name;if(constructorName===""){const newConstructorName=(new errorLike).name;constructorName=newConstructorName||constructorName}}return constructorName}function getMessage(errorLike){let msg="";if(errorLike&&errorLike.message){msg=errorLike.message}else if(typeof errorLike==="string"){msg=errorLike}return msg}
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function flag_flag(obj,key,value){let flags=obj.__flags||(obj.__flags=Object.create(null));if(arguments.length===3){flags[key]=value}else{return flags[key]}}
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function test(obj,args){let negate=flag_flag(obj,"negate"),expr=args[0];return negate?!expr:expr}function type_detect_type(obj){if(typeof obj==="undefined"){return"undefined"}if(obj===null){return"null"}const stringTag=obj[Symbol.toStringTag];if(typeof stringTag==="string"){return stringTag}const type=Object.prototype.toString.call(obj).slice(8,-1);return type}const canElideFrames="captureStackTrace"in Error;class assertion_error_AssertionError extends Error{message;get name(){return"AssertionError"}get ok(){return false}constructor(message="Unspecified AssertionError",props,ssf){super(message);this.message=message;if(canElideFrames){Error.captureStackTrace(this,ssf||assertion_error_AssertionError)}for(const key in props){if(!(key in this)){this[key]=props[key]}}}toJSON(stack){return{...this,name:this.name,message:this.message,ok:false,stack:stack!==false?this.stack:undefined}}}class AssertionResult{get name(){return"AssertionResult"}get ok(){return true}constructor(props){for(const key in props){if(!(key in this)){this[key]=props[key]}}}toJSON(){return{...this,name:this.name,ok:this.ok}}}
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function expectTypes(obj,types){let flagMsg=flag(obj,"message");let ssfi=flag(obj,"ssfi");flagMsg=flagMsg?flagMsg+": ":"";obj=flag(obj,"object");types=types.map(function(t){return t.toLowerCase()});types.sort();let str=types.map(function(t,index){let art=~["a","e","i","o","u"].indexOf(t.charAt(0))?"an":"a";let or=types.length>1&&index===types.length-1?"or ":"";return or+art+" "+t}).join(", ");let objType=type(obj).toLowerCase();if(!types.some(function(expected){return objType===expected})){throw new AssertionError(flagMsg+"object tested must be "+str+", but "+objType+" given",undefined,ssfi)}}
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function getActual(obj,args){return args.length>4?args[4]:obj._obj}const ansiColors={bold:["1","22"],dim:["2","22"],italic:["3","23"],underline:["4","24"],inverse:["7","27"],hidden:["8","28"],strike:["9","29"],black:["30","39"],red:["31","39"],green:["32","39"],yellow:["33","39"],blue:["34","39"],magenta:["35","39"],cyan:["36","39"],white:["37","39"],brightblack:["30;1","39"],brightred:["31;1","39"],brightgreen:["32;1","39"],brightyellow:["33;1","39"],brightblue:["34;1","39"],brightmagenta:["35;1","39"],brightcyan:["36;1","39"],brightwhite:["37;1","39"],grey:["90","39"]};const styles={special:"cyan",number:"yellow",bigint:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",symbol:"green",date:"magenta",regexp:"red"};const truncator="â€¦";function colorise(value,styleType){const color=ansiColors[styles[styleType]]||ansiColors[styleType]||"";if(!color){return String(value)}return`[${color[0]}m${String(value)}[${color[1]}m`}function normaliseOptions({showHidden=false,depth=2,colors=false,customInspect=true,showProxy=false,maxArrayLength=Infinity,breakLength=Infinity,seen=[],truncate=Infinity,stylize=String}={},inspect){const options={showHidden:Boolean(showHidden),depth:Number(depth),colors:Boolean(colors),customInspect:Boolean(customInspect),showProxy:Boolean(showProxy),maxArrayLength:Number(maxArrayLength),breakLength:Number(breakLength),truncate:Number(truncate),seen,inspect,stylize};if(options.colors){options.stylize=colorise}return options}function isHighSurrogate(char){return char>="\ud800"&&char<="\udbff"}function truncate(string,length,tail=truncator){string=String(string);const tailLength=tail.length;const stringLength=string.length;if(tailLength>length&&stringLength>tailLength){return tail}if(stringLength>length&&stringLength>tailLength){let end=length-tailLength;if(end>0&&isHighSurrogate(string[end-1])){end=end-1}return`${string.slice(0,end)}${tail}`}return string}function inspectList(list,options,inspectItem,separator=", "){inspectItem=inspectItem||options.inspect;const size=list.length;if(size===0)return"";const originalLength=options.truncate;let output="";let peek="";let truncated="";for(let i=0;i<size;i+=1){const last=i+1===list.length;const secondToLast=i+2===list.length;truncated=`${truncator}(${list.length-i})`;const value=list[i];options.truncate=originalLength-output.length-(last?0:separator.length);const string=peek||inspectItem(value,options)+(last?"":separator);const nextLength=output.length+string.length;const truncatedLength=nextLength+truncated.length;if(last&&nextLength>originalLength&&output.length+truncated.length<=originalLength){break}if(!last&&!secondToLast&&truncatedLength>originalLength){break}peek=last?"":inspectItem(list[i+1],options)+(secondToLast?"":separator);if(!last&&secondToLast&&truncatedLength>originalLength&&nextLength+peek.length>originalLength){break}output+=string;if(!last&&!secondToLast&&nextLength+peek.length>=originalLength){truncated=`${truncator}(${list.length-i-1})`;break}truncated=""}return`${output}${truncated}`}function quoteComplexKey(key){if(key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)){return key}return JSON.stringify(key).replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'")}function inspectProperty([key,value],options){options.truncate-=2;if(typeof key==="string"){key=quoteComplexKey(key)}else if(typeof key!=="number"){key=`[${options.inspect(key,options)}]`}options.truncate-=key.length;value=options.inspect(value,options);return`${key}: ${value}`}function inspectArray(array,options){const nonIndexProperties=Object.keys(array).slice(array.length);if(!array.length&&!nonIndexProperties.length)return"[]";options.truncate-=4;const listContents=inspectList(array,options);options.truncate-=listContents.length;let propertyContents="";if(nonIndexProperties.length){propertyContents=inspectList(nonIndexProperties.map(key=>[key,array[key]]),options,inspectProperty)}return`[ ${listContents}${propertyContents?`, ${propertyContents}`:""} ]`}const getArrayName=array=>{if(typeof Buffer==="function"&&array instanceof Buffer){return"Buffer"}if(array[Symbol.toStringTag]){return array[Symbol.toStringTag]}return array.constructor.name};function inspectTypedArray(array,options){const name=getArrayName(array);options.truncate-=name.length+4;const nonIndexProperties=Object.keys(array).slice(array.length);if(!array.length&&!nonIndexProperties.length)return`${name}[]`;let output="";for(let i=0;i<array.length;i++){const string=`${options.stylize(truncate(array[i],options.truncate),"number")}${i===array.length-1?"":", "}`;options.truncate-=string.length;if(array[i]!==array.length&&options.truncate<=3){output+=`${truncator}(${array.length-array[i]+1})`;break}output+=string}let propertyContents="";if(nonIndexProperties.length){propertyContents=inspectList(nonIndexProperties.map(key=>[key,array[key]]),options,inspectProperty)}return`${name}[ ${output}${propertyContents?`, ${propertyContents}`:""} ]`}function inspectDate(dateObject,options){const stringRepresentation=dateObject.toJSON();if(stringRepresentation===null){return"Invalid Date"}const split=stringRepresentation.split("T");const date=split[0];return options.stylize(`${date}T${truncate(split[1],options.truncate-date.length-1)}`,"date")}function inspectFunction(func,options){const functionType=func[Symbol.toStringTag]||"Function";const name=func.name;if(!name){return options.stylize(`[${functionType}]`,"special")}return options.stylize(`[${functionType} ${truncate(name,options.truncate-11)}]`,"special")}function inspectMapEntry([key,value],options){options.truncate-=4;key=options.inspect(key,options);options.truncate-=key.length;value=options.inspect(value,options);return`${key} => ${value}`}function mapToEntries(map){const entries=[];map.forEach((value,key)=>{entries.push([key,value])});return entries}function inspectMap(map,options){if(map.size===0)return"Map{}";options.truncate-=7;return`Map{ ${inspectList(mapToEntries(map),options,inspectMapEntry)} }`}const number_isNaN=Number.isNaN||(i=>i!==i);function inspectNumber(number,options){if(number_isNaN(number)){return options.stylize("NaN","number")}if(number===Infinity){return options.stylize("Infinity","number")}if(number===-Infinity){return options.stylize("-Infinity","number")}if(number===0){return options.stylize(1/number===Infinity?"+0":"-0","number")}return options.stylize(truncate(String(number),options.truncate),"number")}function inspectBigInt(number,options){let nums=truncate(number.toString(),options.truncate-1);if(nums!==truncator)nums+="n";return options.stylize(nums,"bigint")}function inspectRegExp(value,options){const flags=value.toString().split("/")[2];const sourceLength=options.truncate-(2+flags.length);const source=value.source;return options.stylize(`/${truncate(source,sourceLength)}/${flags}`,"regexp")}function arrayFromSet(set){const values=[];set.forEach(value=>{values.push(value)});return values}function inspectSet(set,options){if(set.size===0)return"Set{}";options.truncate-=7;return`Set{ ${inspectList(arrayFromSet(set),options)} }`}const stringEscapeChars=new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5"+"\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]","g");const escapeCharacters={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r","'":"\\'","\\":"\\\\"};const hex=16;const unicodeLength=4;function string_escape(char){return escapeCharacters[char]||`\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`}function inspectString(string,options){if(stringEscapeChars.test(string)){string=string.replace(stringEscapeChars,string_escape)}return options.stylize(`'${truncate(string,options.truncate-2)}'`,"string")}function inspectSymbol(value){if("description"in Symbol.prototype){return value.description?`Symbol(${value.description})`:"Symbol()"}return value.toString()}const getPromiseValue=()=>"Promise{â€¦}";const promise=getPromiseValue;function inspectObject(object,options){const properties=Object.getOwnPropertyNames(object);const symbols=Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(object):[];if(properties.length===0&&symbols.length===0){return"{}"}options.truncate-=4;options.seen=options.seen||[];if(options.seen.includes(object)){return"[Circular]"}options.seen.push(object);const propertyContents=inspectList(properties.map(key=>[key,object[key]]),options,inspectProperty);const symbolContents=inspectList(symbols.map(key=>[key,object[key]]),options,inspectProperty);options.seen.pop();let sep="";if(propertyContents&&symbolContents){sep=", "}return`{ ${propertyContents}${sep}${symbolContents} }`}const toStringTag=typeof Symbol!=="undefined"&&Symbol.toStringTag?Symbol.toStringTag:false;function inspectClass(value,options){let name="";if(toStringTag&&toStringTag in value){name=value[toStringTag]}name=name||value.constructor.name;if(!name||name==="_class"){name="<Anonymous Class>"}options.truncate-=name.length;return`${name}${inspectObject(value,options)}`}function inspectArguments(args,options){if(args.length===0)return"Arguments[]";options.truncate-=13;return`Arguments[ ${inspectList(args,options)} ]`}const errorKeys=["stack","line","column","name","message","fileName","lineNumber","columnNumber","number","description","cause"];function error_inspectObject(error,options){const properties=Object.getOwnPropertyNames(error).filter(key=>errorKeys.indexOf(key)===-1);const name=error.name;options.truncate-=name.length;let message="";if(typeof error.message==="string"){message=truncate(error.message,options.truncate)}else{properties.unshift("message")}message=message?`: ${message}`:"";options.truncate-=message.length+5;options.seen=options.seen||[];if(options.seen.includes(error)){return"[Circular]"}options.seen.push(error);const propertyContents=inspectList(properties.map(key=>[key,error[key]]),options,inspectProperty);return`${name}${message}${propertyContents?` { ${propertyContents} }`:""}`}function inspectAttribute([key,value],options){options.truncate-=3;if(!value){return`${options.stylize(String(key),"yellow")}`}return`${options.stylize(String(key),"yellow")}=${options.stylize(`"${value}"`,"string")}`}function inspectNodeCollection(collection,options){return inspectList(collection,options,inspectNode,"\n")}function inspectNode(node,options){switch(node.nodeType){case 1:return inspectHTML(node,options);case 3:return options.inspect(node.data,options);default:return options.inspect(node,options)}}function inspectHTML(element,options){const properties=element.getAttributeNames();const name=element.tagName.toLowerCase();const head=options.stylize(`<${name}`,"special");const headClose=options.stylize(`>`,"special");const tail=options.stylize(`</${name}>`,"special");options.truncate-=name.length*2+5;let propertyContents="";if(properties.length>0){propertyContents+=" ";propertyContents+=inspectList(properties.map(key=>[key,element.getAttribute(key)]),options,inspectAttribute," ")}options.truncate-=propertyContents.length;const truncate=options.truncate;let children=inspectNodeCollection(element.children,options);if(children&&children.length>truncate){children=`${truncator}(${element.children.length})`}return`${head}${propertyContents}${headClose}${children}${tail}`}const symbolsSupported=typeof Symbol==="function"&&typeof Symbol.for==="function";const chaiInspect=symbolsSupported?Symbol.for("chai/inspect"):"@@chai/inspect";const nodeInspect=Symbol.for("nodejs.util.inspect.custom");const constructorMap=new WeakMap;const stringTagMap={};const baseTypesMap={undefined:(value,options)=>options.stylize("undefined","undefined"),null:(value,options)=>options.stylize("null","null"),boolean:(value,options)=>options.stylize(String(value),"boolean"),Boolean:(value,options)=>options.stylize(String(value),"boolean"),number:inspectNumber,Number:inspectNumber,bigint:inspectBigInt,BigInt:inspectBigInt,string:inspectString,String:inspectString,function:inspectFunction,Function:inspectFunction,symbol:inspectSymbol,Symbol:inspectSymbol,Array:inspectArray,Date:inspectDate,Map:inspectMap,Set:inspectSet,RegExp:inspectRegExp,Promise:promise,WeakSet:(value,options)=>options.stylize("WeakSet{â€¦}","special"),WeakMap:(value,options)=>options.stylize("WeakMap{â€¦}","special"),Arguments:inspectArguments,Int8Array:inspectTypedArray,Uint8Array:inspectTypedArray,Uint8ClampedArray:inspectTypedArray,Int16Array:inspectTypedArray,Uint16Array:inspectTypedArray,Int32Array:inspectTypedArray,Uint32Array:inspectTypedArray,Float32Array:inspectTypedArray,Float64Array:inspectTypedArray,Generator:()=>"",DataView:()=>"",ArrayBuffer:()=>"",Error:error_inspectObject,HTMLCollection:inspectNodeCollection,NodeList:inspectNodeCollection};const inspectCustom=(value,options,type)=>{if(chaiInspect in value&&typeof value[chaiInspect]==="function"){return value[chaiInspect](options)}if(nodeInspect in value&&typeof value[nodeInspect]==="function"){return value[nodeInspect](options.depth,options)}if("inspect"in value&&typeof value.inspect==="function"){return value.inspect(options.depth,options)}if("constructor"in value&&constructorMap.has(value.constructor)){return constructorMap.get(value.constructor)(value,options)}if(stringTagMap[type]){return stringTagMap[type](value,options)}return""};const lib_toString=Object.prototype.toString;function inspect(value,opts={}){const options=normaliseOptions(opts,inspect);const{customInspect}=options;let type=value===null?"null":typeof value;if(type==="object"){type=lib_toString.call(value).slice(8,-1)}if(type in baseTypesMap){return baseTypesMap[type](value,options)}if(customInspect&&value){const output=inspectCustom(value,options,type);if(output){if(typeof output==="string")return output;return inspect(output,options)}}const proto=value?Object.getPrototypeOf(value):false;if(proto===Object.prototype||proto===null){return inspectObject(value,options)}if(value&&typeof HTMLElement==="function"&&value instanceof HTMLElement){return inspectHTML(value,options)}if("constructor"in value){if(value.constructor!==Object){return inspectClass(value,options)}return inspectObject(value,options)}if(value===Object(value)){return inspectObject(value,options)}return options.stylize(String(value),type)}function registerConstructor(constructor,inspector){if(constructorMap.has(constructor)){return false}constructorMap.set(constructor,inspector);return true}function registerStringTag(stringTag,inspector){if(stringTag in stringTagMap){return false}stringTagMap[stringTag]=inspector;return true}const custom=null&&chaiInspect;const lib=null&&inspect;const config_config={includeStack:false,showDiff:true,truncateThreshold:40,useProxy:true,proxyExcludedKeys:["then","catch","inspect","toJSON"],deepEqual:null};function inspect_inspect(obj,showHidden,depth,colors){let options={colors,depth:typeof depth==="undefined"?2:depth,showHidden,truncate:config_config.truncateThreshold?config_config.truncateThreshold:Infinity};return inspect(obj,options)}
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function objDisplay(obj){let str=inspect_inspect(obj),type=Object.prototype.toString.call(obj);if(config_config.truncateThreshold&&str.length>=config_config.truncateThreshold){if(type==="[object Function]"){return!obj.name||obj.name===""?"[Function]":"[Function: "+obj.name+"]"}else if(type==="[object Array]"){return"[ Array("+obj.length+") ]"}else if(type==="[object Object]"){let keys=Object.keys(obj),kstr=keys.length>2?keys.splice(0,2).join(", ")+", ...":keys.join(", ");return"{ Object ("+kstr+") }"}else{return str}}else{return str}}
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function getMessage_getMessage(obj,args){let negate=flag_flag(obj,"negate");let val=flag_flag(obj,"object");let expected=args[3];let actual=getActual(obj,args);let msg=negate?args[2]:args[1];let flagMsg=flag_flag(obj,"message");if(typeof msg==="function")msg=msg();msg=msg||"";msg=msg.replace(/#\{this\}/g,function(){return objDisplay(val)}).replace(/#\{act\}/g,function(){return objDisplay(actual)}).replace(/#\{exp\}/g,function(){return objDisplay(expected)});return flagMsg?flagMsg+": "+msg:msg}
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function transferFlags(assertion,object,includeAll){let flags=assertion.__flags||(assertion.__flags=Object.create(null));if(!object.__flags){object.__flags=Object.create(null)}includeAll=arguments.length===3?includeAll:true;for(let flag in flags){if(includeAll||flag!=="object"&&flag!=="ssfi"&&flag!=="lockSsfi"&&flag!="message"){object.__flags[flag]=flags[flag]}}}
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function deep_eql_type(obj){if(typeof obj==="undefined"){return"undefined"}if(obj===null){return"null"}const stringTag=obj[Symbol.toStringTag];if(typeof stringTag==="string"){return stringTag}const sliceStart=8;const sliceEnd=-1;return Object.prototype.toString.call(obj).slice(sliceStart,sliceEnd)}function FakeMap(){this._key="chai/deep-eql__"+Math.random()+Date.now()}FakeMap.prototype={get:function get(key){return key[this._key]},set:function set(key,value){if(Object.isExtensible(key)){Object.defineProperty(key,this._key,{value,configurable:true})}}};var MemoizeMap=typeof WeakMap==="function"?WeakMap:FakeMap;
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/function memoizeCompare(leftHandOperand,rightHandOperand,memoizeMap){if(!memoizeMap||isPrimitive(leftHandOperand)||isPrimitive(rightHandOperand)){return null}var leftHandMap=memoizeMap.get(leftHandOperand);if(leftHandMap){var result=leftHandMap.get(rightHandOperand);if(typeof result==="boolean"){return result}}return null}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/function memoizeSet(leftHandOperand,rightHandOperand,memoizeMap,result){if(!memoizeMap||isPrimitive(leftHandOperand)||isPrimitive(rightHandOperand)){return}var leftHandMap=memoizeMap.get(leftHandOperand);if(leftHandMap){leftHandMap.set(rightHandOperand,result)}else{leftHandMap=new MemoizeMap;leftHandMap.set(rightHandOperand,result);memoizeMap.set(leftHandOperand,leftHandMap)}}
/*!
 * Primary Export
 */const deep_eql=deepEqual;function deepEqual(leftHandOperand,rightHandOperand,options){if(options&&options.comparator){return extensiveDeepEqual(leftHandOperand,rightHandOperand,options)}var simpleResult=simpleEqual(leftHandOperand,rightHandOperand);if(simpleResult!==null){return simpleResult}return extensiveDeepEqual(leftHandOperand,rightHandOperand,options)}function simpleEqual(leftHandOperand,rightHandOperand){if(leftHandOperand===rightHandOperand){return leftHandOperand!==0||1/leftHandOperand===1/rightHandOperand}if(leftHandOperand!==leftHandOperand&&rightHandOperand!==rightHandOperand){return true}if(isPrimitive(leftHandOperand)||isPrimitive(rightHandOperand)){return false}return null}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/function extensiveDeepEqual(leftHandOperand,rightHandOperand,options){options=options||{};options.memoize=options.memoize===false?false:options.memoize||new MemoizeMap;var comparator=options&&options.comparator;var memoizeResultLeft=memoizeCompare(leftHandOperand,rightHandOperand,options.memoize);if(memoizeResultLeft!==null){return memoizeResultLeft}var memoizeResultRight=memoizeCompare(rightHandOperand,leftHandOperand,options.memoize);if(memoizeResultRight!==null){return memoizeResultRight}if(comparator){var comparatorResult=comparator(leftHandOperand,rightHandOperand);if(comparatorResult===false||comparatorResult===true){memoizeSet(leftHandOperand,rightHandOperand,options.memoize,comparatorResult);return comparatorResult}var simpleResult=simpleEqual(leftHandOperand,rightHandOperand);if(simpleResult!==null){return simpleResult}}var leftHandType=deep_eql_type(leftHandOperand);if(leftHandType!==deep_eql_type(rightHandOperand)){memoizeSet(leftHandOperand,rightHandOperand,options.memoize,false);return false}memoizeSet(leftHandOperand,rightHandOperand,options.memoize,true);var result=extensiveDeepEqualByType(leftHandOperand,rightHandOperand,leftHandType,options);memoizeSet(leftHandOperand,rightHandOperand,options.memoize,result);return result}function extensiveDeepEqualByType(leftHandOperand,rightHandOperand,leftHandType,options){switch(leftHandType){case"String":case"Number":case"Boolean":case"Date":return deepEqual(leftHandOperand.valueOf(),rightHandOperand.valueOf());case"Promise":case"Symbol":case"function":case"WeakMap":case"WeakSet":return leftHandOperand===rightHandOperand;case"Error":return keysEqual(leftHandOperand,rightHandOperand,["name","message","code"],options);case"Arguments":case"Int8Array":case"Uint8Array":case"Uint8ClampedArray":case"Int16Array":case"Uint16Array":case"Int32Array":case"Uint32Array":case"Float32Array":case"Float64Array":case"Array":return iterableEqual(leftHandOperand,rightHandOperand,options);case"RegExp":return regexpEqual(leftHandOperand,rightHandOperand);case"Generator":return generatorEqual(leftHandOperand,rightHandOperand,options);case"DataView":return iterableEqual(new Uint8Array(leftHandOperand.buffer),new Uint8Array(rightHandOperand.buffer),options);case"ArrayBuffer":return iterableEqual(new Uint8Array(leftHandOperand),new Uint8Array(rightHandOperand),options);case"Set":return entriesEqual(leftHandOperand,rightHandOperand,options);case"Map":return entriesEqual(leftHandOperand,rightHandOperand,options);case"Temporal.PlainDate":case"Temporal.PlainTime":case"Temporal.PlainDateTime":case"Temporal.Instant":case"Temporal.ZonedDateTime":case"Temporal.PlainYearMonth":case"Temporal.PlainMonthDay":return leftHandOperand.equals(rightHandOperand);case"Temporal.Duration":return leftHandOperand.total("nanoseconds")===rightHandOperand.total("nanoseconds");case"Temporal.TimeZone":case"Temporal.Calendar":return leftHandOperand.toString()===rightHandOperand.toString();default:return objectEqual(leftHandOperand,rightHandOperand,options)}}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */function regexpEqual(leftHandOperand,rightHandOperand){return leftHandOperand.toString()===rightHandOperand.toString()}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function entriesEqual(leftHandOperand,rightHandOperand,options){try{if(leftHandOperand.size!==rightHandOperand.size){return false}if(leftHandOperand.size===0){return true}}catch(sizeError){return false}var leftHandItems=[];var rightHandItems=[];leftHandOperand.forEach(function gatherEntries(key,value){leftHandItems.push([key,value])});rightHandOperand.forEach(function gatherEntries(key,value){rightHandItems.push([key,value])});return iterableEqual(leftHandItems.sort(),rightHandItems.sort(),options)}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function iterableEqual(leftHandOperand,rightHandOperand,options){var length=leftHandOperand.length;if(length!==rightHandOperand.length){return false}if(length===0){return true}var index=-1;while(++index<length){if(deepEqual(leftHandOperand[index],rightHandOperand[index],options)===false){return false}}return true}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function generatorEqual(leftHandOperand,rightHandOperand,options){return iterableEqual(getGeneratorEntries(leftHandOperand),getGeneratorEntries(rightHandOperand),options)}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */function hasIteratorFunction(target){return typeof Symbol!=="undefined"&&typeof target==="object"&&typeof Symbol.iterator!=="undefined"&&typeof target[Symbol.iterator]==="function"}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */function getIteratorEntries(target){if(hasIteratorFunction(target)){try{return getGeneratorEntries(target[Symbol.iterator]())}catch(iteratorError){return[]}}return[]}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */function getGeneratorEntries(generator){var generatorResult=generator.next();var accumulator=[generatorResult.value];while(generatorResult.done===false){generatorResult=generator.next();accumulator.push(generatorResult.value)}return accumulator}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */function getEnumerableKeys(target){var keys=[];for(var key in target){keys.push(key)}return keys}function getEnumerableSymbols(target){var keys=[];var allKeys=Object.getOwnPropertySymbols(target);for(var i=0;i<allKeys.length;i+=1){var key=allKeys[i];if(Object.getOwnPropertyDescriptor(target,key).enumerable){keys.push(key)}}return keys}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function keysEqual(leftHandOperand,rightHandOperand,keys,options){var length=keys.length;if(length===0){return true}for(var i=0;i<length;i+=1){if(deepEqual(leftHandOperand[keys[i]],rightHandOperand[keys[i]],options)===false){return false}}return true}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function objectEqual(leftHandOperand,rightHandOperand,options){var leftHandKeys=getEnumerableKeys(leftHandOperand);var rightHandKeys=getEnumerableKeys(rightHandOperand);var leftHandSymbols=getEnumerableSymbols(leftHandOperand);var rightHandSymbols=getEnumerableSymbols(rightHandOperand);leftHandKeys=leftHandKeys.concat(leftHandSymbols);rightHandKeys=rightHandKeys.concat(rightHandSymbols);if(leftHandKeys.length&&leftHandKeys.length===rightHandKeys.length){if(iterableEqual(mapSymbols(leftHandKeys).sort(),mapSymbols(rightHandKeys).sort())===false){return false}return keysEqual(leftHandOperand,rightHandOperand,leftHandKeys,options)}var leftHandEntries=getIteratorEntries(leftHandOperand);var rightHandEntries=getIteratorEntries(rightHandOperand);if(leftHandEntries.length&&leftHandEntries.length===rightHandEntries.length){leftHandEntries.sort();rightHandEntries.sort();return iterableEqual(leftHandEntries,rightHandEntries,options)}if(leftHandKeys.length===0&&leftHandEntries.length===0&&rightHandKeys.length===0&&rightHandEntries.length===0){return true}return false}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */function isPrimitive(value){return value===null||typeof value!=="object"}function mapSymbols(arr){return arr.map(function mapSymbol(entry){if(typeof entry==="symbol"){return entry.toString()}return entry})}function pathval_hasProperty(obj,name){if(typeof obj==="undefined"||obj===null){return false}return name in Object(obj)}function parsePath(path){const str=path.replace(/([^\\])\[/g,"$1.[");const parts=str.match(/(\\\.|[^.]+?)+/g);return parts.map(value=>{if(value==="constructor"||value==="__proto__"||value==="prototype"){return{}}const regexp=/^\[(\d+)\]$/;const mArr=regexp.exec(value);let parsed=null;if(mArr){parsed={i:parseFloat(mArr[1])}}else{parsed={p:value.replace(/\\([.[\]])/g,"$1")}}return parsed})}function internalGetPathValue(obj,parsed,pathDepth){let temporaryValue=obj;let res=null;pathDepth=typeof pathDepth==="undefined"?parsed.length:pathDepth;for(let i=0;i<pathDepth;i++){const part=parsed[i];if(temporaryValue){if(typeof part.p==="undefined"){temporaryValue=temporaryValue[part.i]}else{temporaryValue=temporaryValue[part.p]}if(i===pathDepth-1){res=temporaryValue}}}return res}function internalSetPathValue(obj,val,parsed){let tempObj=obj;const pathDepth=parsed.length;let part=null;for(let i=0;i<pathDepth;i++){let propName=null;let propVal=null;part=parsed[i];if(i===pathDepth-1){propName=typeof part.p==="undefined"?part.i:part.p;tempObj[propName]=val}else if(typeof part.p!=="undefined"&&tempObj[part.p]){tempObj=tempObj[part.p]}else if(typeof part.i!=="undefined"&&tempObj[part.i]){tempObj=tempObj[part.i]}else{const next=parsed[i+1];propName=typeof part.p==="undefined"?part.i:part.p;propVal=typeof next.p==="undefined"?[]:{};tempObj[propName]=propVal;tempObj=tempObj[propName]}}}function getPathInfo(obj,path){const parsed=parsePath(path);const last=parsed[parsed.length-1];const info={parent:parsed.length>1?internalGetPathValue(obj,parsed,parsed.length-1):obj,name:last.p||last.i,value:internalGetPathValue(obj,parsed)};info.exists=pathval_hasProperty(info.parent,info.name);return info}function getPathValue(obj,path){const info=getPathInfo(obj,path);return info.value}function setPathValue(obj,path,val){const parsed=parsePath(path);internalSetPathValue(obj,val,parsed);return obj}
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
class assertion_Assertion{__flags={};constructor(obj,msg,ssfi,lockSsfi){flag_flag(this,"ssfi",ssfi||assertion_Assertion);flag_flag(this,"lockSsfi",lockSsfi);flag_flag(this,"object",obj);flag_flag(this,"message",msg);flag_flag(this,"eql",config_config.deepEqual||deep_eql);return proxify(this)}static get includeStack(){console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");return config_config.includeStack}static set includeStack(value){console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");config_config.includeStack=value}static get showDiff(){console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");return config_config.showDiff}static set showDiff(value){console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");config_config.showDiff=value}static addProperty(name,fn){addProperty(this.prototype,name,fn)}static addMethod(name,fn){addMethod(this.prototype,name,fn)}static addChainableMethod(name,fn,chainingBehavior){addChainableMethod(this.prototype,name,fn,chainingBehavior)}static overwriteProperty(name,fn){overwriteProperty(this.prototype,name,fn)}static overwriteMethod(name,fn){overwriteMethod(this.prototype,name,fn)}static overwriteChainableMethod(name,fn,chainingBehavior){overwriteChainableMethod(this.prototype,name,fn,chainingBehavior)}assert(_expr,msg,_negateMsg,expected,_actual,showDiff){const ok=test(this,arguments);if(false!==showDiff)showDiff=true;if(undefined===expected&&undefined===_actual)showDiff=false;if(true!==config_config.showDiff)showDiff=false;if(!ok){msg=getMessage_getMessage(this,arguments);const actual=getActual(this,arguments);const assertionErrorObjectProperties={actual,expected,showDiff};const operator=getOperator(this,arguments);if(operator){assertionErrorObjectProperties.operator=operator}throw new assertion_error_AssertionError(msg,assertionErrorObjectProperties,config_config.includeStack?this.assert:flag_flag(this,"ssfi"))}}get _obj(){return flag_flag(this,"object")}set _obj(val){flag_flag(this,"object",val)}}
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function isProxyEnabled(){return config_config.useProxy&&typeof Proxy!=="undefined"&&typeof Reflect!=="undefined"}
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function addProperty(ctx,name,getter){getter=getter===undefined?function(){}:getter;Object.defineProperty(ctx,name,{get:function propertyGetter(){if(!isProxyEnabled()&&!flag_flag(this,"lockSsfi")){flag_flag(this,"ssfi",propertyGetter)}let result=getter.call(this);if(result!==undefined)return result;let newAssertion=new assertion_Assertion;transferFlags(this,newAssertion);return newAssertion},configurable:true})}const fnLengthDesc=Object.getOwnPropertyDescriptor(function(){},"length");
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */function addLengthGuard(fn,assertionName,isChainable){if(!fnLengthDesc.configurable)return fn;Object.defineProperty(fn,"length",{get:function(){if(isChainable){throw Error("Invalid Chai property: "+assertionName+".length. Due"+' to a compatibility issue, "length" cannot directly follow "'+assertionName+'". Use "'+assertionName+'.lengthOf" instead.')}throw Error("Invalid Chai property: "+assertionName+".length. See"+' docs for proper usage of "'+assertionName+'".')}});return fn}
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function getProperties(object){let result=Object.getOwnPropertyNames(object);function addProperty(property){if(result.indexOf(property)===-1){result.push(property)}}let proto=Object.getPrototypeOf(object);while(proto!==null){Object.getOwnPropertyNames(proto).forEach(addProperty);proto=Object.getPrototypeOf(proto)}return result}
/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
const builtins=["__flags","__methods","_obj","assert"];function proxify(obj,nonChainableMethodName){if(!isProxyEnabled())return obj;return new Proxy(obj,{get:function proxyGetter(target,property){if(typeof property==="string"&&config_config.proxyExcludedKeys.indexOf(property)===-1&&!Reflect.has(target,property)){if(nonChainableMethodName){throw Error("Invalid Chai property: "+nonChainableMethodName+"."+property+'. See docs for proper usage of "'+nonChainableMethodName+'".')}let suggestion=null;let suggestionDistance=4;getProperties(target).forEach(function(prop){if(!Object.prototype.hasOwnProperty(prop)&&builtins.indexOf(prop)===-1){let dist=stringDistanceCapped(property,prop,suggestionDistance);if(dist<suggestionDistance){suggestion=prop;suggestionDistance=dist}}});if(suggestion!==null){throw Error("Invalid Chai property: "+property+'. Did you mean "'+suggestion+'"?')}else{throw Error("Invalid Chai property: "+property)}}if(builtins.indexOf(property)===-1&&!flag_flag(target,"lockSsfi")){flag_flag(target,"ssfi",proxyGetter)}return Reflect.get(target,property)}})}function stringDistanceCapped(strA,strB,cap){if(Math.abs(strA.length-strB.length)>=cap){return cap}let memo=[];for(let i=0;i<=strA.length;i++){memo[i]=Array(strB.length+1).fill(0);memo[i][0]=i}for(let j=0;j<strB.length;j++){memo[0][j]=j}for(let i=1;i<=strA.length;i++){let ch=strA.charCodeAt(i-1);for(let j=1;j<=strB.length;j++){if(Math.abs(i-j)>=cap){memo[i][j]=cap;continue}memo[i][j]=Math.min(memo[i-1][j]+1,memo[i][j-1]+1,memo[i-1][j-1]+(ch===strB.charCodeAt(j-1)?0:1))}}return memo[strA.length][strB.length]}
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function addMethod(ctx,name,method){let methodWrapper=function(){if(!flag_flag(this,"lockSsfi")){flag_flag(this,"ssfi",methodWrapper)}let result=method.apply(this,arguments);if(result!==undefined)return result;let newAssertion=new assertion_Assertion;transferFlags(this,newAssertion);return newAssertion};addLengthGuard(methodWrapper,name,false);ctx[name]=proxify(methodWrapper,name)}
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function overwriteProperty(ctx,name,getter){let _get=Object.getOwnPropertyDescriptor(ctx,name),_super=function(){};if(_get&&"function"===typeof _get.get)_super=_get.get;Object.defineProperty(ctx,name,{get:function overwritingPropertyGetter(){if(!isProxyEnabled()&&!flag_flag(this,"lockSsfi")){flag_flag(this,"ssfi",overwritingPropertyGetter)}let origLockSsfi=flag_flag(this,"lockSsfi");flag_flag(this,"lockSsfi",true);let result=getter(_super).call(this);flag_flag(this,"lockSsfi",origLockSsfi);if(result!==undefined){return result}let newAssertion=new assertion_Assertion;transferFlags(this,newAssertion);return newAssertion},configurable:true})}
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function overwriteMethod(ctx,name,method){let _method=ctx[name],_super=function(){throw new Error(name+" is not a function")};if(_method&&"function"===typeof _method)_super=_method;let overwritingMethodWrapper=function(){if(!flag_flag(this,"lockSsfi")){flag_flag(this,"ssfi",overwritingMethodWrapper)}let origLockSsfi=flag_flag(this,"lockSsfi");flag_flag(this,"lockSsfi",true);let result=method(_super).apply(this,arguments);flag_flag(this,"lockSsfi",origLockSsfi);if(result!==undefined){return result}let newAssertion=new assertion_Assertion;transferFlags(this,newAssertion);return newAssertion};addLengthGuard(overwritingMethodWrapper,name,false);ctx[name]=proxify(overwritingMethodWrapper,name)}
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
let canSetPrototype=typeof Object.setPrototypeOf==="function";let testFn=function(){};let excludeNames=Object.getOwnPropertyNames(testFn).filter(function(name){let propDesc=Object.getOwnPropertyDescriptor(testFn,name);if(typeof propDesc!=="object")return true;return!propDesc.configurable});let call=Function.prototype.call,apply=Function.prototype.apply;function addChainableMethod(ctx,name,method,chainingBehavior){if(typeof chainingBehavior!=="function"){chainingBehavior=function(){}}let chainableBehavior={method,chainingBehavior};if(!ctx.__methods){ctx.__methods={}}ctx.__methods[name]=chainableBehavior;Object.defineProperty(ctx,name,{get:function chainableMethodGetter(){chainableBehavior.chainingBehavior.call(this);let chainableMethodWrapper=function(){if(!flag_flag(this,"lockSsfi")){flag_flag(this,"ssfi",chainableMethodWrapper)}let result=chainableBehavior.method.apply(this,arguments);if(result!==undefined){return result}let newAssertion=new assertion_Assertion;transferFlags(this,newAssertion);return newAssertion};addLengthGuard(chainableMethodWrapper,name,true);if(canSetPrototype){let prototype=Object.create(this);prototype.call=call;prototype.apply=apply;Object.setPrototypeOf(chainableMethodWrapper,prototype)}else{let asserterNames=Object.getOwnPropertyNames(ctx);asserterNames.forEach(function(asserterName){if(excludeNames.indexOf(asserterName)!==-1){return}let pd=Object.getOwnPropertyDescriptor(ctx,asserterName);Object.defineProperty(chainableMethodWrapper,asserterName,pd)})}transferFlags(this,chainableMethodWrapper);return proxify(chainableMethodWrapper)},configurable:true})}
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function overwriteChainableMethod(ctx,name,method,chainingBehavior){let chainableBehavior=ctx.__methods[name];let _chainingBehavior=chainableBehavior.chainingBehavior;chainableBehavior.chainingBehavior=function overwritingChainableMethodGetter(){let result=chainingBehavior(_chainingBehavior).call(this);if(result!==undefined){return result}let newAssertion=new assertion_Assertion;transferFlags(this,newAssertion);return newAssertion};let _method=chainableBehavior.method;chainableBehavior.method=function overwritingChainableMethodWrapper(){let result=method(_method).apply(this,arguments);if(result!==undefined){return result}let newAssertion=new assertion_Assertion;transferFlags(this,newAssertion);return newAssertion}}
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function compareByInspect(a,b){return inspect_inspect(a)<inspect_inspect(b)?-1:1}
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function getOwnEnumerablePropertySymbols(obj){if(typeof Object.getOwnPropertySymbols!=="function")return[];return Object.getOwnPropertySymbols(obj).filter(function(sym){return Object.getOwnPropertyDescriptor(obj,sym).enumerable})}
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function getOwnEnumerableProperties(obj){return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj))}
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */
const isNaN_isNaN=Number.isNaN;function isObjectType(obj){let objectType=type_detect_type(obj);let objectTypes=["Array","Object","Function"];return objectTypes.indexOf(objectType)!==-1}function getOperator(obj,args){let operator=flag_flag(obj,"operator");let negate=flag_flag(obj,"negate");let expected=args[3];let msg=negate?args[2]:args[1];if(operator){return operator}if(typeof msg==="function")msg=msg();msg=msg||"";if(!msg){return undefined}if(/\shave\s/.test(msg)){return undefined}let isObject=isObjectType(expected);if(/\snot\s/.test(msg)){return isObject?"notDeepStrictEqual":"notStrictEqual"}return isObject?"deepStrictEqual":"strictEqual"}
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function getName(fn){return fn.name}function utils_isRegExp(obj){return Object.prototype.toString.call(obj)==="[object RegExp]"}function isNumeric(obj){return["Number","BigInt"].includes(type_detect_type(obj))}
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
const{Jt:assertions_flag}=utils_namespaceObject;["to","be","been","is","and","has","have","with","that","which","at","of","same","but","does","still","also"].forEach(function(chain){assertion_Assertion.addProperty(chain)});assertion_Assertion.addProperty("not",function(){assertions_flag(this,"negate",true)});assertion_Assertion.addProperty("deep",function(){assertions_flag(this,"deep",true)});assertion_Assertion.addProperty("nested",function(){assertions_flag(this,"nested",true)});assertion_Assertion.addProperty("own",function(){assertions_flag(this,"own",true)});assertion_Assertion.addProperty("ordered",function(){assertions_flag(this,"ordered",true)});assertion_Assertion.addProperty("any",function(){assertions_flag(this,"any",true);assertions_flag(this,"all",false)});assertion_Assertion.addProperty("all",function(){assertions_flag(this,"all",true);assertions_flag(this,"any",false)});const functionTypes={function:["function","asyncfunction","generatorfunction","asyncgeneratorfunction"],asyncfunction:["asyncfunction","asyncgeneratorfunction"],generatorfunction:["generatorfunction","asyncgeneratorfunction"],asyncgeneratorfunction:["asyncgeneratorfunction"]};function an(type,msg){if(msg)assertions_flag(this,"message",msg);type=type.toLowerCase();let obj=assertions_flag(this,"object"),article=~["a","e","i","o","u"].indexOf(type.charAt(0))?"an ":"a ";const detectedType=type_detect_type(obj).toLowerCase();if(functionTypes["function"].includes(type)){this.assert(functionTypes[type].includes(detectedType),"expected #{this} to be "+article+type,"expected #{this} not to be "+article+type)}else{this.assert(type===detectedType,"expected #{this} to be "+article+type,"expected #{this} not to be "+article+type)}}assertion_Assertion.addChainableMethod("an",an);assertion_Assertion.addChainableMethod("a",an);function SameValueZero(a,b){return isNaN_isNaN(a)&&isNaN_isNaN(b)||a===b}function includeChainingBehavior(){assertions_flag(this,"contains",true)}function include(val,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object"),objType=type_detect_type(obj).toLowerCase(),flagMsg=assertions_flag(this,"message"),negate=assertions_flag(this,"negate"),ssfi=assertions_flag(this,"ssfi"),isDeep=assertions_flag(this,"deep"),descriptor=isDeep?"deep ":"",isEql=isDeep?assertions_flag(this,"eql"):SameValueZero;flagMsg=flagMsg?flagMsg+": ":"";let included=false;switch(objType){case"string":included=obj.indexOf(val)!==-1;break;case"weakset":if(isDeep){throw new assertion_error_AssertionError(flagMsg+"unable to use .deep.include with WeakSet",undefined,ssfi)}included=obj.has(val);break;case"map":obj.forEach(function(item){included=included||isEql(item,val)});break;case"set":if(isDeep){obj.forEach(function(item){included=included||isEql(item,val)})}else{included=obj.has(val)}break;case"array":if(isDeep){included=obj.some(function(item){return isEql(item,val)})}else{included=obj.indexOf(val)!==-1}break;default:{if(val!==Object(val)){throw new assertion_error_AssertionError(flagMsg+"the given combination of arguments ("+objType+" and "+type_detect_type(val).toLowerCase()+")"+" is invalid for this assertion. "+"You can use an array, a map, an object, a set, a string, "+"or a weakset instead of a "+type_detect_type(val).toLowerCase(),undefined,ssfi)}let props=Object.keys(val);let firstErr=null;let numErrs=0;props.forEach(function(prop){let propAssertion=new assertion_Assertion(obj);transferFlags(this,propAssertion,true);assertions_flag(propAssertion,"lockSsfi",true);if(!negate||props.length===1){propAssertion.property(prop,val[prop]);return}try{propAssertion.property(prop,val[prop])}catch(err){if(!compatibleConstructor(err,assertion_error_AssertionError)){throw err}if(firstErr===null)firstErr=err;numErrs++}},this);if(negate&&props.length>1&&numErrs===props.length){throw firstErr}return}}this.assert(included,"expected #{this} to "+descriptor+"include "+inspect_inspect(val),"expected #{this} to not "+descriptor+"include "+inspect_inspect(val))}assertion_Assertion.addChainableMethod("include",include,includeChainingBehavior);assertion_Assertion.addChainableMethod("contain",include,includeChainingBehavior);assertion_Assertion.addChainableMethod("contains",include,includeChainingBehavior);assertion_Assertion.addChainableMethod("includes",include,includeChainingBehavior);assertion_Assertion.addProperty("ok",function(){this.assert(assertions_flag(this,"object"),"expected #{this} to be truthy","expected #{this} to be falsy")});assertion_Assertion.addProperty("true",function(){this.assert(true===assertions_flag(this,"object"),"expected #{this} to be true","expected #{this} to be false",assertions_flag(this,"negate")?false:true)});assertion_Assertion.addProperty("numeric",function(){const object=assertions_flag(this,"object");this.assert(["Number","BigInt"].includes(type_detect_type(object)),"expected #{this} to be numeric","expected #{this} to not be numeric",assertions_flag(this,"negate")?false:true)});assertion_Assertion.addProperty("callable",function(){const val=assertions_flag(this,"object");const ssfi=assertions_flag(this,"ssfi");const message=assertions_flag(this,"message");const msg=message?`${message}: `:"";const negate=assertions_flag(this,"negate");const assertionMessage=negate?`${msg}expected ${inspect_inspect(val)} not to be a callable function`:`${msg}expected ${inspect_inspect(val)} to be a callable function`;const isCallable=["Function","AsyncFunction","GeneratorFunction","AsyncGeneratorFunction"].includes(type_detect_type(val));if(isCallable&&negate||!isCallable&&!negate){throw new assertion_error_AssertionError(assertionMessage,undefined,ssfi)}});assertion_Assertion.addProperty("false",function(){this.assert(false===assertions_flag(this,"object"),"expected #{this} to be false","expected #{this} to be true",assertions_flag(this,"negate")?true:false)});assertion_Assertion.addProperty("null",function(){this.assert(null===assertions_flag(this,"object"),"expected #{this} to be null","expected #{this} not to be null")});assertion_Assertion.addProperty("undefined",function(){this.assert(undefined===assertions_flag(this,"object"),"expected #{this} to be undefined","expected #{this} not to be undefined")});assertion_Assertion.addProperty("NaN",function(){this.assert(isNaN_isNaN(assertions_flag(this,"object")),"expected #{this} to be NaN","expected #{this} not to be NaN")});function assertExist(){let val=assertions_flag(this,"object");this.assert(val!==null&&val!==undefined,"expected #{this} to exist","expected #{this} to not exist")}assertion_Assertion.addProperty("exist",assertExist);assertion_Assertion.addProperty("exists",assertExist);assertion_Assertion.addProperty("empty",function(){let val=assertions_flag(this,"object"),ssfi=assertions_flag(this,"ssfi"),flagMsg=assertions_flag(this,"message"),itemsCount;flagMsg=flagMsg?flagMsg+": ":"";switch(type_detect_type(val).toLowerCase()){case"array":case"string":itemsCount=val.length;break;case"map":case"set":itemsCount=val.size;break;case"weakmap":case"weakset":throw new assertion_error_AssertionError(flagMsg+".empty was passed a weak collection",undefined,ssfi);case"function":{const msg=flagMsg+".empty was passed a function "+getName(val);throw new assertion_error_AssertionError(msg.trim(),undefined,ssfi)}default:if(val!==Object(val)){throw new assertion_error_AssertionError(flagMsg+".empty was passed non-string primitive "+inspect_inspect(val),undefined,ssfi)}itemsCount=Object.keys(val).length}this.assert(0===itemsCount,"expected #{this} to be empty","expected #{this} not to be empty")});function checkArguments(){let obj=assertions_flag(this,"object"),type=type_detect_type(obj);this.assert("Arguments"===type,"expected #{this} to be arguments but got "+type,"expected #{this} to not be arguments")}assertion_Assertion.addProperty("arguments",checkArguments);assertion_Assertion.addProperty("Arguments",checkArguments);function assertEqual(val,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object");if(assertions_flag(this,"deep")){let prevLockSsfi=assertions_flag(this,"lockSsfi");assertions_flag(this,"lockSsfi",true);this.eql(val);assertions_flag(this,"lockSsfi",prevLockSsfi)}else{this.assert(val===obj,"expected #{this} to equal #{exp}","expected #{this} to not equal #{exp}",val,this._obj,true)}}assertion_Assertion.addMethod("equal",assertEqual);assertion_Assertion.addMethod("equals",assertEqual);assertion_Assertion.addMethod("eq",assertEqual);function assertEql(obj,msg){if(msg)assertions_flag(this,"message",msg);let eql=assertions_flag(this,"eql");this.assert(eql(obj,assertions_flag(this,"object")),"expected #{this} to deeply equal #{exp}","expected #{this} to not deeply equal #{exp}",obj,this._obj,true)}assertion_Assertion.addMethod("eql",assertEql);assertion_Assertion.addMethod("eqls",assertEql);function assertAbove(n,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object"),doLength=assertions_flag(this,"doLength"),flagMsg=assertions_flag(this,"message"),msgPrefix=flagMsg?flagMsg+": ":"",ssfi=assertions_flag(this,"ssfi"),objType=type_detect_type(obj).toLowerCase(),nType=type_detect_type(n).toLowerCase();if(doLength&&objType!=="map"&&objType!=="set"){new assertion_Assertion(obj,flagMsg,ssfi,true).to.have.property("length")}if(!doLength&&objType==="date"&&nType!=="date"){throw new assertion_error_AssertionError(msgPrefix+"the argument to above must be a date",undefined,ssfi)}else if(!isNumeric(n)&&(doLength||isNumeric(obj))){throw new assertion_error_AssertionError(msgPrefix+"the argument to above must be a number",undefined,ssfi)}else if(!doLength&&objType!=="date"&&!isNumeric(obj)){let printObj=objType==="string"?"'"+obj+"'":obj;throw new assertion_error_AssertionError(msgPrefix+"expected "+printObj+" to be a number or a date",undefined,ssfi)}if(doLength){let descriptor="length",itemsCount;if(objType==="map"||objType==="set"){descriptor="size";itemsCount=obj.size}else{itemsCount=obj.length}this.assert(itemsCount>n,"expected #{this} to have a "+descriptor+" above #{exp} but got #{act}","expected #{this} to not have a "+descriptor+" above #{exp}",n,itemsCount)}else{this.assert(obj>n,"expected #{this} to be above #{exp}","expected #{this} to be at most #{exp}",n)}}assertion_Assertion.addMethod("above",assertAbove);assertion_Assertion.addMethod("gt",assertAbove);assertion_Assertion.addMethod("greaterThan",assertAbove);function assertLeast(n,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object"),doLength=assertions_flag(this,"doLength"),flagMsg=assertions_flag(this,"message"),msgPrefix=flagMsg?flagMsg+": ":"",ssfi=assertions_flag(this,"ssfi"),objType=type_detect_type(obj).toLowerCase(),nType=type_detect_type(n).toLowerCase(),errorMessage,shouldThrow=true;if(doLength&&objType!=="map"&&objType!=="set"){new assertion_Assertion(obj,flagMsg,ssfi,true).to.have.property("length")}if(!doLength&&objType==="date"&&nType!=="date"){errorMessage=msgPrefix+"the argument to least must be a date"}else if(!isNumeric(n)&&(doLength||isNumeric(obj))){errorMessage=msgPrefix+"the argument to least must be a number"}else if(!doLength&&objType!=="date"&&!isNumeric(obj)){let printObj=objType==="string"?"'"+obj+"'":obj;errorMessage=msgPrefix+"expected "+printObj+" to be a number or a date"}else{shouldThrow=false}if(shouldThrow){throw new assertion_error_AssertionError(errorMessage,undefined,ssfi)}if(doLength){let descriptor="length",itemsCount;if(objType==="map"||objType==="set"){descriptor="size";itemsCount=obj.size}else{itemsCount=obj.length}this.assert(itemsCount>=n,"expected #{this} to have a "+descriptor+" at least #{exp} but got #{act}","expected #{this} to have a "+descriptor+" below #{exp}",n,itemsCount)}else{this.assert(obj>=n,"expected #{this} to be at least #{exp}","expected #{this} to be below #{exp}",n)}}assertion_Assertion.addMethod("least",assertLeast);assertion_Assertion.addMethod("gte",assertLeast);assertion_Assertion.addMethod("greaterThanOrEqual",assertLeast);function assertBelow(n,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object"),doLength=assertions_flag(this,"doLength"),flagMsg=assertions_flag(this,"message"),msgPrefix=flagMsg?flagMsg+": ":"",ssfi=assertions_flag(this,"ssfi"),objType=type_detect_type(obj).toLowerCase(),nType=type_detect_type(n).toLowerCase(),errorMessage,shouldThrow=true;if(doLength&&objType!=="map"&&objType!=="set"){new assertion_Assertion(obj,flagMsg,ssfi,true).to.have.property("length")}if(!doLength&&objType==="date"&&nType!=="date"){errorMessage=msgPrefix+"the argument to below must be a date"}else if(!isNumeric(n)&&(doLength||isNumeric(obj))){errorMessage=msgPrefix+"the argument to below must be a number"}else if(!doLength&&objType!=="date"&&!isNumeric(obj)){let printObj=objType==="string"?"'"+obj+"'":obj;errorMessage=msgPrefix+"expected "+printObj+" to be a number or a date"}else{shouldThrow=false}if(shouldThrow){throw new assertion_error_AssertionError(errorMessage,undefined,ssfi)}if(doLength){let descriptor="length",itemsCount;if(objType==="map"||objType==="set"){descriptor="size";itemsCount=obj.size}else{itemsCount=obj.length}this.assert(itemsCount<n,"expected #{this} to have a "+descriptor+" below #{exp} but got #{act}","expected #{this} to not have a "+descriptor+" below #{exp}",n,itemsCount)}else{this.assert(obj<n,"expected #{this} to be below #{exp}","expected #{this} to be at least #{exp}",n)}}assertion_Assertion.addMethod("below",assertBelow);assertion_Assertion.addMethod("lt",assertBelow);assertion_Assertion.addMethod("lessThan",assertBelow);function assertMost(n,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object"),doLength=assertions_flag(this,"doLength"),flagMsg=assertions_flag(this,"message"),msgPrefix=flagMsg?flagMsg+": ":"",ssfi=assertions_flag(this,"ssfi"),objType=type_detect_type(obj).toLowerCase(),nType=type_detect_type(n).toLowerCase(),errorMessage,shouldThrow=true;if(doLength&&objType!=="map"&&objType!=="set"){new assertion_Assertion(obj,flagMsg,ssfi,true).to.have.property("length")}if(!doLength&&objType==="date"&&nType!=="date"){errorMessage=msgPrefix+"the argument to most must be a date"}else if(!isNumeric(n)&&(doLength||isNumeric(obj))){errorMessage=msgPrefix+"the argument to most must be a number"}else if(!doLength&&objType!=="date"&&!isNumeric(obj)){let printObj=objType==="string"?"'"+obj+"'":obj;errorMessage=msgPrefix+"expected "+printObj+" to be a number or a date"}else{shouldThrow=false}if(shouldThrow){throw new assertion_error_AssertionError(errorMessage,undefined,ssfi)}if(doLength){let descriptor="length",itemsCount;if(objType==="map"||objType==="set"){descriptor="size";itemsCount=obj.size}else{itemsCount=obj.length}this.assert(itemsCount<=n,"expected #{this} to have a "+descriptor+" at most #{exp} but got #{act}","expected #{this} to have a "+descriptor+" above #{exp}",n,itemsCount)}else{this.assert(obj<=n,"expected #{this} to be at most #{exp}","expected #{this} to be above #{exp}",n)}}assertion_Assertion.addMethod("most",assertMost);assertion_Assertion.addMethod("lte",assertMost);assertion_Assertion.addMethod("lessThanOrEqual",assertMost);assertion_Assertion.addMethod("within",function(start,finish,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object"),doLength=assertions_flag(this,"doLength"),flagMsg=assertions_flag(this,"message"),msgPrefix=flagMsg?flagMsg+": ":"",ssfi=assertions_flag(this,"ssfi"),objType=type_detect_type(obj).toLowerCase(),startType=type_detect_type(start).toLowerCase(),finishType=type_detect_type(finish).toLowerCase(),errorMessage,shouldThrow=true,range=startType==="date"&&finishType==="date"?start.toISOString()+".."+finish.toISOString():start+".."+finish;if(doLength&&objType!=="map"&&objType!=="set"){new assertion_Assertion(obj,flagMsg,ssfi,true).to.have.property("length")}if(!doLength&&objType==="date"&&(startType!=="date"||finishType!=="date")){errorMessage=msgPrefix+"the arguments to within must be dates"}else if((!isNumeric(start)||!isNumeric(finish))&&(doLength||isNumeric(obj))){errorMessage=msgPrefix+"the arguments to within must be numbers"}else if(!doLength&&objType!=="date"&&!isNumeric(obj)){let printObj=objType==="string"?"'"+obj+"'":obj;errorMessage=msgPrefix+"expected "+printObj+" to be a number or a date"}else{shouldThrow=false}if(shouldThrow){throw new assertion_error_AssertionError(errorMessage,undefined,ssfi)}if(doLength){let descriptor="length",itemsCount;if(objType==="map"||objType==="set"){descriptor="size";itemsCount=obj.size}else{itemsCount=obj.length}this.assert(itemsCount>=start&&itemsCount<=finish,"expected #{this} to have a "+descriptor+" within "+range,"expected #{this} to not have a "+descriptor+" within "+range)}else{this.assert(obj>=start&&obj<=finish,"expected #{this} to be within "+range,"expected #{this} to not be within "+range)}});function assertInstanceOf(constructor,msg){if(msg)assertions_flag(this,"message",msg);let target=assertions_flag(this,"object");let ssfi=assertions_flag(this,"ssfi");let flagMsg=assertions_flag(this,"message");let isInstanceOf;try{isInstanceOf=target instanceof constructor}catch(err){if(err instanceof TypeError){flagMsg=flagMsg?flagMsg+": ":"";throw new assertion_error_AssertionError(flagMsg+"The instanceof assertion needs a constructor but "+type_detect_type(constructor)+" was given.",undefined,ssfi)}throw err}let name=getName(constructor);if(name==null){name="an unnamed constructor"}this.assert(isInstanceOf,"expected #{this} to be an instance of "+name,"expected #{this} to not be an instance of "+name)}assertion_Assertion.addMethod("instanceof",assertInstanceOf);assertion_Assertion.addMethod("instanceOf",assertInstanceOf);function assertProperty(name,val,msg){if(msg)assertions_flag(this,"message",msg);let isNested=assertions_flag(this,"nested"),isOwn=assertions_flag(this,"own"),flagMsg=assertions_flag(this,"message"),obj=assertions_flag(this,"object"),ssfi=assertions_flag(this,"ssfi"),nameType=typeof name;flagMsg=flagMsg?flagMsg+": ":"";if(isNested){if(nameType!=="string"){throw new assertion_error_AssertionError(flagMsg+"the argument to property must be a string when using nested syntax",undefined,ssfi)}}else{if(nameType!=="string"&&nameType!=="number"&&nameType!=="symbol"){throw new assertion_error_AssertionError(flagMsg+"the argument to property must be a string, number, or symbol",undefined,ssfi)}}if(isNested&&isOwn){throw new assertion_error_AssertionError(flagMsg+'The "nested" and "own" flags cannot be combined.',undefined,ssfi)}if(obj===null||obj===undefined){throw new assertion_error_AssertionError(flagMsg+"Target cannot be null or undefined.",undefined,ssfi)}let isDeep=assertions_flag(this,"deep"),negate=assertions_flag(this,"negate"),pathInfo=isNested?getPathInfo(obj,name):null,value=isNested?pathInfo.value:obj[name],isEql=isDeep?assertions_flag(this,"eql"):(val1,val2)=>val1===val2;let descriptor="";if(isDeep)descriptor+="deep ";if(isOwn)descriptor+="own ";if(isNested)descriptor+="nested ";descriptor+="property ";let hasProperty;if(isOwn)hasProperty=Object.prototype.hasOwnProperty.call(obj,name);else if(isNested)hasProperty=pathInfo.exists;else hasProperty=pathval_hasProperty(obj,name);if(!negate||arguments.length===1){this.assert(hasProperty,"expected #{this} to have "+descriptor+inspect_inspect(name),"expected #{this} to not have "+descriptor+inspect_inspect(name))}if(arguments.length>1){this.assert(hasProperty&&isEql(val,value),"expected #{this} to have "+descriptor+inspect_inspect(name)+" of #{exp}, but got #{act}","expected #{this} to not have "+descriptor+inspect_inspect(name)+" of #{act}",val,value)}assertions_flag(this,"object",value)}assertion_Assertion.addMethod("property",assertProperty);function assertOwnProperty(_name,_value,_msg){assertions_flag(this,"own",true);assertProperty.apply(this,arguments)}assertion_Assertion.addMethod("ownProperty",assertOwnProperty);assertion_Assertion.addMethod("haveOwnProperty",assertOwnProperty);function assertOwnPropertyDescriptor(name,descriptor,msg){if(typeof descriptor==="string"){msg=descriptor;descriptor=null}if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object");let actualDescriptor=Object.getOwnPropertyDescriptor(Object(obj),name);let eql=assertions_flag(this,"eql");if(actualDescriptor&&descriptor){this.assert(eql(descriptor,actualDescriptor),"expected the own property descriptor for "+inspect_inspect(name)+" on #{this} to match "+inspect_inspect(descriptor)+", got "+inspect_inspect(actualDescriptor),"expected the own property descriptor for "+inspect_inspect(name)+" on #{this} to not match "+inspect_inspect(descriptor),descriptor,actualDescriptor,true)}else{this.assert(actualDescriptor,"expected #{this} to have an own property descriptor for "+inspect_inspect(name),"expected #{this} to not have an own property descriptor for "+inspect_inspect(name))}assertions_flag(this,"object",actualDescriptor)}assertion_Assertion.addMethod("ownPropertyDescriptor",assertOwnPropertyDescriptor);assertion_Assertion.addMethod("haveOwnPropertyDescriptor",assertOwnPropertyDescriptor);function assertLengthChain(){assertions_flag(this,"doLength",true)}function assertLength(n,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object"),objType=type_detect_type(obj).toLowerCase(),flagMsg=assertions_flag(this,"message"),ssfi=assertions_flag(this,"ssfi"),descriptor="length",itemsCount;switch(objType){case"map":case"set":descriptor="size";itemsCount=obj.size;break;default:new assertion_Assertion(obj,flagMsg,ssfi,true).to.have.property("length");itemsCount=obj.length}this.assert(itemsCount==n,"expected #{this} to have a "+descriptor+" of #{exp} but got #{act}","expected #{this} to not have a "+descriptor+" of #{act}",n,itemsCount)}assertion_Assertion.addChainableMethod("length",assertLength,assertLengthChain);assertion_Assertion.addChainableMethod("lengthOf",assertLength,assertLengthChain);function assertMatch(re,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object");this.assert(re.exec(obj),"expected #{this} to match "+re,"expected #{this} not to match "+re)}assertion_Assertion.addMethod("match",assertMatch);assertion_Assertion.addMethod("matches",assertMatch);assertion_Assertion.addMethod("string",function(str,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object"),flagMsg=assertions_flag(this,"message"),ssfi=assertions_flag(this,"ssfi");new assertion_Assertion(obj,flagMsg,ssfi,true).is.a("string");this.assert(~obj.indexOf(str),"expected #{this} to contain "+inspect_inspect(str),"expected #{this} to not contain "+inspect_inspect(str))});function assertKeys(keys){let obj=assertions_flag(this,"object"),objType=type_detect_type(obj),keysType=type_detect_type(keys),ssfi=assertions_flag(this,"ssfi"),isDeep=assertions_flag(this,"deep"),str,deepStr="",actual,ok=true,flagMsg=assertions_flag(this,"message");flagMsg=flagMsg?flagMsg+": ":"";let mixedArgsMsg=flagMsg+"when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";if(objType==="Map"||objType==="Set"){deepStr=isDeep?"deeply ":"";actual=[];obj.forEach(function(val,key){actual.push(key)});if(keysType!=="Array"){keys=Array.prototype.slice.call(arguments)}}else{actual=getOwnEnumerableProperties(obj);switch(keysType){case"Array":if(arguments.length>1){throw new assertion_error_AssertionError(mixedArgsMsg,undefined,ssfi)}break;case"Object":if(arguments.length>1){throw new assertion_error_AssertionError(mixedArgsMsg,undefined,ssfi)}keys=Object.keys(keys);break;default:keys=Array.prototype.slice.call(arguments)}keys=keys.map(function(val){return typeof val==="symbol"?val:String(val)})}if(!keys.length){throw new assertion_error_AssertionError(flagMsg+"keys required",undefined,ssfi)}let len=keys.length,any=assertions_flag(this,"any"),all=assertions_flag(this,"all"),expected=keys,isEql=isDeep?assertions_flag(this,"eql"):(val1,val2)=>val1===val2;if(!any&&!all){all=true}if(any){ok=expected.some(function(expectedKey){return actual.some(function(actualKey){return isEql(expectedKey,actualKey)})})}if(all){ok=expected.every(function(expectedKey){return actual.some(function(actualKey){return isEql(expectedKey,actualKey)})});if(!assertions_flag(this,"contains")){ok=ok&&keys.length==actual.length}}if(len>1){keys=keys.map(function(key){return inspect_inspect(key)});let last=keys.pop();if(all){str=keys.join(", ")+", and "+last}if(any){str=keys.join(", ")+", or "+last}}else{str=inspect_inspect(keys[0])}str=(len>1?"keys ":"key ")+str;str=(assertions_flag(this,"contains")?"contain ":"have ")+str;this.assert(ok,"expected #{this} to "+deepStr+str,"expected #{this} to not "+deepStr+str,expected.slice(0).sort(compareByInspect),actual.sort(compareByInspect),true)}assertion_Assertion.addMethod("keys",assertKeys);assertion_Assertion.addMethod("key",assertKeys);function assertThrows(errorLike,errMsgMatcher,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object"),ssfi=assertions_flag(this,"ssfi"),flagMsg=assertions_flag(this,"message"),negate=assertions_flag(this,"negate")||false;new assertion_Assertion(obj,flagMsg,ssfi,true).is.a("function");if(utils_isRegExp(errorLike)||typeof errorLike==="string"){errMsgMatcher=errorLike;errorLike=null}let caughtErr;let errorWasThrown=false;try{obj()}catch(err){errorWasThrown=true;caughtErr=err}let everyArgIsUndefined=errorLike===undefined&&errMsgMatcher===undefined;let everyArgIsDefined=Boolean(errorLike&&errMsgMatcher);let errorLikeFail=false;let errMsgMatcherFail=false;if(everyArgIsUndefined||!everyArgIsUndefined&&!negate){let errorLikeString="an error";if(errorLike instanceof Error){errorLikeString="#{exp}"}else if(errorLike){errorLikeString=getConstructorName(errorLike)}let actual=caughtErr;if(caughtErr instanceof Error){actual=caughtErr.toString()}else if(typeof caughtErr==="string"){actual=caughtErr}else if(caughtErr&&(typeof caughtErr==="object"||typeof caughtErr==="function")){try{actual=getConstructorName(caughtErr)}catch(_err){}}this.assert(errorWasThrown,"expected #{this} to throw "+errorLikeString,"expected #{this} to not throw an error but #{act} was thrown",errorLike&&errorLike.toString(),actual)}if(errorLike&&caughtErr){if(errorLike instanceof Error){let isCompatibleInstance=compatibleInstance(caughtErr,errorLike);if(isCompatibleInstance===negate){if(everyArgIsDefined&&negate){errorLikeFail=true}else{this.assert(negate,"expected #{this} to throw #{exp} but #{act} was thrown","expected #{this} to not throw #{exp}"+(caughtErr&&!negate?" but #{act} was thrown":""),errorLike.toString(),caughtErr.toString())}}}let isCompatibleConstructor=compatibleConstructor(caughtErr,errorLike);if(isCompatibleConstructor===negate){if(everyArgIsDefined&&negate){errorLikeFail=true}else{this.assert(negate,"expected #{this} to throw #{exp} but #{act} was thrown","expected #{this} to not throw #{exp}"+(caughtErr?" but #{act} was thrown":""),errorLike instanceof Error?errorLike.toString():errorLike&&getConstructorName(errorLike),caughtErr instanceof Error?caughtErr.toString():caughtErr&&getConstructorName(caughtErr))}}}if(caughtErr&&errMsgMatcher!==undefined&&errMsgMatcher!==null){let placeholder="including";if(utils_isRegExp(errMsgMatcher)){placeholder="matching"}let isCompatibleMessage=compatibleMessage(caughtErr,errMsgMatcher);if(isCompatibleMessage===negate){if(everyArgIsDefined&&negate){errMsgMatcherFail=true}else{this.assert(negate,"expected #{this} to throw error "+placeholder+" #{exp} but got #{act}","expected #{this} to throw error not "+placeholder+" #{exp}",errMsgMatcher,getMessage(caughtErr))}}}if(errorLikeFail&&errMsgMatcherFail){this.assert(negate,"expected #{this} to throw #{exp} but #{act} was thrown","expected #{this} to not throw #{exp}"+(caughtErr?" but #{act} was thrown":""),errorLike instanceof Error?errorLike.toString():errorLike&&getConstructorName(errorLike),caughtErr instanceof Error?caughtErr.toString():caughtErr&&getConstructorName(caughtErr))}assertions_flag(this,"object",caughtErr)}assertion_Assertion.addMethod("throw",assertThrows);assertion_Assertion.addMethod("throws",assertThrows);assertion_Assertion.addMethod("Throw",assertThrows);function respondTo(method,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object"),itself=assertions_flag(this,"itself"),context="function"===typeof obj&&!itself?obj.prototype[method]:obj[method];this.assert("function"===typeof context,"expected #{this} to respond to "+inspect_inspect(method),"expected #{this} to not respond to "+inspect_inspect(method))}assertion_Assertion.addMethod("respondTo",respondTo);assertion_Assertion.addMethod("respondsTo",respondTo);assertion_Assertion.addProperty("itself",function(){assertions_flag(this,"itself",true)});function satisfy(matcher,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object");let result=matcher(obj);this.assert(result,"expected #{this} to satisfy "+objDisplay(matcher),"expected #{this} to not satisfy"+objDisplay(matcher),assertions_flag(this,"negate")?false:true,result)}assertion_Assertion.addMethod("satisfy",satisfy);assertion_Assertion.addMethod("satisfies",satisfy);function closeTo(expected,delta,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object"),flagMsg=assertions_flag(this,"message"),ssfi=assertions_flag(this,"ssfi");new assertion_Assertion(obj,flagMsg,ssfi,true).is.numeric;let message="A `delta` value is required for `closeTo`";if(delta==undefined){throw new assertion_error_AssertionError(flagMsg?`${flagMsg}: ${message}`:message,undefined,ssfi)}new assertion_Assertion(delta,flagMsg,ssfi,true).is.numeric;message="A `expected` value is required for `closeTo`";if(expected==undefined){throw new assertion_error_AssertionError(flagMsg?`${flagMsg}: ${message}`:message,undefined,ssfi)}new assertion_Assertion(expected,flagMsg,ssfi,true).is.numeric;const abs=x=>x<0n?-x:x;const strip=number=>parseFloat(parseFloat(number).toPrecision(12));this.assert(strip(abs(obj-expected))<=delta,"expected #{this} to be close to "+expected+" +/- "+delta,"expected #{this} not to be close to "+expected+" +/- "+delta)}assertion_Assertion.addMethod("closeTo",closeTo);assertion_Assertion.addMethod("approximately",closeTo);function isSubsetOf(_subset,_superset,cmp,contains,ordered){let superset=Array.from(_superset);let subset=Array.from(_subset);if(!contains){if(subset.length!==superset.length)return false;superset=superset.slice()}return subset.every(function(elem,idx){if(ordered)return cmp?cmp(elem,superset[idx]):elem===superset[idx];if(!cmp){let matchIdx=superset.indexOf(elem);if(matchIdx===-1)return false;if(!contains)superset.splice(matchIdx,1);return true}return superset.some(function(elem2,matchIdx){if(!cmp(elem,elem2))return false;if(!contains)superset.splice(matchIdx,1);return true})})}assertion_Assertion.addMethod("members",function(subset,msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object"),flagMsg=assertions_flag(this,"message"),ssfi=assertions_flag(this,"ssfi");new assertion_Assertion(obj,flagMsg,ssfi,true).to.be.iterable;new assertion_Assertion(subset,flagMsg,ssfi,true).to.be.iterable;let contains=assertions_flag(this,"contains");let ordered=assertions_flag(this,"ordered");let subject,failMsg,failNegateMsg;if(contains){subject=ordered?"an ordered superset":"a superset";failMsg="expected #{this} to be "+subject+" of #{exp}";failNegateMsg="expected #{this} to not be "+subject+" of #{exp}"}else{subject=ordered?"ordered members":"members";failMsg="expected #{this} to have the same "+subject+" as #{exp}";failNegateMsg="expected #{this} to not have the same "+subject+" as #{exp}"}let cmp=assertions_flag(this,"deep")?assertions_flag(this,"eql"):undefined;this.assert(isSubsetOf(subset,obj,cmp,contains,ordered),failMsg,failNegateMsg,subset,obj,true)});assertion_Assertion.addProperty("iterable",function(msg){if(msg)assertions_flag(this,"message",msg);let obj=assertions_flag(this,"object");this.assert(obj!=undefined&&obj[Symbol.iterator],"expected #{this} to be an iterable","expected #{this} to not be an iterable",obj)});function oneOf(list,msg){if(msg)assertions_flag(this,"message",msg);let expected=assertions_flag(this,"object"),flagMsg=assertions_flag(this,"message"),ssfi=assertions_flag(this,"ssfi"),contains=assertions_flag(this,"contains"),isDeep=assertions_flag(this,"deep"),eql=assertions_flag(this,"eql");new assertion_Assertion(list,flagMsg,ssfi,true).to.be.an("array");if(contains){this.assert(list.some(function(possibility){return expected.indexOf(possibility)>-1}),"expected #{this} to contain one of #{exp}","expected #{this} to not contain one of #{exp}",list,expected)}else{if(isDeep){this.assert(list.some(function(possibility){return eql(expected,possibility)}),"expected #{this} to deeply equal one of #{exp}","expected #{this} to deeply equal one of #{exp}",list,expected)}else{this.assert(list.indexOf(expected)>-1,"expected #{this} to be one of #{exp}","expected #{this} to not be one of #{exp}",list,expected)}}}assertion_Assertion.addMethod("oneOf",oneOf);function assertChanges(subject,prop,msg){if(msg)assertions_flag(this,"message",msg);let fn=assertions_flag(this,"object"),flagMsg=assertions_flag(this,"message"),ssfi=assertions_flag(this,"ssfi");new assertion_Assertion(fn,flagMsg,ssfi,true).is.a("function");let initial;if(!prop){new assertion_Assertion(subject,flagMsg,ssfi,true).is.a("function");initial=subject()}else{new assertion_Assertion(subject,flagMsg,ssfi,true).to.have.property(prop);initial=subject[prop]}fn();let final=prop===undefined||prop===null?subject():subject[prop];let msgObj=prop===undefined||prop===null?initial:"."+prop;assertions_flag(this,"deltaMsgObj",msgObj);assertions_flag(this,"initialDeltaValue",initial);assertions_flag(this,"finalDeltaValue",final);assertions_flag(this,"deltaBehavior","change");assertions_flag(this,"realDelta",final!==initial);this.assert(initial!==final,"expected "+msgObj+" to change","expected "+msgObj+" to not change")}assertion_Assertion.addMethod("change",assertChanges);assertion_Assertion.addMethod("changes",assertChanges);function assertIncreases(subject,prop,msg){if(msg)assertions_flag(this,"message",msg);let fn=assertions_flag(this,"object"),flagMsg=assertions_flag(this,"message"),ssfi=assertions_flag(this,"ssfi");new assertion_Assertion(fn,flagMsg,ssfi,true).is.a("function");let initial;if(!prop){new assertion_Assertion(subject,flagMsg,ssfi,true).is.a("function");initial=subject()}else{new assertion_Assertion(subject,flagMsg,ssfi,true).to.have.property(prop);initial=subject[prop]}new assertion_Assertion(initial,flagMsg,ssfi,true).is.a("number");fn();let final=prop===undefined||prop===null?subject():subject[prop];let msgObj=prop===undefined||prop===null?initial:"."+prop;assertions_flag(this,"deltaMsgObj",msgObj);assertions_flag(this,"initialDeltaValue",initial);assertions_flag(this,"finalDeltaValue",final);assertions_flag(this,"deltaBehavior","increase");assertions_flag(this,"realDelta",final-initial);this.assert(final-initial>0,"expected "+msgObj+" to increase","expected "+msgObj+" to not increase")}assertion_Assertion.addMethod("increase",assertIncreases);assertion_Assertion.addMethod("increases",assertIncreases);function assertDecreases(subject,prop,msg){if(msg)assertions_flag(this,"message",msg);let fn=assertions_flag(this,"object"),flagMsg=assertions_flag(this,"message"),ssfi=assertions_flag(this,"ssfi");new assertion_Assertion(fn,flagMsg,ssfi,true).is.a("function");let initial;if(!prop){new assertion_Assertion(subject,flagMsg,ssfi,true).is.a("function");initial=subject()}else{new assertion_Assertion(subject,flagMsg,ssfi,true).to.have.property(prop);initial=subject[prop]}new assertion_Assertion(initial,flagMsg,ssfi,true).is.a("number");fn();let final=prop===undefined||prop===null?subject():subject[prop];let msgObj=prop===undefined||prop===null?initial:"."+prop;assertions_flag(this,"deltaMsgObj",msgObj);assertions_flag(this,"initialDeltaValue",initial);assertions_flag(this,"finalDeltaValue",final);assertions_flag(this,"deltaBehavior","decrease");assertions_flag(this,"realDelta",initial-final);this.assert(final-initial<0,"expected "+msgObj+" to decrease","expected "+msgObj+" to not decrease")}assertion_Assertion.addMethod("decrease",assertDecreases);assertion_Assertion.addMethod("decreases",assertDecreases);function assertDelta(delta,msg){if(msg)assertions_flag(this,"message",msg);let msgObj=assertions_flag(this,"deltaMsgObj");let initial=assertions_flag(this,"initialDeltaValue");let final=assertions_flag(this,"finalDeltaValue");let behavior=assertions_flag(this,"deltaBehavior");let realDelta=assertions_flag(this,"realDelta");let expression;if(behavior==="change"){expression=Math.abs(final-initial)===Math.abs(delta)}else{expression=realDelta===Math.abs(delta)}this.assert(expression,"expected "+msgObj+" to "+behavior+" by "+delta,"expected "+msgObj+" to not "+behavior+" by "+delta)}assertion_Assertion.addMethod("by",assertDelta);assertion_Assertion.addProperty("extensible",function(){let obj=assertions_flag(this,"object");let isExtensible=obj===Object(obj)&&Object.isExtensible(obj);this.assert(isExtensible,"expected #{this} to be extensible","expected #{this} to not be extensible")});assertion_Assertion.addProperty("sealed",function(){let obj=assertions_flag(this,"object");let isSealed=obj===Object(obj)?Object.isSealed(obj):true;this.assert(isSealed,"expected #{this} to be sealed","expected #{this} to not be sealed")});assertion_Assertion.addProperty("frozen",function(){let obj=assertions_flag(this,"object");let isFrozen=obj===Object(obj)?Object.isFrozen(obj):true;this.assert(isFrozen,"expected #{this} to be frozen","expected #{this} to not be frozen")});assertion_Assertion.addProperty("finite",function(_msg){let obj=assertions_flag(this,"object");this.assert(typeof obj==="number"&&isFinite(obj),"expected #{this} to be a finite number","expected #{this} to not be a finite number")});function compareSubset(expected,actual){if(expected===actual){return true}if(typeof actual!==typeof expected){return false}if(typeof expected!=="object"||expected===null){return expected===actual}if(!actual){return false}if(Array.isArray(expected)){if(!Array.isArray(actual)){return false}return expected.every(function(exp){return actual.some(function(act){return compareSubset(exp,act)})})}if(expected instanceof Date){if(actual instanceof Date){return expected.getTime()===actual.getTime()}else{return false}}return Object.keys(expected).every(function(key){let expectedValue=expected[key];let actualValue=actual[key];if(typeof expectedValue==="object"&&expectedValue!==null&&actualValue!==null){return compareSubset(expectedValue,actualValue)}if(typeof expectedValue==="function"){return expectedValue(actualValue)}return actualValue===expectedValue})}assertion_Assertion.addMethod("containSubset",function(expected){const actual=flag_flag(this,"object");const showDiff=config_config.showDiff;this.assert(compareSubset(expected,actual),"expected #{act} to contain subset #{exp}","expected #{act} to not contain subset #{exp}",expected,actual,showDiff)});
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function expect_expect(val,message){return new assertion_Assertion(val,message)}expect_expect.fail=function(actual,expected,message,operator){if(arguments.length<2){message=actual;actual=undefined}message=message||"expect.fail()";throw new assertion_error_AssertionError(message,{actual,expected,operator},expect_expect.fail)};
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function loadShould(){function shouldGetter(){if(this instanceof String||this instanceof Number||this instanceof Boolean||typeof Symbol==="function"&&this instanceof Symbol||typeof BigInt==="function"&&this instanceof BigInt){return new Assertion(this.valueOf(),null,shouldGetter)}return new Assertion(this,null,shouldGetter)}function shouldSetter(value){Object.defineProperty(this,"should",{value,enumerable:true,configurable:true,writable:true})}Object.defineProperty(Object.prototype,"should",{set:shouldSetter,get:shouldGetter,configurable:true});let should={};should.fail=function(actual,expected,message,operator){if(arguments.length<2){message=actual;actual=undefined}message=message||"should.fail()";throw new AssertionError(message,{actual,expected,operator},should.fail)};should.equal=function(actual,expected,message){new Assertion(actual,message).to.equal(expected)};should.Throw=function(fn,errt,errs,msg){new Assertion(fn,msg).to.Throw(errt,errs)};should.exist=function(val,msg){new Assertion(val,msg).to.exist};should.not={};should.not.equal=function(actual,expected,msg){new Assertion(actual,msg).to.not.equal(expected)};should.not.Throw=function(fn,errt,errs,msg){new Assertion(fn,msg).to.not.Throw(errt,errs)};should.not.exist=function(val,msg){new Assertion(val,msg).to.not.exist};should["throw"]=should["Throw"];should.not["throw"]=should.not["Throw"];return should}const should_should=null&&loadShould;const Should=null&&loadShould;
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
function assert_assert(express,errmsg){let test=new assertion_Assertion(null,null,assert_assert,true);test.assert(express,errmsg,"[ negation message unavailable ]")}assert_assert.fail=function(actual,expected,message,operator){if(arguments.length<2){message=actual;actual=undefined}message=message||"assert.fail()";throw new assertion_error_AssertionError(message,{actual,expected,operator},assert_assert.fail)};assert_assert.isOk=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isOk,true).is.ok};assert_assert.isNotOk=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNotOk,true).is.not.ok};assert_assert.equal=function(act,exp,msg){let test=new assertion_Assertion(act,msg,assert_assert.equal,true);test.assert(exp==flag_flag(test,"object"),"expected #{this} to equal #{exp}","expected #{this} to not equal #{act}",exp,act,true)};assert_assert.notEqual=function(act,exp,msg){let test=new assertion_Assertion(act,msg,assert_assert.notEqual,true);test.assert(exp!=flag_flag(test,"object"),"expected #{this} to not equal #{exp}","expected #{this} to equal #{act}",exp,act,true)};assert_assert.strictEqual=function(act,exp,msg){new assertion_Assertion(act,msg,assert_assert.strictEqual,true).to.equal(exp)};assert_assert.notStrictEqual=function(act,exp,msg){new assertion_Assertion(act,msg,assert_assert.notStrictEqual,true).to.not.equal(exp)};assert_assert.deepEqual=assert_assert.deepStrictEqual=function(act,exp,msg){new assertion_Assertion(act,msg,assert_assert.deepEqual,true).to.eql(exp)};assert_assert.notDeepEqual=function(act,exp,msg){new assertion_Assertion(act,msg,assert_assert.notDeepEqual,true).to.not.eql(exp)};assert_assert.isAbove=function(val,abv,msg){new assertion_Assertion(val,msg,assert_assert.isAbove,true).to.be.above(abv)};assert_assert.isAtLeast=function(val,atlst,msg){new assertion_Assertion(val,msg,assert_assert.isAtLeast,true).to.be.least(atlst)};assert_assert.isBelow=function(val,blw,msg){new assertion_Assertion(val,msg,assert_assert.isBelow,true).to.be.below(blw)};assert_assert.isAtMost=function(val,atmst,msg){new assertion_Assertion(val,msg,assert_assert.isAtMost,true).to.be.most(atmst)};assert_assert.isTrue=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isTrue,true).is["true"]};assert_assert.isNotTrue=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNotTrue,true).to.not.equal(true)};assert_assert.isFalse=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isFalse,true).is["false"]};assert_assert.isNotFalse=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNotFalse,true).to.not.equal(false)};assert_assert.isNull=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNull,true).to.equal(null)};assert_assert.isNotNull=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNotNull,true).to.not.equal(null)};assert_assert.isNaN=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNaN,true).to.be.NaN};assert_assert.isNotNaN=function(value,message){new assertion_Assertion(value,message,assert_assert.isNotNaN,true).not.to.be.NaN};assert_assert.exists=function(val,msg){new assertion_Assertion(val,msg,assert_assert.exists,true).to.exist};assert_assert.notExists=function(val,msg){new assertion_Assertion(val,msg,assert_assert.notExists,true).to.not.exist};assert_assert.isUndefined=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isUndefined,true).to.equal(undefined)};assert_assert.isDefined=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isDefined,true).to.not.equal(undefined)};assert_assert.isCallable=function(value,message){new assertion_Assertion(value,message,assert_assert.isCallable,true).is.callable};assert_assert.isNotCallable=function(value,message){new assertion_Assertion(value,message,assert_assert.isNotCallable,true).is.not.callable};assert_assert.isObject=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isObject,true).to.be.a("object")};assert_assert.isNotObject=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNotObject,true).to.not.be.a("object")};assert_assert.isArray=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isArray,true).to.be.an("array")};assert_assert.isNotArray=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNotArray,true).to.not.be.an("array")};assert_assert.isString=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isString,true).to.be.a("string")};assert_assert.isNotString=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNotString,true).to.not.be.a("string")};assert_assert.isNumber=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNumber,true).to.be.a("number")};assert_assert.isNotNumber=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNotNumber,true).to.not.be.a("number")};assert_assert.isNumeric=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNumeric,true).is.numeric};assert_assert.isNotNumeric=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNotNumeric,true).is.not.numeric};assert_assert.isFinite=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isFinite,true).to.be.finite};assert_assert.isBoolean=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isBoolean,true).to.be.a("boolean")};assert_assert.isNotBoolean=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNotBoolean,true).to.not.be.a("boolean")};assert_assert.typeOf=function(val,type,msg){new assertion_Assertion(val,msg,assert_assert.typeOf,true).to.be.a(type)};assert_assert.notTypeOf=function(value,type,message){new assertion_Assertion(value,message,assert_assert.notTypeOf,true).to.not.be.a(type)};assert_assert.instanceOf=function(val,type,msg){new assertion_Assertion(val,msg,assert_assert.instanceOf,true).to.be.instanceOf(type)};assert_assert.notInstanceOf=function(val,type,msg){new assertion_Assertion(val,msg,assert_assert.notInstanceOf,true).to.not.be.instanceOf(type)};assert_assert.include=function(exp,inc,msg){new assertion_Assertion(exp,msg,assert_assert.include,true).include(inc)};assert_assert.notInclude=function(exp,inc,msg){new assertion_Assertion(exp,msg,assert_assert.notInclude,true).not.include(inc)};assert_assert.deepInclude=function(exp,inc,msg){new assertion_Assertion(exp,msg,assert_assert.deepInclude,true).deep.include(inc)};assert_assert.notDeepInclude=function(exp,inc,msg){new assertion_Assertion(exp,msg,assert_assert.notDeepInclude,true).not.deep.include(inc)};assert_assert.nestedInclude=function(exp,inc,msg){new assertion_Assertion(exp,msg,assert_assert.nestedInclude,true).nested.include(inc)};assert_assert.notNestedInclude=function(exp,inc,msg){new assertion_Assertion(exp,msg,assert_assert.notNestedInclude,true).not.nested.include(inc)};assert_assert.deepNestedInclude=function(exp,inc,msg){new assertion_Assertion(exp,msg,assert_assert.deepNestedInclude,true).deep.nested.include(inc)};assert_assert.notDeepNestedInclude=function(exp,inc,msg){new assertion_Assertion(exp,msg,assert_assert.notDeepNestedInclude,true).not.deep.nested.include(inc)};assert_assert.ownInclude=function(exp,inc,msg){new assertion_Assertion(exp,msg,assert_assert.ownInclude,true).own.include(inc)};assert_assert.notOwnInclude=function(exp,inc,msg){new assertion_Assertion(exp,msg,assert_assert.notOwnInclude,true).not.own.include(inc)};assert_assert.deepOwnInclude=function(exp,inc,msg){new assertion_Assertion(exp,msg,assert_assert.deepOwnInclude,true).deep.own.include(inc)};assert_assert.notDeepOwnInclude=function(exp,inc,msg){new assertion_Assertion(exp,msg,assert_assert.notDeepOwnInclude,true).not.deep.own.include(inc)};assert_assert.match=function(exp,re,msg){new assertion_Assertion(exp,msg,assert_assert.match,true).to.match(re)};assert_assert.notMatch=function(exp,re,msg){new assertion_Assertion(exp,msg,assert_assert.notMatch,true).to.not.match(re)};assert_assert.property=function(obj,prop,msg){new assertion_Assertion(obj,msg,assert_assert.property,true).to.have.property(prop)};assert_assert.notProperty=function(obj,prop,msg){new assertion_Assertion(obj,msg,assert_assert.notProperty,true).to.not.have.property(prop)};assert_assert.propertyVal=function(obj,prop,val,msg){new assertion_Assertion(obj,msg,assert_assert.propertyVal,true).to.have.property(prop,val)};assert_assert.notPropertyVal=function(obj,prop,val,msg){new assertion_Assertion(obj,msg,assert_assert.notPropertyVal,true).to.not.have.property(prop,val)};assert_assert.deepPropertyVal=function(obj,prop,val,msg){new assertion_Assertion(obj,msg,assert_assert.deepPropertyVal,true).to.have.deep.property(prop,val)};assert_assert.notDeepPropertyVal=function(obj,prop,val,msg){new assertion_Assertion(obj,msg,assert_assert.notDeepPropertyVal,true).to.not.have.deep.property(prop,val)};assert_assert.ownProperty=function(obj,prop,msg){new assertion_Assertion(obj,msg,assert_assert.ownProperty,true).to.have.own.property(prop)};assert_assert.notOwnProperty=function(obj,prop,msg){new assertion_Assertion(obj,msg,assert_assert.notOwnProperty,true).to.not.have.own.property(prop)};assert_assert.ownPropertyVal=function(obj,prop,value,msg){new assertion_Assertion(obj,msg,assert_assert.ownPropertyVal,true).to.have.own.property(prop,value)};assert_assert.notOwnPropertyVal=function(obj,prop,value,msg){new assertion_Assertion(obj,msg,assert_assert.notOwnPropertyVal,true).to.not.have.own.property(prop,value)};assert_assert.deepOwnPropertyVal=function(obj,prop,value,msg){new assertion_Assertion(obj,msg,assert_assert.deepOwnPropertyVal,true).to.have.deep.own.property(prop,value)};assert_assert.notDeepOwnPropertyVal=function(obj,prop,value,msg){new assertion_Assertion(obj,msg,assert_assert.notDeepOwnPropertyVal,true).to.not.have.deep.own.property(prop,value)};assert_assert.nestedProperty=function(obj,prop,msg){new assertion_Assertion(obj,msg,assert_assert.nestedProperty,true).to.have.nested.property(prop)};assert_assert.notNestedProperty=function(obj,prop,msg){new assertion_Assertion(obj,msg,assert_assert.notNestedProperty,true).to.not.have.nested.property(prop)};assert_assert.nestedPropertyVal=function(obj,prop,val,msg){new assertion_Assertion(obj,msg,assert_assert.nestedPropertyVal,true).to.have.nested.property(prop,val)};assert_assert.notNestedPropertyVal=function(obj,prop,val,msg){new assertion_Assertion(obj,msg,assert_assert.notNestedPropertyVal,true).to.not.have.nested.property(prop,val)};assert_assert.deepNestedPropertyVal=function(obj,prop,val,msg){new assertion_Assertion(obj,msg,assert_assert.deepNestedPropertyVal,true).to.have.deep.nested.property(prop,val)};assert_assert.notDeepNestedPropertyVal=function(obj,prop,val,msg){new assertion_Assertion(obj,msg,assert_assert.notDeepNestedPropertyVal,true).to.not.have.deep.nested.property(prop,val)};assert_assert.lengthOf=function(exp,len,msg){new assertion_Assertion(exp,msg,assert_assert.lengthOf,true).to.have.lengthOf(len)};assert_assert.hasAnyKeys=function(obj,keys,msg){new assertion_Assertion(obj,msg,assert_assert.hasAnyKeys,true).to.have.any.keys(keys)};assert_assert.hasAllKeys=function(obj,keys,msg){new assertion_Assertion(obj,msg,assert_assert.hasAllKeys,true).to.have.all.keys(keys)};assert_assert.containsAllKeys=function(obj,keys,msg){new assertion_Assertion(obj,msg,assert_assert.containsAllKeys,true).to.contain.all.keys(keys)};assert_assert.doesNotHaveAnyKeys=function(obj,keys,msg){new assertion_Assertion(obj,msg,assert_assert.doesNotHaveAnyKeys,true).to.not.have.any.keys(keys)};assert_assert.doesNotHaveAllKeys=function(obj,keys,msg){new assertion_Assertion(obj,msg,assert_assert.doesNotHaveAllKeys,true).to.not.have.all.keys(keys)};assert_assert.hasAnyDeepKeys=function(obj,keys,msg){new assertion_Assertion(obj,msg,assert_assert.hasAnyDeepKeys,true).to.have.any.deep.keys(keys)};assert_assert.hasAllDeepKeys=function(obj,keys,msg){new assertion_Assertion(obj,msg,assert_assert.hasAllDeepKeys,true).to.have.all.deep.keys(keys)};assert_assert.containsAllDeepKeys=function(obj,keys,msg){new assertion_Assertion(obj,msg,assert_assert.containsAllDeepKeys,true).to.contain.all.deep.keys(keys)};assert_assert.doesNotHaveAnyDeepKeys=function(obj,keys,msg){new assertion_Assertion(obj,msg,assert_assert.doesNotHaveAnyDeepKeys,true).to.not.have.any.deep.keys(keys)};assert_assert.doesNotHaveAllDeepKeys=function(obj,keys,msg){new assertion_Assertion(obj,msg,assert_assert.doesNotHaveAllDeepKeys,true).to.not.have.all.deep.keys(keys)};assert_assert.throws=function(fn,errorLike,errMsgMatcher,msg){if("string"===typeof errorLike||errorLike instanceof RegExp){errMsgMatcher=errorLike;errorLike=null}let assertErr=new assertion_Assertion(fn,msg,assert_assert.throws,true).to.throw(errorLike,errMsgMatcher);return flag_flag(assertErr,"object")};assert_assert.doesNotThrow=function(fn,errorLike,errMsgMatcher,message){if("string"===typeof errorLike||errorLike instanceof RegExp){errMsgMatcher=errorLike;errorLike=null}new assertion_Assertion(fn,message,assert_assert.doesNotThrow,true).to.not.throw(errorLike,errMsgMatcher)};assert_assert.operator=function(val,operator,val2,msg){let ok;switch(operator){case"==":ok=val==val2;break;case"===":ok=val===val2;break;case">":ok=val>val2;break;case">=":ok=val>=val2;break;case"<":ok=val<val2;break;case"<=":ok=val<=val2;break;case"!=":ok=val!=val2;break;case"!==":ok=val!==val2;break;default:msg=msg?msg+": ":msg;throw new assertion_error_AssertionError(msg+'Invalid operator "'+operator+'"',undefined,assert_assert.operator)}let test=new assertion_Assertion(ok,msg,assert_assert.operator,true);test.assert(true===flag_flag(test,"object"),"expected "+inspect_inspect(val)+" to be "+operator+" "+inspect_inspect(val2),"expected "+inspect_inspect(val)+" to not be "+operator+" "+inspect_inspect(val2))};assert_assert.closeTo=function(act,exp,delta,msg){new assertion_Assertion(act,msg,assert_assert.closeTo,true).to.be.closeTo(exp,delta)};assert_assert.approximately=function(act,exp,delta,msg){new assertion_Assertion(act,msg,assert_assert.approximately,true).to.be.approximately(exp,delta)};assert_assert.sameMembers=function(set1,set2,msg){new assertion_Assertion(set1,msg,assert_assert.sameMembers,true).to.have.same.members(set2)};assert_assert.notSameMembers=function(set1,set2,msg){new assertion_Assertion(set1,msg,assert_assert.notSameMembers,true).to.not.have.same.members(set2)};assert_assert.sameDeepMembers=function(set1,set2,msg){new assertion_Assertion(set1,msg,assert_assert.sameDeepMembers,true).to.have.same.deep.members(set2)};assert_assert.notSameDeepMembers=function(set1,set2,msg){new assertion_Assertion(set1,msg,assert_assert.notSameDeepMembers,true).to.not.have.same.deep.members(set2)};assert_assert.sameOrderedMembers=function(set1,set2,msg){new assertion_Assertion(set1,msg,assert_assert.sameOrderedMembers,true).to.have.same.ordered.members(set2)};assert_assert.notSameOrderedMembers=function(set1,set2,msg){new assertion_Assertion(set1,msg,assert_assert.notSameOrderedMembers,true).to.not.have.same.ordered.members(set2)};assert_assert.sameDeepOrderedMembers=function(set1,set2,msg){new assertion_Assertion(set1,msg,assert_assert.sameDeepOrderedMembers,true).to.have.same.deep.ordered.members(set2)};assert_assert.notSameDeepOrderedMembers=function(set1,set2,msg){new assertion_Assertion(set1,msg,assert_assert.notSameDeepOrderedMembers,true).to.not.have.same.deep.ordered.members(set2)};assert_assert.includeMembers=function(superset,subset,msg){new assertion_Assertion(superset,msg,assert_assert.includeMembers,true).to.include.members(subset)};assert_assert.notIncludeMembers=function(superset,subset,msg){new assertion_Assertion(superset,msg,assert_assert.notIncludeMembers,true).to.not.include.members(subset)};assert_assert.includeDeepMembers=function(superset,subset,msg){new assertion_Assertion(superset,msg,assert_assert.includeDeepMembers,true).to.include.deep.members(subset)};assert_assert.notIncludeDeepMembers=function(superset,subset,msg){new assertion_Assertion(superset,msg,assert_assert.notIncludeDeepMembers,true).to.not.include.deep.members(subset)};assert_assert.includeOrderedMembers=function(superset,subset,msg){new assertion_Assertion(superset,msg,assert_assert.includeOrderedMembers,true).to.include.ordered.members(subset)};assert_assert.notIncludeOrderedMembers=function(superset,subset,msg){new assertion_Assertion(superset,msg,assert_assert.notIncludeOrderedMembers,true).to.not.include.ordered.members(subset)};assert_assert.includeDeepOrderedMembers=function(superset,subset,msg){new assertion_Assertion(superset,msg,assert_assert.includeDeepOrderedMembers,true).to.include.deep.ordered.members(subset)};assert_assert.notIncludeDeepOrderedMembers=function(superset,subset,msg){new assertion_Assertion(superset,msg,assert_assert.notIncludeDeepOrderedMembers,true).to.not.include.deep.ordered.members(subset)};assert_assert.oneOf=function(inList,list,msg){new assertion_Assertion(inList,msg,assert_assert.oneOf,true).to.be.oneOf(list)};assert_assert.isIterable=function(obj,msg){if(obj==undefined||!obj[Symbol.iterator]){msg=msg?`${msg} expected ${inspect_inspect(obj)} to be an iterable`:`expected ${inspect_inspect(obj)} to be an iterable`;throw new assertion_error_AssertionError(msg,undefined,assert_assert.isIterable)}};assert_assert.changes=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==="function"){msg=prop;prop=null}new assertion_Assertion(fn,msg,assert_assert.changes,true).to.change(obj,prop)};assert_assert.changesBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==="function"){let tmpMsg=delta;delta=prop;msg=tmpMsg}else if(arguments.length===3){delta=prop;prop=null}new assertion_Assertion(fn,msg,assert_assert.changesBy,true).to.change(obj,prop).by(delta)};assert_assert.doesNotChange=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==="function"){msg=prop;prop=null}return new assertion_Assertion(fn,msg,assert_assert.doesNotChange,true).to.not.change(obj,prop)};assert_assert.changesButNotBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==="function"){let tmpMsg=delta;delta=prop;msg=tmpMsg}else if(arguments.length===3){delta=prop;prop=null}new assertion_Assertion(fn,msg,assert_assert.changesButNotBy,true).to.change(obj,prop).but.not.by(delta)};assert_assert.increases=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==="function"){msg=prop;prop=null}return new assertion_Assertion(fn,msg,assert_assert.increases,true).to.increase(obj,prop)};assert_assert.increasesBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==="function"){let tmpMsg=delta;delta=prop;msg=tmpMsg}else if(arguments.length===3){delta=prop;prop=null}new assertion_Assertion(fn,msg,assert_assert.increasesBy,true).to.increase(obj,prop).by(delta)};assert_assert.doesNotIncrease=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==="function"){msg=prop;prop=null}return new assertion_Assertion(fn,msg,assert_assert.doesNotIncrease,true).to.not.increase(obj,prop)};assert_assert.increasesButNotBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==="function"){let tmpMsg=delta;delta=prop;msg=tmpMsg}else if(arguments.length===3){delta=prop;prop=null}new assertion_Assertion(fn,msg,assert_assert.increasesButNotBy,true).to.increase(obj,prop).but.not.by(delta)};assert_assert.decreases=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==="function"){msg=prop;prop=null}return new assertion_Assertion(fn,msg,assert_assert.decreases,true).to.decrease(obj,prop)};assert_assert.decreasesBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==="function"){let tmpMsg=delta;delta=prop;msg=tmpMsg}else if(arguments.length===3){delta=prop;prop=null}new assertion_Assertion(fn,msg,assert_assert.decreasesBy,true).to.decrease(obj,prop).by(delta)};assert_assert.doesNotDecrease=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==="function"){msg=prop;prop=null}return new assertion_Assertion(fn,msg,assert_assert.doesNotDecrease,true).to.not.decrease(obj,prop)};assert_assert.doesNotDecreaseBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==="function"){let tmpMsg=delta;delta=prop;msg=tmpMsg}else if(arguments.length===3){delta=prop;prop=null}return new assertion_Assertion(fn,msg,assert_assert.doesNotDecreaseBy,true).to.not.decrease(obj,prop).by(delta)};assert_assert.decreasesButNotBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==="function"){let tmpMsg=delta;delta=prop;msg=tmpMsg}else if(arguments.length===3){delta=prop;prop=null}new assertion_Assertion(fn,msg,assert_assert.decreasesButNotBy,true).to.decrease(obj,prop).but.not.by(delta)};assert_assert.ifError=function(val){if(val){throw val}};assert_assert.isExtensible=function(obj,msg){new assertion_Assertion(obj,msg,assert_assert.isExtensible,true).to.be.extensible};assert_assert.isNotExtensible=function(obj,msg){new assertion_Assertion(obj,msg,assert_assert.isNotExtensible,true).to.not.be.extensible};assert_assert.isSealed=function(obj,msg){new assertion_Assertion(obj,msg,assert_assert.isSealed,true).to.be.sealed};assert_assert.isNotSealed=function(obj,msg){new assertion_Assertion(obj,msg,assert_assert.isNotSealed,true).to.not.be.sealed};assert_assert.isFrozen=function(obj,msg){new assertion_Assertion(obj,msg,assert_assert.isFrozen,true).to.be.frozen};assert_assert.isNotFrozen=function(obj,msg){new assertion_Assertion(obj,msg,assert_assert.isNotFrozen,true).to.not.be.frozen};assert_assert.isEmpty=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isEmpty,true).to.be.empty};assert_assert.isNotEmpty=function(val,msg){new assertion_Assertion(val,msg,assert_assert.isNotEmpty,true).to.not.be.empty};assert_assert.containsSubset=function(val,exp,msg){new assertion_Assertion(val,msg).to.containSubset(exp)};assert_assert.doesNotContainSubset=function(val,exp,msg){new assertion_Assertion(val,msg).to.not.containSubset(exp)};const aliases=[["isOk","ok"],["isNotOk","notOk"],["throws","throw"],["throws","Throw"],["isExtensible","extensible"],["isNotExtensible","notExtensible"],["isSealed","sealed"],["isNotSealed","notSealed"],["isFrozen","frozen"],["isNotFrozen","notFrozen"],["isEmpty","empty"],["isNotEmpty","notEmpty"],["isCallable","isFunction"],["isNotCallable","isNotFunction"],["containsSubset","containSubset"]];for(const[name,as]of aliases){assert_assert[as]=assert_assert[name]}
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
const used=null&&[];function use(fn){const exports={use,AssertionError,util,config,expect,assert,Assertion,...should};if(!~used.indexOf(fn)){fn(exports,util);used.push(fn)}return exports}const chai_assert=assert_assert;const chai_expect=expect_expect;const chai_AssertionError=assertion_error_AssertionError;const tests=[];const describe=(name,func)=>func();const it=(name,func)=>tests.push({name,func});describe("assert",()=>{it("assert",()=>{const foo="bar";chai_assert(foo=="bar","expected foo to equal `bar`");chai_expect(()=>{chai_assert(foo=="baz","expected foo to equal `baz`")}).to.throw(chai_AssertionError,"expected foo to equal `baz`");chai_expect(()=>{chai_assert(foo=="baz",()=>"expected foo to equal `baz`")}).to.throw(chai_AssertionError,"expected foo to equal `baz`")});it("fail",()=>{chai_expect(()=>{chai_assert.fail(0,1,"this has failed")}).to.throw(chai_AssertionError,"this has failed")});it("isTrue",()=>{chai_assert.isTrue(true);chai_expect(()=>{chai_assert.isTrue(false,"blah")}).to.throw(chai_AssertionError,"blah: expected false to be true");chai_expect(()=>{chai_assert.isTrue(1)}).to.throw(chai_AssertionError,"expected 1 to be true");chai_expect(()=>{chai_assert.isTrue("test")}).to.throw(chai_AssertionError,"expected 'test' to be true")});it("isNotTrue",()=>{chai_assert.isNotTrue(false);chai_expect(()=>{chai_assert.isNotTrue(true,"blah")}).to.throw(chai_AssertionError,"blah: expected true to not equal true")});it("isOk / ok",()=>{["isOk","ok"].forEach(isOk=>{chai_assert[isOk](true);chai_assert[isOk](1);chai_assert[isOk]("test");chai_expect(()=>{chai_assert[isOk](false,"blah")}).to.throw(chai_AssertionError,"blah: expected false to be truthy");chai_expect(()=>{chai_assert[isOk](0)}).to.throw(chai_AssertionError,"expected +0 to be truthy");chai_expect(()=>{chai_assert[isOk]("")}).to.throw(chai_AssertionError,"expected '' to be truthy")})});it("isNotOk / notOk",()=>{["isNotOk","notOk"].forEach(isNotOk=>{chai_assert[isNotOk](false);chai_assert[isNotOk](0);chai_assert[isNotOk]("");chai_expect(()=>{chai_assert[isNotOk](true,"blah")}).to.throw(chai_AssertionError,"blah: expected true to be falsy");chai_expect(()=>{chai_assert[isNotOk](1)}).to.throw(chai_AssertionError,"expected 1 to be falsy");chai_expect(()=>{chai_assert[isNotOk]("test")}).to.throw(chai_AssertionError,"expected 'test' to be falsy")})});it("isFalse",()=>{chai_assert.isFalse(false);chai_expect(()=>{chai_assert.isFalse(true,"blah")}).to.throw(chai_AssertionError,"blah: expected true to be false");chai_expect(()=>{chai_assert.isFalse(0)}).to.throw(chai_AssertionError,"expected +0 to be false")});it("isNotFalse",()=>{chai_assert.isNotFalse(true);chai_expect(()=>{chai_assert.isNotFalse(false,"blah")}).to.throw(chai_AssertionError,"blah: expected false to not equal false")});const sym=Symbol();it("isEqual",()=>{chai_assert.equal(0,0);chai_assert.equal(sym,sym);chai_assert.equal("test","test");chai_assert.equal(void 0,null);chai_assert.equal(void 0,undefined);chai_expect(()=>{chai_assert.equal(NaN,NaN)}).to.throw(chai_AssertionError,"expected NaN to equal NaN");chai_expect(()=>{chai_assert.equal(1,2,"blah")}).to.throw(chai_AssertionError,"blah: expected 1 to equal 2")});it("notEqual",()=>{chai_assert.notEqual(1,2);chai_assert.notEqual(NaN,NaN);chai_assert.notEqual(1,"test");chai_expect(()=>{chai_assert.notEqual("test","test")}).to.throw(chai_AssertionError,"expected 'test' to not equal 'test'");chai_expect(()=>{chai_assert.notEqual(sym,sym)}).to.throw(chai_AssertionError,"expected Symbol() to not equal Symbol()")});it("strictEqual",()=>{chai_assert.strictEqual(0,0);chai_assert.strictEqual(0,-0);chai_assert.strictEqual("foo","foo");chai_assert.strictEqual(sym,sym);chai_expect(()=>{chai_assert.strictEqual("5",5,"blah")}).to.throw(chai_AssertionError,"blah: expected '5' to equal 5")});it("notStrictEqual",()=>{chai_assert.notStrictEqual(5,"5");chai_assert.notStrictEqual(NaN,NaN);chai_assert.notStrictEqual(Symbol(),Symbol());chai_expect(()=>{chai_assert.notStrictEqual(5,5,"blah")}).to.throw(chai_AssertionError,"blah: expected 5 to not equal 5")});it("deepEqual",()=>{const obja=Object.create({tea:"chai"});const objb=Object.create({tea:"chai"});chai_assert.deepEqual(/a/,/a/);chai_assert.deepEqual(/a/g,/a/g);chai_assert.deepEqual(/a/i,/a/i);chai_assert.deepEqual(/a/m,/a/m);chai_assert.deepEqual(obja,objb);chai_assert.deepEqual([NaN],[NaN]);chai_assert.deepEqual({tea:NaN},{tea:NaN});chai_assert.deepEqual({tea:"chai"},{tea:"chai"});chai_assert.deepEqual({a:"a",b:"b"},{b:"b",a:"a"});chai_assert.deepEqual(new Date(1,2,3),new Date(1,2,3));chai_expect(()=>{chai_assert.deepEqual({tea:"chai"},{tea:"black"})}).to.throw(chai_AssertionError);const obj1=Object.create({tea:"chai"});const obj2=Object.create({tea:"black"});chai_expect(()=>{chai_assert.deepEqual(obj1,obj2)}).to.throw(chai_AssertionError);const circularObject={};const secondCircularObject={};circularObject.field=circularObject;secondCircularObject.field=secondCircularObject;chai_assert.deepEqual(circularObject,secondCircularObject);chai_expect(()=>{secondCircularObject.field2=secondCircularObject;chai_assert.deepEqual(circularObject,secondCircularObject)}).to.throw(chai_AssertionError)});it("notDeepEqual",()=>{chai_assert.notDeepEqual({tea:"jasmine"},{tea:"chai"});chai_assert.notDeepEqual(/a/,/b/);chai_assert.notDeepEqual(/a/,{});chai_assert.notDeepEqual(/a/g,/b/g);chai_assert.notDeepEqual(/a/i,/b/i);chai_assert.notDeepEqual(/a/m,/b/m);chai_assert.notDeepEqual(new Date(1,2,3),new Date(4,5,6));chai_assert.notDeepEqual(new Date(1,2,3),{});chai_expect(()=>{chai_assert.notDeepEqual({tea:"chai"},{tea:"chai"})}).to.throw(chai_AssertionError);const circularObject={};const secondCircularObject={tea:"jasmine"};circularObject.field=circularObject;secondCircularObject.field=secondCircularObject;chai_assert.notDeepEqual(circularObject,secondCircularObject);chai_expect(()=>{delete secondCircularObject.tea;chai_assert.notDeepEqual(circularObject,secondCircularObject)}).to.throw(chai_AssertionError)});it("typeOf",()=>{chai_assert.typeOf("test","string");chai_assert.typeOf(true,"boolean");chai_assert.typeOf(NaN,"number");chai_assert.typeOf(sym,"symbol");chai_expect(()=>{chai_assert.typeOf(5,"string","blah")}).to.throw(chai_AssertionError,"blah: expected 5 to be a string")});it("notTypeOf",()=>{chai_assert.notTypeOf(5,"string");chai_assert.notTypeOf(sym,"string");chai_assert.notTypeOf(null,"object");chai_assert.notTypeOf("test","number");chai_expect(()=>{chai_assert.notTypeOf(5,"number","blah")}).to.throw(chai_AssertionError,"blah: expected 5 not to be a number")});function Foo(){}const FakeConstructor={[Symbol.hasInstance](x){return x===3}};it("instanceOf",()=>{chai_assert.instanceOf({},Object);chai_assert.instanceOf(/a/,RegExp);chai_assert.instanceOf(new Foo,Foo);chai_assert.instanceOf(3,FakeConstructor);chai_expect(()=>{chai_assert.instanceOf(new Foo,1)}).to.throw("The instanceof assertion needs a constructor but Number was given.");chai_expect(()=>{chai_assert.instanceOf(new Foo,"Foo")}).to.throw("The instanceof assertion needs a constructor but String was given.");chai_expect(()=>{chai_assert.instanceOf(4,FakeConstructor)}).to.throw("expected 4 to be an instance of an unnamed constructor")});it("notInstanceOf",()=>{chai_assert.notInstanceOf({},Foo);chai_assert.notInstanceOf({},Array);chai_assert.notInstanceOf(new Foo,Array);chai_expect(()=>{chai_assert.notInstanceOf(new Foo,Foo)}).to.throw("expected Foo{} to not be an instance of Foo");chai_expect(()=>{chai_assert.notInstanceOf(3,FakeConstructor)}).to.throw("expected 3 to not be an instance of an unnamed constructor")});it("isObject",()=>{chai_assert.isObject({});chai_assert.isObject(new Foo);chai_expect(()=>{chai_assert.isObject(true)}).to.throw(chai_AssertionError,"expected true to be an object");chai_expect(()=>{chai_assert.isObject(Foo)}).to.throw(chai_AssertionError,"expected [Function Foo] to be an object");chai_expect(()=>{chai_assert.isObject("foo")}).to.throw(chai_AssertionError,"expected 'foo' to be an object")});it("isNotObject",()=>{chai_assert.isNotObject(1);chai_assert.isNotObject([]);chai_assert.isNotObject(/a/);chai_assert.isNotObject(Foo);chai_assert.isNotObject("foo");chai_expect(()=>{chai_assert.isNotObject({},"blah")}).to.throw(chai_AssertionError,"blah: expected {} not to be an object")});it("include",()=>{chai_assert.include("foobar","bar");chai_assert.include("","");chai_assert.include([1,2,3],3);chai_assert.include(new Error("foo"),{message:"foo"});chai_assert.include({a:1,[Symbol.toStringTag]:"foo"},{a:1});var obj1={a:1},obj2={b:2};chai_assert.include([obj1,obj2],obj1);chai_assert.include({foo:obj1,bar:obj2},{foo:obj1});chai_assert.include({foo:obj1,bar:obj2},{foo:obj1,bar:obj2});var map=new Map;var val=[{a:1}];map.set("a",val);map.set("b",2);map.set("c",-0);map.set("d",NaN);chai_assert.include(map,val);chai_assert.include(map,2);chai_assert.include(map,0);chai_assert.include(map,NaN);var set=new Set;var val=[{a:1}];set.add(val);set.add(2);set.add(-0);set.add(NaN);chai_assert.include(set,val);chai_assert.include(set,2);chai_assert.include(set,NaN);var ws=new WeakSet;var val=[{a:1}];ws.add(val);chai_assert.include(ws,val);var sym1=Symbol(),sym2=Symbol();chai_assert.include([sym1,sym2],sym1);chai_expect(()=>{chai_assert.include("foobar","baz","blah")}).to.throw(chai_AssertionError,"blah: expected 'foobar' to include 'baz'");chai_expect(()=>{chai_assert.include([{a:1},{b:2}],{a:1})}).to.throw(chai_AssertionError,"expected [ { a: 1 }, { b: 2 } ] to include { a: 1 }");chai_expect(()=>{chai_assert.include({foo:{a:1},bar:{b:2}},{foo:{a:1}},"blah")}).to.throw(chai_AssertionError,"blah: expected { foo: { a: 1 }, bar: { b: 2 } } to have property 'foo' of { a: 1 }, but got { a: 1 }");chai_expect(()=>{chai_assert.include(true,true,"blah")}).to.throw(chai_AssertionError,"blah: the given combination of arguments (boolean and boolean) is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a boolean");chai_expect(()=>{chai_assert.include(42,"bar")}).to.throw(chai_AssertionError,"the given combination of arguments (number and string) is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a string");chai_expect(()=>{chai_assert.include(null,42)}).to.throw(chai_AssertionError,"the given combination of arguments (null and number) is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a number");chai_expect(()=>{chai_assert.include(undefined,"bar")}).to.throw(chai_AssertionError,"the given combination of arguments (undefined and string) is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a string")});it("notInclude",()=>{chai_assert.notInclude("foobar","baz");chai_assert.notInclude([1,2,3],4);var obj1={a:1},obj2={b:2};chai_assert.notInclude([obj1,obj2],{a:1});chai_assert.notInclude({foo:obj1,bar:obj2},{foo:{a:1}});chai_assert.notInclude({foo:obj1,bar:obj2},{foo:obj1,bar:{b:2}});var map=new Map;var val=[{a:1}];map.set("a",val);map.set("b",2);chai_assert.notInclude(map,[{a:1}]);chai_assert.notInclude(map,3);var set=new Set;var val=[{a:1}];set.add(val);set.add(2);chai_assert.include(set,val);chai_assert.include(set,2);chai_assert.notInclude(set,[{a:1}]);chai_assert.notInclude(set,3);var ws=new WeakSet;var val=[{a:1}];ws.add(val);chai_assert.notInclude(ws,[{a:1}]);chai_assert.notInclude(ws,{});var sym1=Symbol(),sym2=Symbol(),sym3=Symbol();chai_assert.notInclude([sym1,sym2],sym3);chai_expect(()=>{var obj1={a:1},obj2={b:2};chai_assert.notInclude([obj1,obj2],obj1,"blah")}).to.throw(chai_AssertionError,"blah: expected [ { a: 1 }, { b: 2 } ] to not include { a: 1 }");chai_expect(()=>{var obj1={a:1},obj2={b:2};chai_assert.notInclude({foo:obj1,bar:obj2},{foo:obj1,bar:obj2},"blah")}).to.throw(chai_AssertionError,"blah: expected { foo: { a: 1 }, bar: { b: 2 } } to not have property 'foo' of { a: 1 }");chai_expect(()=>{chai_assert.notInclude(true,true,"blah")}).to.throw(chai_AssertionError,"blah: the given combination of arguments (boolean and boolean) is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a boolean");chai_expect(()=>{chai_assert.notInclude(42,"bar")}).to.throw(chai_AssertionError,"the given combination of arguments (number and string) is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a string");chai_expect(()=>{chai_assert.notInclude(null,42)}).to.throw(chai_AssertionError,"the given combination of arguments (null and number) is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a number");chai_expect(()=>{chai_assert.notInclude(undefined,"bar")}).to.throw(chai_AssertionError,"the given combination of arguments (undefined and string) is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a string");chai_expect(()=>{chai_assert.notInclude("foobar","bar")}).to.throw(chai_AssertionError,"expected 'foobar' to not include 'bar'")});it("deepInclude and notDeepInclude",()=>{var obj1={a:1},obj2={b:2};chai_assert.deepInclude([obj1,obj2],{a:1});chai_assert.notDeepInclude([obj1,obj2],{a:9});chai_assert.notDeepInclude([obj1,obj2],{z:1});chai_assert.deepInclude({foo:obj1,bar:obj2},{foo:{a:1}});chai_assert.deepInclude({foo:obj1,bar:obj2},{foo:{a:1},bar:{b:2}});chai_assert.notDeepInclude({foo:obj1,bar:obj2},{foo:{a:9}});chai_assert.notDeepInclude({foo:obj1,bar:obj2},{foo:{z:1}});chai_assert.notDeepInclude({foo:obj1,bar:obj2},{baz:{a:1}});chai_assert.notDeepInclude({foo:obj1,bar:obj2},{foo:{a:1},bar:{b:9}});var map=new Map;map.set(1,[{a:1}]);chai_assert.deepInclude(map,[{a:1}]);var set=new Set;set.add([{a:1}]);chai_assert.deepInclude(set,[{a:1}]);chai_expect(()=>{chai_assert.deepInclude(new WeakSet,{},"foo")}).to.throw(chai_AssertionError,"foo: unable to use .deep.include with WeakSet");chai_expect(()=>{chai_assert.deepInclude([obj1,obj2],{a:9},"blah")}).to.throw(chai_AssertionError,"blah: expected [ { a: 1 }, { b: 2 } ] to deep include { a: 9 }");chai_expect(()=>{chai_assert.notDeepInclude([obj1,obj2],{a:1})}).to.throw(chai_AssertionError,"expected [ { a: 1 }, { b: 2 } ] to not deep include { a: 1 }");chai_expect(()=>{chai_assert.deepInclude({foo:obj1,bar:obj2},{foo:{a:1},bar:{b:9}},"blah")}).to.throw(chai_AssertionError,"blah: expected { foo: { a: 1 }, bar: { b: 2 } } to have deep property 'bar' of { b: 9 }, but got { b: 2 }");chai_expect(()=>{chai_assert.notDeepInclude({foo:obj1,bar:obj2},{foo:{a:1},bar:{b:2}},"blah")}).to.throw(chai_AssertionError,"blah: expected { foo: { a: 1 }, bar: { b: 2 } } to not have deep property 'foo' of { a: 1 }")});it("nestedInclude and notNestedInclude",()=>{chai_assert.nestedInclude({a:{b:["x","y"]}},{"a.b[1]":"y"});chai_assert.notNestedInclude({a:{b:["x","y"]}},{"a.b[1]":"x"});chai_assert.notNestedInclude({a:{b:["x","y"]}},{"a.c":"y"});chai_assert.notNestedInclude({a:{b:[{x:1}]}},{"a.b[0]":{x:1}});chai_assert.nestedInclude({".a":{"[b]":"x"}},{"\\.a.\\[b\\]":"x"});chai_assert.notNestedInclude({".a":{"[b]":"x"}},{"\\.a.\\[b\\]":"y"});chai_expect(()=>{chai_assert.nestedInclude({a:{b:["x","y"]}},{"a.b[1]":"x"},"blah")}).to.throw(chai_AssertionError,"blah: expected { a: { b: [ 'x', 'y' ] } } to have nested property 'a.b[1]' of 'x', but got 'y'");chai_expect(()=>{chai_assert.nestedInclude({a:{b:["x","y"]}},{"a.b[1]":"x"},"blah")}).to.throw(chai_AssertionError,"blah: expected { a: { b: [ 'x', 'y' ] } } to have nested property 'a.b[1]' of 'x', but got 'y'");chai_expect(()=>{chai_assert.nestedInclude({a:{b:["x","y"]}},{"a.c":"y"})}).to.throw(chai_AssertionError,"expected { a: { b: [ 'x', 'y' ] } } to have nested property 'a.c'");chai_expect(()=>{chai_assert.notNestedInclude({a:{b:["x","y"]}},{"a.b[1]":"y"},"blah")}).to.throw(chai_AssertionError,"blah: expected { a: { b: [ 'x', 'y' ] } } to not have nested property 'a.b[1]' of 'y'")});it("deepNestedInclude and notDeepNestedInclude",()=>{chai_assert.deepNestedInclude({a:{b:[{x:1}]}},{"a.b[0]":{x:1}});chai_assert.notDeepNestedInclude({a:{b:[{x:1}]}},{"a.b[0]":{y:2}});chai_assert.notDeepNestedInclude({a:{b:[{x:1}]}},{"a.c":{x:1}});chai_assert.deepNestedInclude({".a":{"[b]":{x:1}}},{"\\.a.\\[b\\]":{x:1}});chai_assert.notDeepNestedInclude({".a":{"[b]":{x:1}}},{"\\.a.\\[b\\]":{y:2}});chai_expect(()=>{chai_assert.deepNestedInclude({a:{b:[{x:1}]}},{"a.b[0]":{y:2}},"blah")}).to.throw(chai_AssertionError,"blah: expected { a: { b: [ { x: 1 } ] } } to have deep nested property 'a.b[0]' of { y: 2 }, but got { x: 1 }");chai_expect(()=>{chai_assert.deepNestedInclude({a:{b:[{x:1}]}},{"a.b[0]":{y:2}},"blah")}).to.throw(chai_AssertionError,"blah: expected { a: { b: [ { x: 1 } ] } } to have deep nested property 'a.b[0]' of { y: 2 }, but got { x: 1 }");chai_expect(()=>{chai_assert.deepNestedInclude({a:{b:[{x:1}]}},{"a.c":{x:1}})}).to.throw(chai_AssertionError,"expected { a: { b: [ { x: 1 } ] } } to have deep nested property 'a.c'");chai_expect(()=>{chai_assert.notDeepNestedInclude({a:{b:[{x:1}]}},{"a.b[0]":{x:1}},"blah")}).to.throw(chai_AssertionError,"blah: expected { a: { b: [ { x: 1 } ] } } to not have deep nested property 'a.b[0]' of { x: 1 }")});it("ownInclude and notOwnInclude",()=>{chai_assert.ownInclude({a:1},{a:1});chai_assert.notOwnInclude({a:1},{a:3});chai_assert.notOwnInclude({a:1},{toString:Object.prototype.toString});chai_assert.notOwnInclude({a:{b:2}},{a:{b:2}});chai_expect(()=>{chai_assert.ownInclude({a:1},{a:3},"blah")}).to.throw(chai_AssertionError,"blah: expected { a: 1 } to have own property 'a' of 3, but got 1");chai_expect(()=>{chai_assert.ownInclude({a:1},{a:3},"blah")}).to.throw(chai_AssertionError,"blah: expected { a: 1 } to have own property 'a' of 3, but got 1");chai_expect(()=>{chai_assert.ownInclude({a:1},{toString:Object.prototype.toString})}).to.throw(chai_AssertionError,"expected { a: 1 } to have own property 'toString'");chai_expect(()=>{chai_assert.notOwnInclude({a:1},{a:1},"blah")}).to.throw(chai_AssertionError,"blah: expected { a: 1 } to not have own property 'a' of 1")});it("deepOwnInclude and notDeepOwnInclude",()=>{chai_assert.deepOwnInclude({a:{b:2}},{a:{b:2}});chai_assert.notDeepOwnInclude({a:{b:2}},{a:{c:3}});chai_assert.notDeepOwnInclude({a:{b:2}},{toString:Object.prototype.toString});chai_expect(()=>{chai_assert.deepOwnInclude({a:{b:2}},{a:{c:3}},"blah")}).to.throw(chai_AssertionError,"blah: expected { a: { b: 2 } } to have deep own property 'a' of { c: 3 }, but got { b: 2 }");chai_expect(()=>{chai_assert.deepOwnInclude({a:{b:2}},{a:{c:3}},"blah")}).to.throw(chai_AssertionError,"blah: expected { a: { b: 2 } } to have deep own property 'a' of { c: 3 }, but got { b: 2 }");chai_expect(()=>{chai_assert.deepOwnInclude({a:{b:2}},{toString:Object.prototype.toString})}).to.throw(chai_AssertionError,"expected { a: { b: 2 } } to have deep own property 'toString'");chai_expect(()=>{chai_assert.notDeepOwnInclude({a:{b:2}},{a:{b:2}},"blah")}).to.throw(chai_AssertionError,"blah: expected { a: { b: 2 } } to not have deep own property 'a' of { b: 2 }")});it("lengthOf",()=>{chai_assert.lengthOf([1,2,3],3);chai_assert.lengthOf("foobar",6);chai_expect(()=>{chai_assert.lengthOf("foobar",5,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foobar' to have a length of 5 but got 6");chai_expect(()=>{chai_assert.lengthOf(1,5)}).to.throw(chai_AssertionError,"expected 1 to have property 'length'")});it("match",()=>{chai_assert.match("foobar",/^foo/);chai_assert.notMatch("foobar",/^bar/);chai_expect(()=>{chai_assert.match("foobar",/^bar/i,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foobar' to match /^bar/i");chai_expect(()=>{chai_assert.notMatch("foobar",/^foo/i,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foobar' not to match /^foo/i")})});describe("expect",()=>{const sym=Symbol();describe("proxify",()=>{it("throws when invalid property follows expect",function(){chai_expect(()=>{chai_expect(42).pizza}).to.throw(Error,"Invalid Chai property: pizza")});it("throws when invalid property follows language chain",function(){chai_expect(()=>{chai_expect(42).to.pizza}).to.throw(Error,"Invalid Chai property: pizza")});it("throws when invalid property follows property assertion",function(){chai_expect(()=>{chai_expect(42).ok.pizza}).to.throw(Error,"Invalid Chai property: pizza")});it("throws when invalid property follows uncalled method assertion",function(){chai_expect(()=>{chai_expect(42).equal.pizza}).to.throw(Error,'Invalid Chai property: equal.pizza. See docs for proper usage of "equal".')});it("throws when invalid property follows called method assertion",function(){chai_expect(()=>{chai_expect(42).equal(42).pizza}).to.throw(Error,"Invalid Chai property: pizza")});it("throws when invalid property follows uncalled chainable method assertion",function(){chai_expect(()=>{chai_expect(42).a.pizza}).to.throw(Error,"Invalid Chai property: pizza")});it("throws when invalid property follows called chainable method assertion",function(){chai_expect(()=>{chai_expect(42).a("number").pizza}).to.throw(Error,"Invalid Chai property: pizza")});it("doesn't throw if invalid property is excluded via config",function(){chai_expect(()=>{chai_expect(42).then}).to.not.throw()})});it("no-op chains",()=>{["to","be","been","is","and","has","have","with","that","which","at","of","same","but","does"].forEach(chain=>{chai_expect(chai_expect(1)[chain]).not.undefined;chai_expect(1)[chain].equal(1);chai_expect(false)[chain].false;chai_expect(false)[chain].not.true;chai_expect([1,2,3])[chain].contains(1)})});it("fail",()=>{chai_expect(()=>{chai_expect.fail(0,1,"this has failed")}).to.throw(chai_AssertionError,"this has failed")});it("true",()=>{chai_expect(true).to.be.true;chai_expect(false).to.not.be.true;chai_expect(1).to.not.be.true;chai_expect(()=>{chai_expect("test","blah").to.be.true}).to.throw(chai_AssertionError,"blah: expected 'test' to be true")});it("ok",()=>{chai_expect(true).to.be.ok;chai_expect(false).to.not.be.ok;chai_expect(1).to.be.ok;chai_expect(0).to.not.be.ok;chai_expect(()=>{chai_expect("","blah").to.be.ok}).to.throw(chai_AssertionError,"blah: expected '' to be truthy");chai_expect(()=>{chai_expect("test").to.not.be.ok}).to.throw(chai_AssertionError,"expected 'test' to be falsy")});it("false",()=>{chai_expect(false).to.be.false;chai_expect(true).to.not.be.false;chai_expect(0).to.not.be.false;chai_expect(()=>{chai_expect("","blah").to.be.false}).to.throw(chai_AssertionError,"blah: expected '' to be false")});it("null",()=>{chai_expect(null).to.be.null;chai_expect(false).to.not.be.null;chai_expect(()=>{chai_expect("","blah").to.be.null}).to.throw(chai_AssertionError,"blah: expected '' to be null")});it("undefined",()=>{chai_expect(undefined).to.be.undefined;chai_expect(null).to.not.be.undefined;chai_expect(()=>{chai_expect("","blah").to.be.undefined}).to.throw(chai_AssertionError,"blah: expected '' to be undefined")});it("exist",()=>{const foo="bar";var bar;chai_expect(foo).to.exist;chai_expect(bar).to.not.exist;chai_expect(0).to.exist;chai_expect(false).to.exist;chai_expect("").to.exist;chai_expect(()=>{chai_expect(bar,"blah").to.exist}).to.throw(chai_AssertionError,"blah: expected undefined to exist");chai_expect(()=>{chai_expect(foo).to.not.exist(foo)}).to.throw(chai_AssertionError,"expected 'bar' to not exist")});it("arguments",()=>{var args=function(){return arguments}(1,2,3);chai_expect(args).to.be.arguments;chai_expect([]).to.not.be.arguments;chai_expect(args).to.be.an("arguments").and.be.arguments;chai_expect([]).to.be.an("array").and.not.be.Arguments;chai_expect(()=>{chai_expect([]).to.be.arguments}).to.throw(chai_AssertionError,"expected [] to be arguments but got Array")});it("instanceof",()=>{function Foo(){}chai_expect(new Foo).to.be.an.instanceof(Foo);chai_expect(()=>{chai_expect(new Foo).to.an.instanceof(1,"blah")}).to.throw(chai_AssertionError,"blah: The instanceof assertion needs a constructor but Number was given.");chai_expect(()=>{chai_expect(new Foo,"blah").to.an.instanceof(1)}).to.throw(chai_AssertionError,"blah: The instanceof assertion needs a constructor but Number was given.");chai_expect(()=>{chai_expect(new Foo).to.an.instanceof("batman")}).to.throw(chai_AssertionError,"The instanceof assertion needs a constructor but String was given.");chai_expect(()=>{chai_expect(new Foo).to.an.instanceof({})}).to.throw(chai_AssertionError,"The instanceof assertion needs a constructor but Object was given.");chai_expect(()=>{chai_expect(new Foo).to.an.instanceof(true)}).to.throw(chai_AssertionError,"The instanceof assertion needs a constructor but Boolean was given.");chai_expect(()=>{chai_expect(new Foo).to.an.instanceof(null)}).to.throw(chai_AssertionError,"The instanceof assertion needs a constructor but null was given.");chai_expect(()=>{chai_expect(new Foo).to.an.instanceof(undefined)}).to.throw(chai_AssertionError,"The instanceof assertion needs a constructor but undefined was given.");chai_expect(()=>{function Thing(){}var t=new Thing;Thing.prototype=1337;chai_expect(t).to.an.instanceof(Thing)}).to.throw(chai_AssertionError,"The instanceof assertion needs a constructor but Function was given.");chai_expect(()=>{chai_expect(new Foo).to.an.instanceof(Symbol())}).to.throw(chai_AssertionError,"The instanceof assertion needs a constructor but Symbol was given.");chai_expect(()=>{var FakeConstructor={};var fakeInstanceB=4;FakeConstructor[Symbol.hasInstance]=function(val){return val===3};chai_expect(fakeInstanceB).to.be.an.instanceof(FakeConstructor)}).to.throw(chai_AssertionError,"expected 4 to be an instance of an unnamed constructor");chai_expect(()=>{var FakeConstructor={};var fakeInstanceB=4;FakeConstructor[Symbol.hasInstance]=function(val){return val===4};chai_expect(fakeInstanceB).to.not.be.an.instanceof(FakeConstructor)}).to.throw(chai_AssertionError,"expected 4 to not be an instance of an unnamed constructor");chai_expect(()=>{chai_expect(3).to.an.instanceof(Foo,"blah")}).to.throw(chai_AssertionError,"blah: expected 3 to be an instance of Foo");chai_expect(()=>{chai_expect(3,"blah").to.an.instanceof(Foo)}).to.throw(chai_AssertionError,"blah: expected 3 to be an instance of Foo")});it("within(start, finish)",()=>{chai_expect(5).to.be.within(5,10);chai_expect(5).to.be.within(3,6);chai_expect(5).to.be.within(3,5);chai_expect(5).to.not.be.within(1,3);chai_expect("foo").to.have.length.within(2,4);chai_expect("foo").to.have.lengthOf.within(2,4);chai_expect([1,2,3]).to.have.length.within(2,4);chai_expect([1,2,3]).to.have.lengthOf.within(2,4);chai_expect(()=>{chai_expect(5).to.not.be.within(4,6,"blah")}).to.throw(chai_AssertionError,"blah: expected 5 to not be within 4..6");chai_expect(()=>{chai_expect(5,"blah").to.not.be.within(4,6)}).to.throw(chai_AssertionError,"blah: expected 5 to not be within 4..6");chai_expect(()=>{chai_expect(10).to.be.within(50,100,"blah")}).to.throw(chai_AssertionError,"blah: expected 10 to be within 50..100");chai_expect(()=>{chai_expect("foo").to.have.length.within(5,7,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length within 5..7");chai_expect(()=>{chai_expect("foo","blah").to.have.length.within(5,7)}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length within 5..7");chai_expect(()=>{chai_expect("foo").to.have.lengthOf.within(5,7,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length within 5..7");chai_expect(()=>{chai_expect([1,2,3]).to.have.length.within(5,7,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have a length within 5..7");chai_expect(()=>{chai_expect([1,2,3]).to.have.lengthOf.within(5,7,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have a length within 5..7");chai_expect(()=>{chai_expect(null).to.be.within(0,1,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(null,"blah").to.be.within(0,1)}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(1).to.be.within(null,1,"blah")}).to.throw(chai_AssertionError,"blah: the arguments to within must be numbers");chai_expect(()=>{chai_expect(1,"blah").to.be.within(null,1)}).to.throw(chai_AssertionError,"blah: the arguments to within must be numbers");chai_expect(()=>{chai_expect(1).to.be.within(0,null,"blah")}).to.throw(chai_AssertionError,"blah: the arguments to within must be numbers");chai_expect(()=>{chai_expect(1,"blah").to.be.within(0,null)}).to.throw(chai_AssertionError,"blah: the arguments to within must be numbers");chai_expect(()=>{chai_expect(null).to.not.be.within(0,1,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(1).to.not.be.within(null,1,"blah")}).to.throw(chai_AssertionError,"blah: the arguments to within must be numbers");chai_expect(()=>{chai_expect(1).to.not.be.within(0,null,"blah")}).to.throw(chai_AssertionError,"blah: the arguments to within must be numbers");chai_expect(()=>{chai_expect(1).to.have.length.within(5,7,"blah")}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'");chai_expect(()=>{chai_expect(1,"blah").to.have.length.within(5,7)}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'");chai_expect(()=>{chai_expect(1).to.have.lengthOf.within(5,7,"blah")}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'")});it("within(start, finish) (dates)",()=>{const now=new Date;const oneSecondAgo=new Date(now.getTime()-1e3);const oneSecondAfter=new Date(now.getTime()+1e3);const nowISO=now.toISOString();const beforeISO=oneSecondAgo.toISOString();const afterISO=oneSecondAfter.toISOString();chai_expect(now).to.be.within(oneSecondAgo,oneSecondAfter);chai_expect(now).to.be.within(now,oneSecondAfter);chai_expect(now).to.be.within(now,now);chai_expect(oneSecondAgo).to.not.be.within(now,oneSecondAfter);chai_expect(()=>{chai_expect(now).to.not.be.within(now,oneSecondAfter,"blah")}).to.throw(chai_AssertionError,"blah: expected "+nowISO+" to not be within "+nowISO+".."+afterISO);chai_expect(()=>{chai_expect(now,"blah").to.not.be.within(oneSecondAgo,oneSecondAfter)}).to.throw(chai_AssertionError,"blah: expected "+nowISO+" to not be within "+beforeISO+".."+afterISO);chai_expect(()=>{chai_expect(now).to.have.length.within(5,7,"blah")}).to.throw(chai_AssertionError,"blah: expected "+nowISO+" to have property 'length'");chai_expect(()=>{chai_expect("foo").to.have.lengthOf.within(now,7,"blah")}).to.throw(chai_AssertionError,"blah: the arguments to within must be numbers");chai_expect(()=>{chai_expect(now).to.be.within(now,1,"blah")}).to.throw(chai_AssertionError,"blah: the arguments to within must be dates");chai_expect(()=>{chai_expect(now).to.be.within(null,now,"blah")}).to.throw(chai_AssertionError,"blah: the arguments to within must be dates");chai_expect(()=>{chai_expect(now).to.be.within(now,undefined,"blah")}).to.throw(chai_AssertionError,"blah: the arguments to within must be dates");chai_expect(()=>{chai_expect(now,"blah").to.be.within(1,now)}).to.throw(chai_AssertionError,"blah: the arguments to within must be dates");chai_expect(()=>{chai_expect(now,"blah").to.be.within(now,1)}).to.throw(chai_AssertionError,"blah: the arguments to within must be dates");chai_expect(()=>{chai_expect(null).to.not.be.within(now,oneSecondAfter,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date")});it("above(n)",()=>{chai_expect(5).to.be.above(2);chai_expect(5).to.be.greaterThan(2);chai_expect(5).to.not.be.above(5);chai_expect(5).to.not.be.above(6);chai_expect("foo").to.have.length.above(2);chai_expect("foo").to.have.lengthOf.above(2);chai_expect([1,2,3]).to.have.length.above(2);chai_expect([1,2,3]).to.have.lengthOf.above(2);chai_expect(()=>{chai_expect(5).to.be.above(6,"blah")}).to.throw(chai_AssertionError,"blah: expected 5 to be above 6");chai_expect(()=>{chai_expect(5,"blah").to.be.above(6)}).to.throw(chai_AssertionError,"blah: expected 5 to be above 6");chai_expect(()=>{chai_expect(10).to.not.be.above(6,"blah")}).to.throw(chai_AssertionError,"blah: expected 10 to be at most 6");chai_expect(()=>{chai_expect("foo").to.have.length.above(4,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length above 4 but got 3");chai_expect(()=>{chai_expect("foo","blah").to.have.length.above(4)}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length above 4 but got 3");chai_expect(()=>{chai_expect("foo").to.have.lengthOf.above(4,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length above 4 but got 3");chai_expect(()=>{chai_expect([1,2,3]).to.have.length.above(4,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have a length above 4 but got 3");chai_expect(()=>{chai_expect([1,2,3]).to.have.lengthOf.above(4,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have a length above 4 but got 3");chai_expect(()=>{chai_expect(null).to.be.above(0,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(null,"blah").to.be.above(0)}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(1).to.be.above(null,"blah")}).to.throw(chai_AssertionError,"blah: the argument to above must be a number");chai_expect(()=>{chai_expect(1,"blah").to.be.above(null)}).to.throw(chai_AssertionError,"blah: the argument to above must be a number");chai_expect(()=>{chai_expect(null).to.not.be.above(0,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(1).to.not.be.above(null,"blah")}).to.throw(chai_AssertionError,"blah: the argument to above must be a number");chai_expect(()=>{chai_expect(1).to.have.length.above(0,"blah")}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'");chai_expect(()=>{chai_expect(1,"blah").to.have.length.above(0)}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'");chai_expect(()=>{chai_expect(1).to.have.lengthOf.above(0,"blah")}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'")});it("above(n) (dates)",()=>{const now=new Date;const oneSecondAgo=new Date(now.getTime()-1e3);const oneSecondAfter=new Date(now.getTime()+1e3);chai_expect(now).to.be.above(oneSecondAgo);chai_expect(now).to.be.greaterThan(oneSecondAgo);chai_expect(now).to.not.be.above(now);chai_expect(now).to.not.be.above(oneSecondAfter);chai_expect(()=>{chai_expect(now).to.be.above(oneSecondAfter,"blah")}).to.throw(chai_AssertionError,"blah: expected "+now.toISOString()+" to be above "+oneSecondAfter.toISOString());chai_expect(()=>{chai_expect(10).to.not.be.above(6,"blah")}).to.throw(chai_AssertionError,"blah: expected 10 to be at most 6");chai_expect(()=>{chai_expect(now).to.have.length.above(4,"blah")}).to.throw(chai_AssertionError,"blah: expected "+now.toISOString()+" to have property 'length'");chai_expect(()=>{chai_expect([1,2,3]).to.have.length.above(now,"blah")}).to.throw(chai_AssertionError,"blah: the argument to above must be a number");chai_expect(()=>{chai_expect(null).to.be.above(now,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(now).to.be.above(null,"blah")}).to.throw(chai_AssertionError,"blah: the argument to above must be a date");chai_expect(()=>{chai_expect(null).to.have.length.above(0,"blah")}).to.throw(chai_AssertionError,"blah: Target cannot be null or undefined.")});it("least(n)",()=>{chai_expect(5).to.be.at.least(2);chai_expect(5).to.be.at.least(5);chai_expect(5).to.not.be.at.least(6);chai_expect("foo").to.have.length.of.at.least(2);chai_expect("foo").to.have.lengthOf.at.least(2);chai_expect([1,2,3]).to.have.length.of.at.least(2);chai_expect([1,2,3]).to.have.lengthOf.at.least(2);chai_expect(()=>{chai_expect(5).to.be.at.least(6,"blah")}).to.throw(chai_AssertionError,"blah: expected 5 to be at least 6");chai_expect(()=>{chai_expect(5,"blah").to.be.at.least(6)}).to.throw(chai_AssertionError,"blah: expected 5 to be at least 6");chai_expect(()=>{chai_expect(10).to.not.be.at.least(6,"blah")}).to.throw(chai_AssertionError,"blah: expected 10 to be below 6");chai_expect(()=>{chai_expect("foo").to.have.length.of.at.least(4,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length at least 4 but got 3");chai_expect(()=>{chai_expect("foo","blah").to.have.length.of.at.least(4)}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length at least 4 but got 3");chai_expect(()=>{chai_expect("foo").to.have.lengthOf.at.least(4,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length at least 4 but got 3");chai_expect(()=>{chai_expect([1,2,3]).to.have.length.of.at.least(4,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have a length at least 4 but got 3");chai_expect(()=>{chai_expect([1,2,3]).to.have.lengthOf.at.least(4,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have a length at least 4 but got 3");chai_expect(()=>{chai_expect([1,2,3,4]).to.not.have.length.of.at.least(4,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3, 4 ] to have a length below 4");chai_expect(()=>{chai_expect([1,2,3,4]).to.not.have.lengthOf.at.least(4,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3, 4 ] to have a length below 4");chai_expect(()=>{chai_expect(null).to.be.at.least(0,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(null,"blah").to.be.at.least(0)}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(1).to.be.at.least(null,"blah")}).to.throw(chai_AssertionError,"blah: the argument to least must be a number");chai_expect(()=>{chai_expect(1,"blah").to.be.at.least(null)}).to.throw(chai_AssertionError,"blah: the argument to least must be a number");chai_expect(()=>{chai_expect(null).to.not.be.at.least(0,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(1).to.not.be.at.least(null,"blah")}).to.throw(chai_AssertionError,"blah: the argument to least must be a number");chai_expect(()=>{chai_expect(1).to.have.length.at.least(0,"blah")}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'");chai_expect(()=>{chai_expect(1,"blah").to.have.length.at.least(0)}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'");chai_expect(()=>{chai_expect(1).to.have.lengthOf.at.least(0,"blah")}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'")});it("below(n)",()=>{chai_expect(2).to.be.below(5);chai_expect(2).to.be.lessThan(5);chai_expect(2).to.not.be.below(2);chai_expect(2).to.not.be.below(1);chai_expect("foo").to.have.length.below(4);chai_expect("foo").to.have.lengthOf.below(4);chai_expect([1,2,3]).to.have.length.below(4);chai_expect([1,2,3]).to.have.lengthOf.below(4);chai_expect(()=>{chai_expect(6).to.be.below(5,"blah")}).to.throw(chai_AssertionError,"blah: expected 6 to be below 5");chai_expect(()=>{chai_expect(6,"blah").to.be.below(5)}).to.throw(chai_AssertionError,"blah: expected 6 to be below 5");chai_expect(()=>{chai_expect(6).to.not.be.below(10,"blah")}).to.throw(chai_AssertionError,"blah: expected 6 to be at least 10");chai_expect(()=>{chai_expect("foo").to.have.length.below(2,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length below 2 but got 3");chai_expect(()=>{chai_expect("foo","blah").to.have.length.below(2)}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length below 2 but got 3");chai_expect(()=>{chai_expect("foo").to.have.lengthOf.below(2,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length below 2 but got 3");chai_expect(()=>{chai_expect([1,2,3]).to.have.length.below(2,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have a length below 2 but got 3");chai_expect(()=>{chai_expect([1,2,3]).to.have.lengthOf.below(2,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have a length below 2 but got 3");chai_expect(()=>{chai_expect(null).to.be.below(0,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(null,"blah").to.be.below(0)},"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(1).to.be.below(null,"blah")}).to.throw(chai_AssertionError,"blah: the argument to below must be a number");chai_expect(()=>{chai_expect(1,"blah").to.be.below(null)}).to.throw(chai_AssertionError,"blah: the argument to below must be a number");chai_expect(()=>{chai_expect(null).to.not.be.below(0,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(1).to.not.be.below(null,"blah")}).to.throw(chai_AssertionError,"blah: the argument to below must be a number");chai_expect(()=>{chai_expect(1).to.have.length.below(0,"blah")}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'");chai_expect(()=>{chai_expect(1,"blah").to.have.length.below(0)}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'");chai_expect(()=>{chai_expect(1).to.have.lengthOf.below(0,"blah")}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'")});it("below(n) (dates)",()=>{const now=new Date;const oneSecondAgo=new Date(now.getTime()-1e3);const oneSecondAfter=new Date(now.getTime()+1e3);chai_expect(now).to.be.below(oneSecondAfter);chai_expect(oneSecondAgo).to.be.lessThan(now);chai_expect(now).to.not.be.below(oneSecondAgo);chai_expect(oneSecondAfter).to.not.be.below(oneSecondAgo);chai_expect(()=>{chai_expect(now).to.be.below(oneSecondAgo,"blah")}).to.throw(chai_AssertionError,"blah: expected "+now.toISOString()+" to be below "+oneSecondAgo.toISOString());chai_expect(()=>{chai_expect(now).to.not.be.below(oneSecondAfter,"blah")}).to.throw(chai_AssertionError,"blah: expected "+now.toISOString()+" to be at least "+oneSecondAfter.toISOString());chai_expect(()=>{chai_expect("foo").to.have.length.below(2,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length below 2 but got 3");chai_expect(()=>{chai_expect(null).to.be.below(now,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(1).to.be.below(null,"blah")}).to.throw(chai_AssertionError,"blah: the argument to below must be a number");chai_expect(()=>{chai_expect(now).to.not.be.below(null,"blah")}).to.throw(chai_AssertionError,"blah: the argument to below must be a date");chai_expect(()=>{chai_expect(now).to.have.length.below(0,"blah")}).to.throw(chai_AssertionError,"blah: expected "+now.toISOString()+" to have property 'length'");chai_expect(()=>{chai_expect("asdasd").to.have.length.below(now,"blah")}).to.throw(chai_AssertionError,"blah: the argument to below must be a number")});it("most(n)",()=>{chai_expect(2).to.be.at.most(5);chai_expect(2).to.be.at.most(2);chai_expect(2).to.not.be.at.most(1);chai_expect("foo").to.have.length.of.at.most(4);chai_expect("foo").to.have.lengthOf.at.most(4);chai_expect([1,2,3]).to.have.length.of.at.most(4);chai_expect([1,2,3]).to.have.lengthOf.at.most(4);chai_expect(()=>{chai_expect(6).to.be.at.most(5,"blah")}).to.throw(chai_AssertionError,"blah: expected 6 to be at most 5");chai_expect(()=>{chai_expect(6,"blah").to.be.at.most(5)}).to.throw(chai_AssertionError,"blah: expected 6 to be at most 5");chai_expect(()=>{chai_expect(6).to.not.be.at.most(10,"blah")}).to.throw(chai_AssertionError,"blah: expected 6 to be above 10");chai_expect(()=>{chai_expect("foo").to.have.length.of.at.most(2,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length at most 2 but got 3");chai_expect(()=>{chai_expect("foo","blah").to.have.length.of.at.most(2)}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length at most 2 but got 3");chai_expect(()=>{chai_expect("foo").to.have.lengthOf.at.most(2,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foo' to have a length at most 2 but got 3");chai_expect(()=>{chai_expect([1,2,3]).to.have.length.of.at.most(2,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have a length at most 2 but got 3");chai_expect(()=>{chai_expect([1,2,3]).to.have.lengthOf.at.most(2,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have a length at most 2 but got 3");chai_expect(()=>{chai_expect([1,2]).to.not.have.length.of.at.most(2,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2 ] to have a length above 2");chai_expect(()=>{chai_expect([1,2]).to.not.have.lengthOf.at.most(2,"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2 ] to have a length above 2");chai_expect(()=>{chai_expect(null).to.be.at.most(0,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(null,"blah").to.be.at.most(0)}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(1).to.be.at.most(null,"blah")}).to.throw(chai_AssertionError,"blah: the argument to most must be a number");chai_expect(()=>{chai_expect(1,"blah").to.be.at.most(null)}).to.throw(chai_AssertionError,"blah: the argument to most must be a number");chai_expect(()=>{chai_expect(null).to.not.be.at.most(0,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(1).to.not.be.at.most(null,"blah")}).to.throw(chai_AssertionError,"blah: the argument to most must be a number");chai_expect(()=>{chai_expect(1).to.have.length.of.at.most(0,"blah")}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'");chai_expect(()=>{chai_expect(1,"blah").to.have.length.of.at.most(0)}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'");chai_expect(()=>{chai_expect(1).to.have.lengthOf.at.most(0,"blah")}).to.throw(chai_AssertionError,"blah: expected 1 to have property 'length'")});it("most(n) (dates)",()=>{const now=new Date;const oneSecondBefore=new Date(now.getTime()-1e3);const oneSecondAfter=new Date(now.getTime()+1e3);const nowISO=now.toISOString();const beforeISO=oneSecondBefore.toISOString();chai_expect(now).to.be.at.most(oneSecondAfter);chai_expect(now).to.be.at.most(now);chai_expect(now).to.not.be.at.most(oneSecondBefore);chai_expect(()=>{chai_expect(now).to.be.at.most(oneSecondBefore,"blah")}).to.throw(chai_AssertionError,"blah: expected "+nowISO+" to be at most "+beforeISO);chai_expect(()=>{chai_expect(now).to.not.be.at.most(now,"blah")}).to.throw(chai_AssertionError,"blah: expected "+nowISO+" to be above "+nowISO);chai_expect(()=>{chai_expect(now).to.have.length.of.at.most(2,"blah")}).to.throw(chai_AssertionError,"blah: expected "+nowISO+" to have property 'length'");chai_expect(()=>{chai_expect("foo","blah").to.have.length.of.at.most(now)}).to.throw(chai_AssertionError,"blah: the argument to most must be a number");chai_expect(()=>{chai_expect([1,2,3]).to.not.have.length.of.at.most(now,"blah")}).to.throw(chai_AssertionError,"blah: the argument to most must be a number");chai_expect(()=>{chai_expect(null).to.be.at.most(now,"blah")}).to.throw(chai_AssertionError,"blah: expected null to be a number or a date");chai_expect(()=>{chai_expect(now,"blah").to.be.at.most(null)}).to.throw(chai_AssertionError,"blah: the argument to most must be a date");chai_expect(()=>{chai_expect(1).to.be.at.most(now,"blah")}).to.throw(chai_AssertionError,"blah: the argument to most must be a number");chai_expect(()=>{chai_expect(now,"blah").to.be.at.most(1)}).to.throw(chai_AssertionError,"blah: the argument to most must be a date");chai_expect(()=>{chai_expect(now).to.not.be.at.most(undefined,"blah")}).to.throw(chai_AssertionError,"blah: the argument to most must be a date")});it("match(regexp)",()=>{chai_expect("foobar").to.match(/^foo/);chai_expect("foobar").to.matches(/^foo/);chai_expect("foobar").to.not.match(/^bar/);chai_expect(()=>{chai_expect("foobar").to.match(/^bar/i,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foobar' to match /^bar/i");chai_expect(()=>{chai_expect("foobar","blah").to.match(/^bar/i)}).to.throw(chai_AssertionError,"blah: expected 'foobar' to match /^bar/i");chai_expect(()=>{chai_expect("foobar").to.matches(/^bar/i,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foobar' to match /^bar/i");chai_expect(()=>{chai_expect("foobar").to.not.match(/^foo/i,"blah")}).to.throw(chai_AssertionError,"blah: expected 'foobar' not to match /^foo/i")});it("lengthOf(n)",()=>{chai_expect("test").to.have.length(4);chai_expect("test").to.have.lengthOf(4);chai_expect("test").to.not.have.length(3);chai_expect("test").to.not.have.lengthOf(3);chai_expect([1,2,3]).to.have.length(3);chai_expect([1,2,3]).to.have.lengthOf(3);chai_expect(()=>{chai_expect(4).to.have.length(3,"blah")}).to.throw(chai_AssertionError,"blah: expected 4 to have property 'length'");chai_expect(()=>{chai_expect(4,"blah").to.have.length(3)}).to.throw(chai_AssertionError,"blah: expected 4 to have property 'length'");chai_expect(()=>{chai_expect(4).to.have.lengthOf(3,"blah")}).to.throw(chai_AssertionError,"blah: expected 4 to have property 'length'");chai_expect(()=>{chai_expect("asd").to.not.have.length(3,"blah")}).to.throw(chai_AssertionError,"blah: expected 'asd' to not have a length of 3");chai_expect(()=>{chai_expect("asd").to.not.have.lengthOf(3,"blah")}).to.throw(chai_AssertionError,"blah: expected 'asd' to not have a length of 3")});it("eql(val)",()=>{chai_expect("test").to.eql("test");chai_expect({foo:"bar"}).to.eql({foo:"bar"});chai_expect(1).to.eql(1);chai_expect("4").to.not.eql(4);chai_expect(sym).to.eql(sym);chai_expect(()=>{chai_expect(4).to.eql(3,"blah")}).to.throw(chai_AssertionError,"blah: expected 4 to deeply equal 3")});it("equal(val)",()=>{chai_expect("test").to.equal("test");chai_expect(1).to.equal(1);chai_expect(sym).to.equal(sym);chai_expect(()=>{chai_expect(4).to.equal(3,"blah")}).to.throw(chai_AssertionError,"blah: expected 4 to equal 3");chai_expect(()=>{chai_expect(4,"blah").to.equal(3)}).to.throw(chai_AssertionError,"blah: expected 4 to equal 3");chai_expect(()=>{chai_expect("4").to.equal(4,"blah")}).to.throw(chai_AssertionError,"blah: expected '4' to equal 4")});it("deep.equal(val)",()=>{chai_expect({foo:"bar"}).to.deep.equal({foo:"bar"});chai_expect({foo:"bar"}).not.to.deep.equal({foo:"baz"})});it("deep.equal(/regexp/)",()=>{chai_expect(/a/).to.deep.equal(/a/);chai_expect(/a/).not.to.deep.equal(/b/);chai_expect(/a/).not.to.deep.equal({});chai_expect(/a/g).to.deep.equal(/a/g);chai_expect(/a/g).not.to.deep.equal(/b/g);chai_expect(/a/i).to.deep.equal(/a/i);chai_expect(/a/i).not.to.deep.equal(/b/i);chai_expect(/a/m).to.deep.equal(/a/m);chai_expect(/a/m).not.to.deep.equal(/b/m)});it("deep.equal(Date)",()=>{var a=new Date(1,2,3),b=new Date(4,5,6);chai_expect(a).to.deep.equal(a);chai_expect(a).not.to.deep.equal(b);chai_expect(a).not.to.deep.equal({})});it("empty",()=>{function FakeArgs(){}FakeArgs.prototype.length=0;chai_expect("").to.be.empty;chai_expect("foo").not.to.be.empty;chai_expect([]).to.be.empty;chai_expect(["foo"]).not.to.be.empty;chai_expect(new FakeArgs).to.be.empty;chai_expect({arguments:0}).not.to.be.empty;chai_expect({}).to.be.empty;chai_expect({foo:"bar"}).not.to.be.empty;chai_expect(()=>{chai_expect(new WeakMap,"blah").not.to.be.empty}).to.throw(chai_AssertionError,"blah: .empty was passed a weak collection");chai_expect(()=>{chai_expect(new WeakSet,"blah").not.to.be.empty}).to.throw(chai_AssertionError,"blah: .empty was passed a weak collection");chai_expect(new Map).to.be.empty;var map=new Map;map.set("a",1);chai_expect(map).not.to.be.empty;chai_expect(()=>{chai_expect(new Map).not.to.be.empty}).to.throw(chai_AssertionError,"expected Map{} not to be empty");map=new Map;map.key="val";chai_expect(map).to.be.empty;chai_expect(()=>{chai_expect(map).not.to.be.empty}).to.throw(chai_AssertionError,"expected Map{} not to be empty");chai_expect(new Set).to.be.empty;var set=new Set;set.add(1);chai_expect(set).not.to.be.empty;chai_expect(()=>{chai_expect(new Set).not.to.be.empty}).to.throw(chai_AssertionError,"expected Set{} not to be empty");set=new Set;set.key="val";chai_expect(set).to.be.empty;chai_expect(()=>{chai_expect(set).not.to.be.empty}).to.throw(chai_AssertionError,"expected Set{} not to be empty");chai_expect(()=>{chai_expect("","blah").not.to.be.empty}).to.throw(chai_AssertionError,"blah: expected '' not to be empty");chai_expect(()=>{chai_expect("foo").to.be.empty}).to.throw(chai_AssertionError,"expected 'foo' to be empty");chai_expect(()=>{chai_expect([]).not.to.be.empty}).to.throw(chai_AssertionError,"expected [] not to be empty");chai_expect(()=>{chai_expect(["foo"]).to.be.empty}).to.throw(chai_AssertionError,"expected [ 'foo' ] to be empty");chai_expect(()=>{chai_expect(new FakeArgs).not.to.be.empty}).to.throw(chai_AssertionError,"expected FakeArgs{} not to be empty");chai_expect(()=>{chai_expect({arguments:0}).to.be.empty}).to.throw(chai_AssertionError,"expected { arguments: +0 } to be empty");chai_expect(()=>{chai_expect({}).not.to.be.empty}).to.throw(chai_AssertionError,"expected {} not to be empty");chai_expect(()=>{chai_expect({foo:"bar"}).to.be.empty}).to.throw(chai_AssertionError,"expected { foo: 'bar' } to be empty");chai_expect(()=>{chai_expect(null,"blah").to.be.empty}).to.throw(chai_AssertionError,"blah: .empty was passed non-string primitive null");chai_expect(()=>{chai_expect(undefined).to.be.empty}).to.throw(chai_AssertionError,".empty was passed non-string primitive undefined");chai_expect(()=>{chai_expect().to.be.empty}).to.throw(chai_AssertionError,".empty was passed non-string primitive undefined");chai_expect(()=>{chai_expect(null).to.not.be.empty}).to.throw(chai_AssertionError,".empty was passed non-string primitive null");chai_expect(()=>{chai_expect(undefined).to.not.be.empty}).to.throw(chai_AssertionError,".empty was passed non-string primitive undefined");chai_expect(()=>{chai_expect().to.not.be.empty}).to.throw(chai_AssertionError,".empty was passed non-string primitive undefined");chai_expect(()=>{chai_expect(0).to.be.empty}).to.throw(chai_AssertionError,".empty was passed non-string primitive +0");chai_expect(()=>{chai_expect(1).to.be.empty}).to.throw(chai_AssertionError,".empty was passed non-string primitive 1");chai_expect(()=>{chai_expect(true).to.be.empty}).to.throw(chai_AssertionError,".empty was passed non-string primitive true");chai_expect(()=>{chai_expect(false).to.be.empty}).to.throw(chai_AssertionError,".empty was passed non-string primitive false");chai_expect(()=>{chai_expect(Symbol()).to.be.empty}).to.throw(chai_AssertionError,".empty was passed non-string primitive Symbol()");chai_expect(()=>{chai_expect(Symbol.iterator).to.be.empty}).to.throw(chai_AssertionError,".empty was passed non-string primitive Symbol(Symbol.iterator)");chai_expect(()=>{chai_expect(function(){},"blah").to.be.empty}).to.throw(chai_AssertionError,"blah: .empty was passed a function");chai_expect(()=>{chai_expect(FakeArgs).to.be.empty}).to.throw(chai_AssertionError,".empty was passed a function FakeArgs")});it("string()",()=>{chai_expect("foobar").to.have.string("bar");chai_expect("foobar").to.have.string("foo");chai_expect("foobar").to.not.have.string("baz");chai_expect(()=>{chai_expect(3).to.have.string("baz","blah")}).to.throw(chai_AssertionError,"blah: expected 3 to be a string");chai_expect(()=>{chai_expect(3,"blah").to.have.string("baz")}).to.throw(chai_AssertionError,"blah: expected 3 to be a string");chai_expect(()=>{chai_expect("foobar").to.have.string("baz","blah")}).to.throw(chai_AssertionError,"blah: expected 'foobar' to contain 'baz'");chai_expect(()=>{chai_expect("foobar","blah").to.have.string("baz")}).to.throw(chai_AssertionError,"blah: expected 'foobar' to contain 'baz'");chai_expect(()=>{chai_expect("foobar").to.not.have.string("bar","blah")}).to.throw(chai_AssertionError,"blah: expected 'foobar' to not contain 'bar'")});it("NaN",()=>{chai_expect(NaN).to.be.NaN;chai_expect(undefined).not.to.be.NaN;chai_expect(Infinity).not.to.be.NaN;chai_expect("foo").not.to.be.NaN;chai_expect({}).not.to.be.NaN;chai_expect(4).not.to.be.NaN;chai_expect([]).not.to.be.NaN;chai_expect(()=>{chai_expect(NaN,"blah").not.to.be.NaN}).to.throw(chai_AssertionError,"blah: expected NaN not to be NaN");chai_expect(()=>{chai_expect(undefined).to.be.NaN}).to.throw(chai_AssertionError,"expected undefined to be NaN");chai_expect(()=>{chai_expect(Infinity).to.be.NaN}).to.throw(chai_AssertionError,"expected Infinity to be NaN");chai_expect(()=>{chai_expect("foo").to.be.NaN}).to.throw(chai_AssertionError,"expected 'foo' to be NaN");chai_expect(()=>{chai_expect({}).to.be.NaN}).to.throw(chai_AssertionError,"expected {} to be NaN");chai_expect(()=>{chai_expect(4).to.be.NaN}).to.throw(chai_AssertionError,"expected 4 to be NaN");chai_expect(()=>{chai_expect([]).to.be.NaN}).to.throw(chai_AssertionError,"expected [] to be NaN")});it("finite",function(){chai_expect(4).to.be.finite;chai_expect(-10).to.be.finite;chai_expect(()=>{chai_expect(NaN,"blah").to.be.finite}).to.throw(chai_AssertionError,"blah: expected NaN to be a finite number");chai_expect(()=>{chai_expect(Infinity).to.be.finite}).to.throw(chai_AssertionError,"expected Infinity to be a finite number");chai_expect(()=>{chai_expect("foo").to.be.finite}).to.throw(chai_AssertionError,"expected 'foo' to be a finite number");chai_expect(()=>{chai_expect([]).to.be.finite}).to.throw(chai_AssertionError,"expected [] to be a finite number");chai_expect(()=>{chai_expect({}).to.be.finite}).to.throw(chai_AssertionError,"expected {} to be a finite number")});it("property(name)",function(){chai_expect("test").to.have.property("length");chai_expect({a:1}).to.have.property("toString");chai_expect(4).to.not.have.property("length");chai_expect({"foo.bar":"baz"}).to.have.property("foo.bar");chai_expect({foo:{bar:"baz"}}).to.not.have.property("foo.bar");var obj={foo:undefined};Object.defineProperty(obj,"bar",{get:function(){}});chai_expect(obj).to.have.property("foo");chai_expect(obj).to.have.property("bar");chai_expect({"foo.bar[]":"baz"}).to.have.property("foo.bar[]");chai_expect(()=>{chai_expect("asd").to.have.property("foo")}).to.throw(chai_AssertionError,"expected 'asd' to have property 'foo'");chai_expect(()=>{chai_expect("asd","blah").to.have.property("foo")}).to.throw(chai_AssertionError,"blah: expected 'asd' to have property 'foo'");chai_expect(()=>{chai_expect({foo:{bar:"baz"}}).to.have.property("foo.bar")}).to.throw(chai_AssertionError,"expected { foo: { bar: 'baz' } } to have property 'foo.bar'");chai_expect(()=>{chai_expect({a:{b:1}}).to.have.own.nested.property("a.b")}).to.throw(chai_AssertionError,'The "nested" and "own" flags cannot be combined.');chai_expect(()=>{chai_expect({a:{b:1}},"blah").to.have.own.nested.property("a.b")}).to.throw(chai_AssertionError,'blah: The "nested" and "own" flags cannot be combined.');chai_expect(()=>{chai_expect(null,"blah").to.have.property("a")}).to.throw(chai_AssertionError,"blah: Target cannot be null or undefined.");chai_expect(()=>{chai_expect(undefined,"blah").to.have.property("a")}).to.throw(chai_AssertionError,"blah: Target cannot be null or undefined.")});it("include()",()=>{chai_expect(["foo","bar"]).to.include("foo");chai_expect(["foo","bar"]).to.include("foo");chai_expect(["foo","bar"]).to.include("bar");chai_expect([1,2]).to.include(1);chai_expect(["foo","bar"]).to.not.include("baz");chai_expect(["foo","bar"]).to.not.include(1);chai_expect({a:1}).to.include({toString:Object.prototype.toString});chai_expect(new Error("foo")).to.include({message:"foo"});var customObj={a:1};customObj[Symbol.toStringTag]="foo";chai_expect(customObj).to.include({a:1});var obj1={a:1},obj2={b:2};chai_expect([obj1,obj2]).to.include(obj1);chai_expect([obj1,obj2]).to.not.include({a:1});chai_expect({foo:obj1,bar:obj2}).to.include({foo:obj1});chai_expect({foo:obj1,bar:obj2}).to.include({foo:obj1,bar:obj2});chai_expect({foo:obj1,bar:obj2}).to.not.include({foo:{a:1}});chai_expect({foo:obj1,bar:obj2}).to.not.include({foo:obj1,bar:{b:2}});var map=new Map;var val=[{a:1}];map.set("a",val);map.set("b",2);map.set("c",-0);map.set("d",NaN);chai_expect(map).to.include(val);chai_expect(map).to.not.include([{a:1}]);chai_expect(map).to.include(2);chai_expect(map).to.not.include(3);chai_expect(map).to.include(0);chai_expect(map).to.include(NaN);var set=new Set;var val=[{a:1}];set.add(val);set.add(2);set.add(-0);set.add(NaN);chai_expect(set).to.include(val);chai_expect(set).to.not.include([{a:1}]);chai_expect(set).to.include(2);chai_expect(set).to.not.include(3);chai_expect(set).to.include(NaN);var ws=new WeakSet;var val=[{a:1}];ws.add(val);chai_expect(ws).to.include(val);chai_expect(ws).to.not.include([{a:1}]);chai_expect(ws).to.not.include({});var sym1=Symbol(),sym2=Symbol(),sym3=Symbol();chai_expect([sym1,sym2]).to.include(sym1);chai_expect([sym1,sym2]).to.not.include(sym3)});it("deep.include()",()=>{var obj1={a:1},obj2={b:2};chai_expect([obj1,obj2]).to.deep.include({a:1});chai_expect([obj1,obj2]).to.not.deep.include({a:9});chai_expect([obj1,obj2]).to.not.deep.include({z:1});chai_expect({foo:obj1,bar:obj2}).to.deep.include({foo:{a:1}});chai_expect({foo:obj1,bar:obj2}).to.deep.include({foo:{a:1},bar:{b:2}});chai_expect({foo:obj1,bar:obj2}).to.not.deep.include({foo:{a:9}});chai_expect({foo:obj1,bar:obj2}).to.not.deep.include({foo:{z:1}});chai_expect({foo:obj1,bar:obj2}).to.not.deep.include({baz:{a:1}});chai_expect({foo:obj1,bar:obj2}).to.not.deep.include({foo:{a:1},bar:{b:9}});var map=new Map;map.set(1,[{a:1}]);chai_expect(map).to.deep.include([{a:1}]);var set=new Set;set.add([{a:1}]);chai_expect(set).to.deep.include([{a:1}])});it("nested.include()",()=>{chai_expect({a:{b:["x","y"]}}).to.nested.include({"a.b[1]":"y"});chai_expect({a:{b:["x","y"]}}).to.not.nested.include({"a.b[1]":"x"});chai_expect({a:{b:["x","y"]}}).to.not.nested.include({"a.c":"y"});chai_expect({a:{b:[{x:1}]}}).to.not.nested.include({"a.b[0]":{x:1}});chai_expect({".a":{"[b]":"x"}}).to.nested.include({"\\.a.\\[b\\]":"x"});chai_expect({".a":{"[b]":"x"}}).to.not.nested.include({"\\.a.\\[b\\]":"y"})});it("deep.nested.include()",()=>{chai_expect({a:{b:[{x:1}]}}).to.deep.nested.include({"a.b[0]":{x:1}});chai_expect({a:{b:[{x:1}]}}).to.not.deep.nested.include({"a.b[0]":{y:2}});chai_expect({a:{b:[{x:1}]}}).to.not.deep.nested.include({"a.c":{x:1}});chai_expect({".a":{"[b]":{x:1}}}).to.deep.nested.include({"\\.a.\\[b\\]":{x:1}});chai_expect({".a":{"[b]":{x:1}}}).to.not.deep.nested.include({"\\.a.\\[b\\]":{y:2}})});it("own.include()",()=>{chai_expect({a:1}).to.own.include({a:1});chai_expect({a:1}).to.not.own.include({a:3});chai_expect({a:1}).to.not.own.include({toString:Object.prototype.toString});chai_expect({a:{b:2}}).to.not.own.include({a:{b:2}})});it("deep.own.include()",()=>{chai_expect({a:{b:2}}).to.deep.own.include({a:{b:2}});chai_expect({a:{b:2}}).to.not.deep.own.include({a:{c:3}});chai_expect({a:{b:2}}).to.not.deep.own.include({toString:Object.prototype.toString})});it("keys(array|Object|arguments)",()=>{chai_expect({foo:1}).to.have.keys(["foo"]);chai_expect({foo:1}).have.keys({foo:6});chai_expect({foo:1,bar:2}).to.have.keys(["foo","bar"]);chai_expect({foo:1,bar:2}).to.have.keys("foo","bar");chai_expect({foo:1,bar:2}).have.keys({foo:6,bar:7});chai_expect({foo:1,bar:2,baz:3}).to.contain.keys("foo","bar");chai_expect({foo:1,bar:2,baz:3}).to.contain.keys("bar","foo");chai_expect({foo:1,bar:2,baz:3}).to.contain.keys("baz");chai_expect({foo:1,bar:2}).contain.keys({foo:6});chai_expect({foo:1,bar:2}).contain.keys({bar:7});chai_expect({foo:1,bar:2}).contain.keys({foo:6});chai_expect({foo:1,bar:2}).to.contain.keys("foo");chai_expect({foo:1,bar:2}).to.contain.keys("bar","foo");chai_expect({foo:1,bar:2}).to.contain.keys(["foo"]);chai_expect({foo:1,bar:2}).to.contain.keys(["bar"]);chai_expect({foo:1,bar:2}).to.contain.keys(["bar","foo"]);chai_expect({foo:1,bar:2,baz:3}).to.contain.all.keys(["bar","foo"]);chai_expect({foo:1,bar:2}).to.not.have.keys("baz");chai_expect({foo:1,bar:2}).to.not.have.keys("foo");chai_expect({foo:1,bar:2}).to.not.have.keys("foo","baz");chai_expect({foo:1,bar:2}).to.not.contain.keys("baz");chai_expect({foo:1,bar:2}).to.not.contain.keys("foo","baz");chai_expect({foo:1,bar:2}).to.not.contain.keys("baz","foo");chai_expect({foo:1,bar:2}).to.have.any.keys("foo","baz");chai_expect({foo:1,bar:2}).to.have.any.keys("foo");chai_expect({foo:1,bar:2}).to.contain.any.keys("bar","baz");chai_expect({foo:1,bar:2}).to.contain.any.keys(["foo"]);chai_expect({foo:1,bar:2}).to.have.all.keys(["bar","foo"]);chai_expect({foo:1,bar:2}).to.contain.all.keys(["bar","foo"]);chai_expect({foo:1,bar:2}).contain.any.keys({foo:6});chai_expect({foo:1,bar:2}).have.all.keys({foo:6,bar:7});chai_expect({foo:1,bar:2}).contain.all.keys({bar:7,foo:6});chai_expect({foo:1,bar:2}).to.not.have.any.keys("baz","abc","def");chai_expect({foo:1,bar:2}).to.not.have.any.keys("baz");chai_expect({foo:1,bar:2}).to.not.contain.any.keys("baz");chai_expect({foo:1,bar:2}).to.not.have.all.keys(["baz","foo"]);chai_expect({foo:1,bar:2}).to.not.contain.all.keys(["baz","foo"]);chai_expect({foo:1,bar:2}).not.have.all.keys({baz:8,foo:7});chai_expect({foo:1,bar:2}).not.contain.all.keys({baz:8,foo:7});var enumProp1="enumProp1",enumProp2="enumProp2",nonEnumProp="nonEnumProp",obj={};obj[enumProp1]="enumProp1";obj[enumProp2]="enumProp2";Object.defineProperty(obj,nonEnumProp,{enumerable:false,value:"nonEnumProp"});chai_expect(obj).to.have.all.keys([enumProp1,enumProp2]);chai_expect(obj).to.not.have.all.keys([enumProp1,enumProp2,nonEnumProp]);var sym1=Symbol("sym1"),sym2=Symbol("sym2"),sym3=Symbol("sym3"),str="str",obj={};obj[sym1]="sym1";obj[sym2]="sym2";obj[str]="str";Object.defineProperty(obj,sym3,{enumerable:false,value:"sym3"});chai_expect(obj).to.have.all.keys([sym1,sym2,str]);chai_expect(obj).to.not.have.all.keys([sym1,sym2,sym3,str]);var aKey={thisIs:"anExampleObject"},anotherKey={doingThisBecauseOf:"referential equality"},testMap=new Map;testMap.set(aKey,"aValue");testMap.set(anotherKey,"anotherValue");chai_expect(testMap).to.have.any.keys(aKey);chai_expect(testMap).to.have.any.keys("thisDoesNotExist","thisToo",aKey);chai_expect(testMap).to.have.all.keys(aKey,anotherKey);chai_expect(testMap).to.contain.all.keys(aKey);chai_expect(testMap).to.not.contain.all.keys(aKey,"thisDoesNotExist");chai_expect(testMap).to.not.have.any.keys({iDoNot:"exist"});chai_expect(testMap).to.not.have.any.keys("thisIsNotAkey",{iDoNot:"exist"},{33:20});chai_expect(testMap).to.not.have.all.keys("thisDoesNotExist","thisToo",anotherKey);chai_expect(testMap).to.have.any.keys([aKey]);chai_expect(testMap).to.have.any.keys([20,1,aKey]);chai_expect(testMap).to.have.all.keys([aKey,anotherKey]);chai_expect(testMap).to.not.have.any.keys([{13:37},"thisDoesNotExist","thisToo"]);chai_expect(testMap).to.not.have.any.keys([20,1,{13:37}]);chai_expect(testMap).to.not.have.all.keys([aKey,{iDoNot:"exist"}]);chai_expect(testMap).to.have.any.deep.keys({thisIs:"anExampleObject"});chai_expect(testMap).to.have.any.deep.keys("thisDoesNotExist","thisToo",{thisIs:"anExampleObject"});chai_expect(testMap).to.contain.all.deep.keys({thisIs:"anExampleObject"});chai_expect(testMap).to.not.contain.all.deep.keys({thisIs:"anExampleObject"},"thisDoesNotExist");chai_expect(testMap).to.not.have.any.deep.keys({iDoNot:"exist"});chai_expect(testMap).to.not.have.any.deep.keys("thisIsNotAkey",{iDoNot:"exist"},{33:20});chai_expect(testMap).to.not.have.all.deep.keys("thisDoesNotExist","thisToo",{doingThisBecauseOf:"referential equality"});chai_expect(testMap).to.have.any.deep.keys([{thisIs:"anExampleObject"}]);chai_expect(testMap).to.have.any.deep.keys([20,1,{thisIs:"anExampleObject"}]);chai_expect(testMap).to.have.all.deep.keys({thisIs:"anExampleObject"},{doingThisBecauseOf:"referential equality"});chai_expect(testMap).to.not.have.any.deep.keys([{13:37},"thisDoesNotExist","thisToo"]);chai_expect(testMap).to.not.have.any.deep.keys([20,1,{13:37}]);chai_expect(testMap).to.not.have.all.deep.keys([{thisIs:"anExampleObject"},{iDoNot:"exist"}]);var weirdMapKey1=Object.create(null),weirdMapKey2={toString:NaN},weirdMapKey3=[],weirdMap=new Map;weirdMap.set(weirdMapKey1,"val1");weirdMap.set(weirdMapKey2,"val2");chai_expect(weirdMap).to.have.all.keys([weirdMapKey1,weirdMapKey2]);chai_expect(weirdMap).to.not.have.all.keys([weirdMapKey1,weirdMapKey3]);var symMapKey1=Symbol(),symMapKey2=Symbol(),symMapKey3=Symbol(),symMap=new Map;symMap.set(symMapKey1,"val1");symMap.set(symMapKey2,"val2");chai_expect(symMap).to.have.all.keys(symMapKey1,symMapKey2);chai_expect(symMap).to.have.any.keys(symMapKey1,symMapKey3);chai_expect(symMap).to.contain.all.keys(symMapKey2,symMapKey1);chai_expect(symMap).to.contain.any.keys(symMapKey3,symMapKey1);chai_expect(symMap).to.not.have.all.keys(symMapKey1,symMapKey3);chai_expect(symMap).to.not.have.any.keys(symMapKey3);chai_expect(symMap).to.not.contain.all.keys(symMapKey3,symMapKey1);chai_expect(symMap).to.not.contain.any.keys(symMapKey3);var aKey={thisIs:"anExampleObject"},anotherKey={doingThisBecauseOf:"referential equality"},testSet=new Set;testSet.add(aKey);testSet.add(anotherKey);chai_expect(testSet).to.have.any.keys(aKey);chai_expect(testSet).to.have.any.keys("thisDoesNotExist","thisToo",aKey);chai_expect(testSet).to.have.all.keys(aKey,anotherKey);chai_expect(testSet).to.contain.all.keys(aKey);chai_expect(testSet).to.not.contain.all.keys(aKey,"thisDoesNotExist");chai_expect(testSet).to.not.have.any.keys({iDoNot:"exist"});chai_expect(testSet).to.not.have.any.keys("thisIsNotAkey",{iDoNot:"exist"},{33:20});chai_expect(testSet).to.not.have.all.keys("thisDoesNotExist","thisToo",anotherKey);chai_expect(testSet).to.have.any.keys([aKey]);chai_expect(testSet).to.have.any.keys([20,1,aKey]);chai_expect(testSet).to.have.all.keys([aKey,anotherKey]);chai_expect(testSet).to.not.have.any.keys([{13:37},"thisDoesNotExist","thisToo"]);chai_expect(testSet).to.not.have.any.keys([20,1,{13:37}]);chai_expect(testSet).to.not.have.all.keys([aKey,{iDoNot:"exist"}]);chai_expect(testSet).to.have.any.deep.keys({thisIs:"anExampleObject"});chai_expect(testSet).to.have.any.deep.keys("thisDoesNotExist","thisToo",{thisIs:"anExampleObject"});chai_expect(testSet).to.contain.all.deep.keys({thisIs:"anExampleObject"});chai_expect(testSet).to.not.contain.all.deep.keys({thisIs:"anExampleObject"},"thisDoesNotExist");chai_expect(testSet).to.not.have.any.deep.keys({iDoNot:"exist"});chai_expect(testSet).to.not.have.any.deep.keys("thisIsNotAkey",{iDoNot:"exist"},{33:20});chai_expect(testSet).to.not.have.all.deep.keys("thisDoesNotExist","thisToo",{doingThisBecauseOf:"referential equality"});chai_expect(testSet).to.have.any.deep.keys([{thisIs:"anExampleObject"}]);chai_expect(testSet).to.have.any.deep.keys([20,1,{thisIs:"anExampleObject"}]);chai_expect(testSet).to.have.all.deep.keys([{thisIs:"anExampleObject"},{doingThisBecauseOf:"referential equality"}]);chai_expect(testSet).to.not.have.any.deep.keys([{13:37},"thisDoesNotExist","thisToo"]);chai_expect(testSet).to.not.have.any.deep.keys([20,1,{13:37}]);chai_expect(testSet).to.not.have.all.deep.keys([{thisIs:"anExampleObject"},{iDoNot:"exist"}]);var weirdSetKey1=Object.create(null),weirdSetKey2={toString:NaN},weirdSetKey3=[],weirdSet=new Set;weirdSet.add(weirdSetKey1);weirdSet.add(weirdSetKey2);chai_expect(weirdSet).to.have.all.keys([weirdSetKey1,weirdSetKey2]);chai_expect(weirdSet).to.not.have.all.keys([weirdSetKey1,weirdSetKey3]);var symSetKey1=Symbol(),symSetKey2=Symbol(),symSetKey3=Symbol(),symSet=new Set;symSet.add(symSetKey1);symSet.add(symSetKey2);chai_expect(symSet).to.have.all.keys(symSetKey1,symSetKey2);chai_expect(symSet).to.have.any.keys(symSetKey1,symSetKey3);chai_expect(symSet).to.contain.all.keys(symSetKey2,symSetKey1);chai_expect(symSet).to.contain.any.keys(symSetKey3,symSetKey1);chai_expect(symSet).to.not.have.all.keys(symSetKey1,symSetKey3);chai_expect(symSet).to.not.have.any.keys(symSetKey3);chai_expect(symSet).to.not.contain.all.keys(symSetKey3,symSetKey1);chai_expect(symSet).to.not.contain.any.keys(symSetKey3)});it("keys(array) will not mutate array (#359)",()=>{var expected=["b","a"];var original_order=["b","a"];var obj={b:1,a:1};chai_expect(expected).deep.equal(original_order);chai_expect(obj).keys(original_order);chai_expect(expected).deep.equal(original_order)});it("chaining",()=>{var tea={name:"chai",extras:["milk","sugar","smile"]};chai_expect(tea).to.have.property("extras").with.lengthOf(3);chai_expect(tea).to.have.property("extras").which.contains("smile");chai_expect(()=>{chai_expect(tea).to.have.property("extras").with.lengthOf(4)}).to.throw(chai_AssertionError,"expected [ 'milk', 'sugar', 'smile' ] to have a length of 4 but got 3");chai_expect(tea).to.be.a("object").and.have.property("name","chai");var badFn=function(){throw new Error("testing")};chai_expect(badFn).to.throw(Error).with.property("message","testing")});it("throw",function(){var PoorlyConstructedError=function(){this.name="PoorlyConstructedError"};PoorlyConstructedError.prototype=Object.create(Error.prototype);function CustomError(message){this.name="CustomError";this.message=message}CustomError.prototype=Error.prototype;var specificError=new RangeError("boo");var goodFn=function(){1==1},badFn=function(){throw new Error("testing")},refErrFn=function(){throw new ReferenceError("hello")},ickyErrFn=function(){throw new PoorlyConstructedError},specificErrFn=function(){throw specificError},customErrFn=function(){throw new CustomError("foo")},emptyErrFn=function(){throw new Error},emptyStringErrFn=function(){throw new Error("")};chai_expect(goodFn).to.not.throw();chai_expect(goodFn).to.not.throw(Error);chai_expect(goodFn).to.not.throw(specificError);chai_expect(badFn).to.throw();chai_expect(badFn).to.throw(Error);chai_expect(badFn).to.not.throw(ReferenceError);chai_expect(badFn).to.not.throw(specificError);chai_expect(refErrFn).to.throw();chai_expect(refErrFn).to.throw(ReferenceError);chai_expect(refErrFn).to.throw(Error);chai_expect(refErrFn).to.not.throw(TypeError);chai_expect(refErrFn).to.not.throw(specificError);chai_expect(ickyErrFn).to.throw();chai_expect(ickyErrFn).to.throw(PoorlyConstructedError);chai_expect(ickyErrFn).to.throw(Error);chai_expect(ickyErrFn).to.not.throw(specificError);chai_expect(specificErrFn).to.throw(specificError);chai_expect(goodFn).to.not.throw("testing");chai_expect(goodFn).to.not.throw(/testing/);chai_expect(badFn).to.throw(/testing/);chai_expect(badFn).to.not.throw(/hello/);chai_expect(badFn).to.throw("testing");chai_expect(badFn).to.not.throw("hello");chai_expect(emptyStringErrFn).to.throw("");chai_expect(emptyStringErrFn).to.not.throw("testing");chai_expect(badFn).to.throw("");chai_expect(badFn).to.throw(Error,/testing/);chai_expect(badFn).to.throw(Error,"testing");chai_expect(emptyErrFn).to.not.throw(Error,"testing");chai_expect(badFn).to.not.throw(Error,"I am the wrong error message");chai_expect(badFn).to.not.throw(TypeError,"testing");chai_expect(()=>{chai_expect(goodFn,"blah").to.throw()}).to.throw(chai_AssertionError,/^blah: expected \[Function( goodFn)*\] to throw an error$/);chai_expect(()=>{chai_expect(goodFn,"blah").to.throw(ReferenceError)}).to.throw(chai_AssertionError,/^blah: expected \[Function( goodFn)*\] to throw ReferenceError$/);chai_expect(()=>{chai_expect(goodFn,"blah").to.throw(specificError)}).to.throw(chai_AssertionError,/^blah: expected \[Function( goodFn)*\] to throw 'RangeError: boo'$/);chai_expect(()=>{chai_expect(badFn,"blah").to.not.throw()}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to not throw an error but 'Error: testing' was thrown$/);chai_expect(()=>{chai_expect(badFn,"blah").to.throw(ReferenceError)}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to throw 'ReferenceError' but 'Error: testing' was thrown$/);chai_expect(()=>{chai_expect(badFn,"blah").to.throw(specificError)}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to throw 'RangeError: boo' but 'Error: testing' was thrown$/);chai_expect(()=>{chai_expect(badFn,"blah").to.not.throw(Error)}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to not throw 'Error' but 'Error: testing' was thrown$/);chai_expect(()=>{chai_expect(refErrFn,"blah").to.not.throw(ReferenceError)}).to.throw(chai_AssertionError,/^blah: expected \[Function( refErrFn)*\] to not throw 'ReferenceError' but 'ReferenceError: hello' was thrown$/);chai_expect(()=>{chai_expect(badFn,"blah").to.throw(PoorlyConstructedError)}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to throw 'PoorlyConstructedError' but 'Error: testing' was thrown$/);chai_expect(()=>{chai_expect(ickyErrFn,"blah").to.not.throw(PoorlyConstructedError)}).to.throw(chai_AssertionError,/^blah: (expected \[Function( ickyErrFn)*\] to not throw 'PoorlyConstructedError' but)(.*)(PoorlyConstructedError|\{ Object \()(.*)(was thrown)$/);chai_expect(()=>{chai_expect(ickyErrFn,"blah").to.throw(ReferenceError)}).to.throw(chai_AssertionError,/^blah: (expected \[Function( ickyErrFn)*\] to throw 'ReferenceError' but)(.*)(PoorlyConstructedError|\{ Object \()(.*)(was thrown)$/);chai_expect(()=>{chai_expect(specificErrFn,"blah").to.throw(new ReferenceError("eek"))}).to.throw(chai_AssertionError,/^blah: expected \[Function( specificErrFn)*\] to throw 'ReferenceError: eek' but 'RangeError: boo' was thrown$/);chai_expect(()=>{chai_expect(specificErrFn,"blah").to.not.throw(specificError)}).to.throw(chai_AssertionError,/^blah: expected \[Function( specificErrFn)*\] to not throw 'RangeError: boo'$/);chai_expect(()=>{chai_expect(badFn,"blah").to.not.throw(/testing/)}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to throw error not matching \/testing\/$/);chai_expect(()=>{chai_expect(badFn,"blah").to.throw(/hello/)}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to throw error matching \/hello\/ but got 'testing'$/);chai_expect(()=>{chai_expect(badFn).to.throw(Error,/hello/,"blah")}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to throw error matching \/hello\/ but got 'testing'$/);chai_expect(()=>{chai_expect(badFn,"blah").to.throw(Error,/hello/)}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to throw error matching \/hello\/ but got 'testing'$/);chai_expect(()=>{chai_expect(badFn).to.throw(Error,"hello","blah")}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to throw error including 'hello' but got 'testing'$/);chai_expect(()=>{chai_expect(badFn,"blah").to.throw(Error,"hello")}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to throw error including 'hello' but got 'testing'$/);chai_expect(()=>{chai_expect(customErrFn,"blah").to.not.throw()}).to.throw(chai_AssertionError,/^blah: expected \[Function( customErrFn)*\] to not throw an error but 'CustomError: foo' was thrown$/);chai_expect(()=>{chai_expect(badFn).to.not.throw(Error,"testing","blah")}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to not throw 'Error' but 'Error: testing' was thrown$/);chai_expect(()=>{chai_expect(badFn,"blah").to.not.throw(Error,"testing")}).to.throw(chai_AssertionError,/^blah: expected \[Function( badFn)*\] to not throw 'Error' but 'Error: testing' was thrown$/);chai_expect(()=>{chai_expect(emptyStringErrFn).to.not.throw(Error,"","blah")}).to.throw(chai_AssertionError,/^blah: expected \[Function( emptyStringErrFn)*\] to not throw 'Error' but 'Error' was thrown$/);chai_expect(()=>{chai_expect(emptyStringErrFn,"blah").to.not.throw(Error,"")}).to.throw(chai_AssertionError,/^blah: expected \[Function( emptyStringErrFn)*\] to not throw 'Error' but 'Error' was thrown$/);chai_expect(()=>{chai_expect(emptyStringErrFn,"blah").to.not.throw("")}).to.throw(chai_AssertionError,/^blah: expected \[Function( emptyStringErrFn)*\] to throw error not including ''$/);chai_expect(()=>{chai_expect({},"blah").to.throw()}).to.throw(chai_AssertionError,"blah: expected {} to be a function");chai_expect(()=>{chai_expect({}).to.throw(Error,"testing","blah")}).to.throw(chai_AssertionError,"blah: expected {} to be a function")});it("respondTo",()=>{function Foo(){}Foo.prototype.bar=function(){};Foo.func=function(){};var bar={};bar.foo=function(){};chai_expect(Foo).to.respondTo("bar");chai_expect(Foo).to.not.respondTo("foo");chai_expect(Foo).itself.to.respondTo("func");chai_expect(Foo).itself.not.to.respondTo("bar");chai_expect(bar).to.respondTo("foo");chai_expect(()=>{chai_expect(Foo).to.respondTo("baz","constructor")}).to.throw(chai_AssertionError,/^(constructor: expected)(.*)(\[Function Foo\])(.*)(to respond to \'baz\')$/);chai_expect(()=>{chai_expect(Foo,"constructor").to.respondTo("baz")}).to.throw(chai_AssertionError,/^(constructor: expected)(.*)(\[Function Foo\])(.*)(to respond to \'baz\')$/);chai_expect(()=>{chai_expect(bar).to.respondTo("baz","object")}).to.throw(chai_AssertionError,/^(object: expected)(.*)(\{ foo: \[Function\] \}|\{ Object \()(.*)(to respond to \'baz\')$/);chai_expect(()=>{chai_expect(bar,"object").to.respondTo("baz")}).to.throw(chai_AssertionError,/^(object: expected)(.*)(\{ foo: \[Function\] \}|\{ Object \()(.*)(to respond to \'baz\')$/)});it("satisfy",()=>{var matcher=function(num){return num===1};chai_expect(1).to.satisfy(matcher);chai_expect(()=>{chai_expect(2).to.satisfy(matcher,"blah")}).to.throw(chai_AssertionError,/^blah: expected 2 to satisfy \[Function( matcher)*\]$/);chai_expect(()=>{chai_expect(2,"blah").to.satisfy(matcher)}).to.throw(chai_AssertionError,/^blah: expected 2 to satisfy \[Function( matcher)*\]$/)});it("closeTo",()=>{chai_expect(1.5).to.be.closeTo(1,.5);chai_expect(10).to.be.closeTo(20,20);chai_expect(-10).to.be.closeTo(20,30)});it("approximately",()=>{chai_expect(1.5).to.be.approximately(1,.5);chai_expect(10).to.be.approximately(20,20);chai_expect(-10).to.be.approximately(20,30)});it("oneOf",()=>{chai_expect(1).to.be.oneOf([1,2,3]);chai_expect("1").to.not.be.oneOf([1,2,3]);chai_expect([3,[4]]).to.not.be.oneOf([1,2,[3,4]]);var threeFour=[3,[4]];chai_expect(threeFour).to.be.oneOf([1,2,threeFour])});it("include.members",()=>{chai_expect([1,2,3]).to.include.members([]);chai_expect([1,2,3]).to.include.members([3,2]);chai_expect([1,2,3]).to.include.members([3,2,2]);chai_expect([1,2,3]).to.not.include.members([8,4]);chai_expect([1,2,3]).to.not.include.members([1,2,3,4]);chai_expect([{a:1}]).to.not.include.members([{a:1}]);chai_expect(()=>{chai_expect([1,2,3]).to.include.members([2,5],"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to be a superset of [ 2, 5 ]");chai_expect(()=>{chai_expect([1,2,3],"blah").to.include.members([2,5])}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to be a superset of [ 2, 5 ]");chai_expect(()=>{chai_expect([1,2,3]).to.not.include.members([2,1])}).to.throw(chai_AssertionError,"expected [ 1, 2, 3 ] to not be a superset of [ 2, 1 ]")});it("same.members",()=>{chai_expect([5,4]).to.have.same.members([4,5]);chai_expect([5,4]).to.have.same.members([5,4]);chai_expect([5,4,4]).to.have.same.members([5,4,4]);chai_expect([5,4]).to.not.have.same.members([]);chai_expect([5,4]).to.not.have.same.members([6,3]);chai_expect([5,4]).to.not.have.same.members([5,4,2]);chai_expect([5,4]).to.not.have.same.members([5,4,4]);chai_expect([5,4,4]).to.not.have.same.members([5,4]);chai_expect([5,4,4]).to.not.have.same.members([5,4,3]);chai_expect([5,4,3]).to.not.have.same.members([5,4,4])});it("members",()=>{chai_expect([5,4]).members([4,5]);chai_expect([5,4]).members([5,4]);chai_expect([5,4,4]).members([5,4,4]);chai_expect([5,4]).not.members([]);chai_expect([5,4]).not.members([6,3]);chai_expect([5,4]).not.members([5,4,2]);chai_expect([5,4]).not.members([5,4,4]);chai_expect([5,4,4]).not.members([5,4]);chai_expect([5,4,4]).not.members([5,4,3]);chai_expect([5,4,3]).not.members([5,4,4]);chai_expect([{id:1}]).not.members([{id:1}]);chai_expect(()=>{chai_expect([1,2,3]).members([2,1,5],"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have the same members as [ 2, 1, 5 ]");chai_expect(()=>{chai_expect([1,2,3],"blah").members([2,1,5])}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have the same members as [ 2, 1, 5 ]");chai_expect(()=>{chai_expect([1,2,3]).not.members([2,1,3])}).to.throw(chai_AssertionError,"expected [ 1, 2, 3 ] to not have the same members as [ 2, 1, 3 ]");chai_expect(()=>{chai_expect({}).members([],"blah")}).to.throw(chai_AssertionError,"blah: expected {} to be an iterable");chai_expect(()=>{chai_expect({},"blah").members([])}).to.throw(chai_AssertionError,"blah: expected {} to be an iterable");chai_expect(()=>{chai_expect([]).members({},"blah")}).to.throw(chai_AssertionError,"blah: expected {} to be an iterable");chai_expect(()=>{chai_expect([],"blah").members({})}).to.throw(chai_AssertionError,"blah: expected {} to be an iterable")});it("deep.members",()=>{chai_expect([{id:1}]).deep.members([{id:1}]);chai_expect([{a:1},{b:2},{b:2}]).deep.members([{a:1},{b:2},{b:2}]);chai_expect([{id:2}]).not.deep.members([{id:1}]);chai_expect([{a:1},{b:2}]).not.deep.members([{a:1},{b:2},{b:2}]);chai_expect([{a:1},{b:2},{b:2}]).not.deep.members([{a:1},{b:2}]);chai_expect([{a:1},{b:2},{b:2}]).not.deep.members([{a:1},{b:2},{c:3}]);chai_expect([{a:1},{b:2},{c:3}]).not.deep.members([{a:1},{b:2},{b:2}]);chai_expect(()=>{chai_expect([{id:1}]).deep.members([{id:2}],"blah")}).to.throw(chai_AssertionError,"blah: expected [ { id: 1 } ] to have the same members as [ { id: 2 } ]");chai_expect(()=>{chai_expect([{id:1}],"blah").deep.members([{id:2}])}).to.throw(chai_AssertionError,"blah: expected [ { id: 1 } ] to have the same members as [ { id: 2 } ]")});it("include.deep.members",()=>{chai_expect([{a:1},{b:2},{c:3}]).include.deep.members([{b:2},{a:1}]);chai_expect([{a:1},{b:2},{c:3}]).include.deep.members([{b:2},{a:1},{a:1}]);chai_expect([{a:1},{b:2},{c:3}]).not.include.deep.members([{b:2},{a:1},{f:5}]);chai_expect(()=>{chai_expect([{a:1},{b:2},{c:3}]).include.deep.members([{b:2},{a:1},{f:5}],"blah")}).to.throw(chai_AssertionError,"blah: expected [ { a: 1 }, { b: 2 }, { c: 3 } ] to be a superset of [ { b: 2 }, { a: 1 }, { f: 5 } ]");chai_expect(()=>{chai_expect([{a:1},{b:2},{c:3}],"blah").include.deep.members([{b:2},{a:1},{f:5}])}).to.throw(chai_AssertionError,"blah: expected [ { a: 1 }, { b: 2 }, { c: 3 } ] to be a superset of [ { b: 2 }, { a: 1 }, { f: 5 } ]")});it("ordered.members",()=>{chai_expect([1,2,3]).ordered.members([1,2,3]);chai_expect([1,2,2]).ordered.members([1,2,2]);chai_expect([1,2,3]).not.ordered.members([2,1,3]);chai_expect([1,2,3]).not.ordered.members([1,2]);chai_expect([1,2]).not.ordered.members([1,2,2]);chai_expect([1,2,2]).not.ordered.members([1,2]);chai_expect([1,2,2]).not.ordered.members([1,2,3]);chai_expect([1,2,3]).not.ordered.members([1,2,2]);chai_expect(()=>{chai_expect([1,2,3]).ordered.members([2,1,3],"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have the same ordered members as [ 2, 1, 3 ]");chai_expect(()=>{chai_expect([1,2,3],"blah").ordered.members([2,1,3])}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to have the same ordered members as [ 2, 1, 3 ]");chai_expect(()=>{chai_expect([1,2,3]).not.ordered.members([1,2,3])}).to.throw(chai_AssertionError,"expected [ 1, 2, 3 ] to not have the same ordered members as [ 1, 2, 3 ]")});it("include.ordered.members",()=>{chai_expect([1,2,3]).include.ordered.members([1,2]);chai_expect([1,2,3]).not.include.ordered.members([2,1]);chai_expect([1,2,3]).not.include.ordered.members([2,3]);chai_expect([1,2,3]).not.include.ordered.members([1,2,2]);chai_expect(()=>{chai_expect([1,2,3]).include.ordered.members([2,1],"blah")}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to be an ordered superset of [ 2, 1 ]");chai_expect(()=>{chai_expect([1,2,3],"blah").include.ordered.members([2,1])}).to.throw(chai_AssertionError,"blah: expected [ 1, 2, 3 ] to be an ordered superset of [ 2, 1 ]");chai_expect(()=>{chai_expect([1,2,3]).not.include.ordered.members([1,2])}).to.throw(chai_AssertionError,"expected [ 1, 2, 3 ] to not be an ordered superset of [ 1, 2 ]")});it("deep.ordered.members",()=>{chai_expect([{a:1},{b:2},{c:3}]).deep.ordered.members([{a:1},{b:2},{c:3}]);chai_expect([{a:1},{b:2},{b:2}]).deep.ordered.members([{a:1},{b:2},{b:2}]);chai_expect([{a:1},{b:2},{c:3}]).not.deep.ordered.members([{b:2},{a:1},{c:3}]);chai_expect([{a:1},{b:2}]).not.deep.ordered.members([{a:1},{b:2},{b:2}]);chai_expect([{a:1},{b:2},{b:2}]).not.deep.ordered.members([{a:1},{b:2}]);chai_expect([{a:1},{b:2},{b:2}]).not.deep.ordered.members([{a:1},{b:2},{c:3}]);chai_expect([{a:1},{b:2},{c:3}]).not.deep.ordered.members([{a:1},{b:2},{b:2}]);chai_expect(()=>{chai_expect([{a:1},{b:2},{c:3}]).deep.ordered.members([{b:2},{a:1},{c:3}],"blah")}).to.throw(chai_AssertionError,"blah: expected [ { a: 1 }, { b: 2 }, { c: 3 } ] to have the same ordered members as [ { b: 2 }, { a: 1 }, { c: 3 } ]");chai_expect(()=>{chai_expect([{a:1},{b:2},{c:3}],"blah").deep.ordered.members([{b:2},{a:1},{c:3}])}).to.throw(chai_AssertionError,"blah: expected [ { a: 1 }, { b: 2 }, { c: 3 } ] to have the same ordered members as [ { b: 2 }, { a: 1 }, { c: 3 } ]");chai_expect(()=>{chai_expect([{a:1},{b:2},{c:3}]).not.deep.ordered.members([{a:1},{b:2},{c:3}])}).to.throw(chai_AssertionError,"expected [ { a: 1 }, { b: 2 }, { c: 3 } ] to not have the same ordered members as [ { a: 1 }, { b: 2 }, { c: 3 } ]")});it("include.deep.ordered.members",()=>{chai_expect([{a:1},{b:2},{c:3}]).include.deep.ordered.members([{a:1},{b:2}]);chai_expect([{a:1},{b:2},{c:3}]).not.include.deep.ordered.members([{b:2},{a:1}]);chai_expect([{a:1},{b:2},{c:3}]).not.include.deep.ordered.members([{b:2},{c:3}]);chai_expect([{a:1},{b:2},{c:3}]).not.include.deep.ordered.members([{a:1},{b:2},{b:2}]);chai_expect(()=>{chai_expect([{a:1},{b:2},{c:3}]).include.deep.ordered.members([{b:2},{a:1}],"blah")}).to.throw(chai_AssertionError,"blah: expected [ { a: 1 }, { b: 2 }, { c: 3 } ] to be an ordered superset of [ { b: 2 }, { a: 1 } ]");chai_expect(()=>{chai_expect([{a:1},{b:2},{c:3}],"blah").include.deep.ordered.members([{b:2},{a:1}])}).to.throw(chai_AssertionError,"blah: expected [ { a: 1 }, { b: 2 }, { c: 3 } ] to be an ordered superset of [ { b: 2 }, { a: 1 } ]");chai_expect(()=>{chai_expect([{a:1},{b:2},{c:3}]).not.include.deep.ordered.members([{a:1},{b:2}])}).to.throw(chai_AssertionError,"expected [ { a: 1 }, { b: 2 }, { c: 3 } ] to not be an ordered superset of [ { a: 1 }, { b: 2 } ]")});it("change",()=>{const obj={value:10,str:"foo"};const heroes=["spiderman","superman"];const fn=()=>obj.value+=5;const decFn=()=>obj.value-=20;const sameFn=()=>"foo"+"bar";const bangFn=()=>obj.str+="!";const batFn=()=>heroes.push("batman");const lenFn=()=>heroes.length;chai_expect(fn).to.change(obj,"value");chai_expect(fn).to.change(obj,"value").by(5);chai_expect(fn).to.change(obj,"value").by(-5);chai_expect(decFn).to.change(obj,"value").by(20);chai_expect(decFn).to.change(obj,"value").but.not.by(21);chai_expect(sameFn).to.not.change(obj,"value");chai_expect(sameFn).to.not.change(obj,"str");chai_expect(bangFn).to.change(obj,"str");chai_expect(batFn).to.change(lenFn).by(1);chai_expect(batFn).to.change(lenFn).but.not.by(2);chai_expect(()=>{chai_expect(sameFn).to.change(obj,"value","blah")}).to.throw(chai_AssertionError,"blah: expected .value to change");chai_expect(()=>{chai_expect(sameFn,"blah").to.change(obj,"value")}).to.throw(chai_AssertionError,"blah: expected .value to change");chai_expect(()=>{chai_expect(fn).to.not.change(obj,"value","blah")}).to.throw(chai_AssertionError,"blah: expected .value to not change");chai_expect(()=>{chai_expect({}).to.change(obj,"value","blah")}).to.throw(chai_AssertionError,"blah: expected {} to be a function");chai_expect(()=>{chai_expect({},"blah").to.change(obj,"value")}).to.throw(chai_AssertionError,"blah: expected {} to be a function");chai_expect(()=>{chai_expect(fn).to.change({},"badprop","blah")}).to.throw(chai_AssertionError,"blah: expected {} to have property 'badprop'");chai_expect(()=>{chai_expect(fn,"blah").to.change({},"badprop")}).to.throw(chai_AssertionError,"blah: expected {} to have property 'badprop'");chai_expect(()=>{chai_expect(fn,"blah").to.change({})}).to.throw(chai_AssertionError,"blah: expected {} to be a function");chai_expect(()=>{chai_expect(fn).to.change(obj,"value").by(10,"blah")}).to.throw(chai_AssertionError,"blah: expected .value to change by 10");chai_expect(()=>{chai_expect(fn,"blah").to.change(obj,"value").by(10)}).to.throw(chai_AssertionError,"blah: expected .value to change by 10");chai_expect(()=>{chai_expect(fn).to.change(obj,"value").but.not.by(5,"blah")}).to.throw(chai_AssertionError,"blah: expected .value to not change by 5")});it("increase, decrease",()=>{var obj={value:10,noop:null},arr=["one","two"],pFn=function(){arr.push("three")},popFn=function(){arr.pop()},nFn=function(){return null},lenFn=function(){return arr.length},incFn=function(){obj.value+=2},decFn=function(){obj.value-=3},smFn=function(){obj.value+=0};chai_expect(smFn).to.not.increase(obj,"value");chai_expect(decFn).to.not.increase(obj,"value");chai_expect(incFn).to.increase(obj,"value");chai_expect(incFn).to.increase(obj,"value").by(2);chai_expect(incFn).to.increase(obj,"value").but.not.by(1);chai_expect(smFn).to.not.decrease(obj,"value");chai_expect(incFn).to.not.decrease(obj,"value");chai_expect(decFn).to.decrease(obj,"value");chai_expect(decFn).to.decrease(obj,"value").by(3);chai_expect(decFn).to.decrease(obj,"value").but.not.by(2);chai_expect(popFn).to.not.increase(lenFn);chai_expect(nFn).to.not.increase(lenFn);chai_expect(pFn).to.increase(lenFn);chai_expect(pFn).to.increase(lenFn).by(1);chai_expect(pFn).to.increase(lenFn).but.not.by(2);chai_expect(popFn).to.decrease(lenFn);chai_expect(popFn).to.decrease(lenFn).by(1);chai_expect(popFn).to.decrease(lenFn).but.not.by(2);chai_expect(nFn).to.not.decrease(lenFn);chai_expect(pFn).to.not.decrease(lenFn)});it("extensible",function(){const nonExtensibleObject=Object.preventExtensions({});chai_expect({}).to.be.extensible;chai_expect(nonExtensibleObject).to.not.be.extensible;chai_expect(()=>{chai_expect(nonExtensibleObject,"blah").to.be.extensible}).to.throw(chai_AssertionError,"blah: expected {} to be extensible");chai_expect(()=>{chai_expect({}).to.not.be.extensible}).to.throw(chai_AssertionError,"expected {} to not be extensible");chai_expect(42).to.not.be.extensible;chai_expect(null).to.not.be.extensible;chai_expect("foo").to.not.be.extensible;chai_expect(false).to.not.be.extensible;chai_expect(undefined).to.not.be.extensible;chai_expect(sym).to.not.be.extensible;chai_expect(()=>{chai_expect(42).to.be.extensible}).to.throw(chai_AssertionError,"expected 42 to be extensible");chai_expect(()=>{chai_expect(null).to.be.extensible}).to.throw(chai_AssertionError,"expected null to be extensible");chai_expect(()=>{chai_expect("foo").to.be.extensible}).to.throw(chai_AssertionError,"expected 'foo' to be extensible");chai_expect(()=>{chai_expect(false).to.be.extensible}).to.throw(chai_AssertionError,"expected false to be extensible");chai_expect(()=>{chai_expect(undefined).to.be.extensible}).to.throw(chai_AssertionError,"expected undefined to be extensible");const proxy=new Proxy({},{isExtensible(){throw new TypeError}});chai_expect(()=>{chai_expect(proxy).to.be.extensible}).to.throw(TypeError)});it("sealed",function(){const sealedObject=Object.seal({});chai_expect(sealedObject).to.be.sealed;chai_expect({}).to.not.be.sealed;chai_expect(()=>{chai_expect({}).to.be.sealed}).to.throw(chai_AssertionError,"expected {} to be sealed");chai_expect(()=>{chai_expect(sealedObject).to.not.be.sealed}).to.throw(chai_AssertionError,"expected {} to not be sealed");chai_expect(42).to.be.sealed;chai_expect(null).to.be.sealed;chai_expect("foo").to.be.sealed;chai_expect(false).to.be.sealed;chai_expect(undefined).to.be.sealed;chai_expect(sym).to.be.sealed;chai_expect(()=>{chai_expect(42).to.not.be.sealed}).to.throw(chai_AssertionError,"expected 42 to not be sealed");chai_expect(()=>{chai_expect(null).to.not.be.sealed}).to.throw(chai_AssertionError,"expected null to not be sealed");chai_expect(()=>{chai_expect("foo").to.not.be.sealed}).to.throw(chai_AssertionError,"expected 'foo' to not be sealed");chai_expect(()=>{chai_expect(false).to.not.be.sealed}).to.throw(chai_AssertionError,"expected false to not be sealed");chai_expect(()=>{chai_expect(undefined).to.not.be.sealed}).to.throw(chai_AssertionError,"expected undefined to not be sealed");const proxy=new Proxy({},{ownKeys(){throw new TypeError}});Object.preventExtensions(proxy);chai_expect(()=>{chai_expect(proxy).to.be.sealed}).to.throw(TypeError)});it("frozen",function(){const frozenObject=Object.freeze({});chai_expect(frozenObject).to.be.frozen;chai_expect({}).to.not.be.frozen;chai_expect(()=>{chai_expect({}).to.be.frozen}).to.throw(chai_AssertionError,"expected {} to be frozen");chai_expect(()=>{chai_expect(frozenObject).to.not.be.frozen}).to.throw(chai_AssertionError,"expected {} to not be frozen");chai_expect(42).to.be.frozen;chai_expect(null).to.be.frozen;chai_expect("foo").to.be.frozen;chai_expect(false).to.be.frozen;chai_expect(undefined).to.be.frozen;chai_expect(sym).to.be.frozen;chai_expect(()=>{chai_expect(42).to.not.be.frozen}).to.throw(chai_AssertionError,"expected 42 to not be frozen");chai_expect(()=>{chai_expect(null).to.not.be.frozen}).to.throw(chai_AssertionError,"expected null to not be frozen");chai_expect(()=>{chai_expect("foo").to.not.be.frozen}).to.throw(chai_AssertionError,"expected 'foo' to not be frozen");chai_expect(()=>{chai_expect(false).to.not.be.frozen}).to.throw(chai_AssertionError,"expected false to not be frozen");chai_expect(()=>{chai_expect(undefined).to.not.be.frozen}).to.throw(chai_AssertionError,"expected undefined to not be frozen");const proxy=new Proxy({},{ownKeys(){throw new TypeError}});Object.preventExtensions(proxy);chai_expect(()=>{chai_expect(proxy).to.be.frozen}).to.throw(TypeError)})});function runTest(fileData){tests.forEach(test=>test.func())}self.WTBenchmark=__webpack_exports__})();