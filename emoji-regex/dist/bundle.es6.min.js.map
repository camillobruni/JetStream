{"version":3,"file":"bundle.es6.min.js","mappings":"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","sources":["webpack://EmojiRegexBenchmark/webpack/bootstrap","webpack://EmojiRegexBenchmark/webpack/runtime/define property getters","webpack://EmojiRegexBenchmark/webpack/runtime/hasOwnProperty shorthand","webpack://EmojiRegexBenchmark/webpack/runtime/make namespace object","webpack://EmojiRegexBenchmark/../src/defaults.ts","webpack://EmojiRegexBenchmark/../src/rules.ts","webpack://EmojiRegexBenchmark/../src/helpers.ts","webpack://EmojiRegexBenchmark/../src/Tokenizer.ts","webpack://EmojiRegexBenchmark/../src/Lexer.ts","webpack://EmojiRegexBenchmark/../src/Renderer.ts","webpack://EmojiRegexBenchmark/../src/TextRenderer.ts","webpack://EmojiRegexBenchmark/../src/Parser.ts","webpack://EmojiRegexBenchmark/../src/Hooks.ts","webpack://EmojiRegexBenchmark/../src/marked.ts","webpack://EmojiRegexBenchmark/../src/Instance.ts","webpack://EmojiRegexBenchmark/./src/test.mjs","webpack://EmojiRegexBenchmark/./node_modules/emoji-regex/index.mjs"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Gets the original marked default options.\n */\nexport function _getDefaults<ParserOutput = string, RendererOutput = string>(): MarkedOptions<ParserOutput, RendererOutput> {\n  return {\n    async: false,\n    breaks: false,\n    extensions: null,\n    gfm: true,\n    hooks: null,\n    pedantic: false,\n    renderer: null,\n    silent: false,\n    tokenizer: null,\n    walkTokens: null,\n  };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport let _defaults: MarkedOptions<any, any> = _getDefaults();\n\nexport function changeDefaults<ParserOutput = string, RendererOutput = string>(newDefaults: MarkedOptions<ParserOutput, RendererOutput>) {\n  _defaults = newDefaults;\n}\n","const noopTest = { exec: () => null } as unknown as RegExp;\n\nfunction edit(regex: string | RegExp, opt = '') {\n  let source = typeof regex === 'string' ? regex : regex.source;\n  const obj = {\n    replace: (name: string | RegExp, val: string | RegExp) => {\n      let valSource = typeof val === 'string' ? val : val.source;\n      valSource = valSource.replace(other.caret, '$1');\n      source = source.replace(name, valSource);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(source, opt);\n    },\n  };\n  return obj;\n}\n\nconst supportsLookbehind = (() => {\ntry {\n  // eslint-disable-next-line prefer-regex-literals\n  return !!new RegExp('(?<=1)(?<!1)');\n} catch {\n  // See browser support here:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Lookbehind_assertion\n  return false;\n}\n})();\n\nexport const other = {\n  codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n  outputLinkReplace: /\\\\([\\[\\]])/g,\n  indentCodeCompensation: /^(\\s+)(?:```)/,\n  beginningSpace: /^\\s+/,\n  endingHash: /#$/,\n  startingSpaceChar: /^ /,\n  endingSpaceChar: / $/,\n  nonSpaceChar: /[^ ]/,\n  newLineCharGlobal: /\\n/g,\n  tabCharGlobal: /\\t/g,\n  multipleSpaceGlobal: /\\s+/g,\n  blankLine: /^[ \\t]*$/,\n  doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n  blockquoteStart: /^ {0,3}>/,\n  blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n  blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n  listIsTask: /^\\[[ xX]\\] +\\S/,\n  listReplaceTask: /^\\[[ xX]\\] +/,\n  listTaskCheckbox: /\\[[ xX]\\]/,\n  anyLine: /\\n.*\\n/,\n  hrefBrackets: /^<(.*)>$/,\n  tableDelimiter: /[:|]/,\n  tableAlignChars: /^\\||\\| *$/g,\n  tableRowBlankLine: /\\n[ \\t]*$/,\n  tableAlignRight: /^ *-+: *$/,\n  tableAlignCenter: /^ *:-+: *$/,\n  tableAlignLeft: /^ *:-+ *$/,\n  startATag: /^<a /i,\n  endATag: /^<\\/a>/i,\n  startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n  endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n  startAngleBracket: /^</,\n  endAngleBracket: />$/,\n  pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n  unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n  escapeTest: /[&<>\"']/,\n  escapeReplace: /[&<>\"']/g,\n  escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n  escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n  unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n  caret: /(^|[^\\[])\\^/g,\n  percentDecode: /%25/g,\n  findPipe: /\\|/g,\n  splitPipe: / \\|/,\n  slashPipe: /\\\\\\|/g,\n  carriageReturn: /\\r\\n|\\r/g,\n  spaceLine: /^ +$/gm,\n  notSpaceStart: /^\\S*/,\n  endingNewline: /\\n$/,\n  listItemRegex: (bull: string) => new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n  nextBulletRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n  hrRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n  fencesBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n  headingBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n  htmlBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),\n  blockquoteBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}>`),\n};\n\n/**\n * Block-Level Grammar\n */\n\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = / {0,3}(?:[*+-]|\\d{1,9}[.)])/;\nconst lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\nconst lheading = edit(lheadingCore)\n  .replace(/bull/g, bullet) // lists can interrupt\n  .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n  .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n  .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n  .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n  .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n  .replace(/\\|table/g, '') // table not in commonmark\n  .getRegex();\nconst lheadingGfm = edit(lheadingCore)\n  .replace(/bull/g, bullet) // lists can interrupt\n  .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n  .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n  .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n  .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n  .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n  .replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/) // table can interrupt\n  .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\[\\s\\S]|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n  .replace('label', _blockLabel)\n  .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n  .getRegex();\n\nconst list = edit(/^(bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n  .replace(/bull/g, bullet)\n  .getRegex();\n\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n  + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit(\n  '^ {0,3}(?:' // optional indentation\n+ '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n+ '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n+ '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n+ '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n+ '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n+ '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n+ '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n+ '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n+ ')', 'i')\n  .replace('comment', _comment)\n  .replace('tag', _tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nconst paragraph = edit(_paragraph)\n  .replace('hr', hr)\n  .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n  .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n  .replace('|table', '')\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)])[ \\\\t]') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n  .replace('paragraph', paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nconst blockNormal = {\n  blockquote,\n  code: blockCode,\n  def,\n  fences,\n  heading,\n  hr,\n  html,\n  lheading,\n  list,\n  newline,\n  paragraph,\n  table: noopTest,\n  text: blockText,\n};\n\ntype BlockKeys = keyof typeof blockNormal;\n\n/**\n * GFM Block Grammar\n */\n\nconst gfmTable = edit(\n  '^ *([^\\\\n ].*)\\\\n' // Header\n+ ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n+ '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n  .replace('hr', hr)\n  .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)])[ \\\\t]') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\nconst blockGfm: Record<BlockKeys, RegExp> = {\n  ...blockNormal,\n  lheading: lheadingGfm,\n  table: gfmTable,\n  paragraph: edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('table', gfmTable) // interrupt paragraphs with table\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)])[ \\\\t]') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex(),\n};\n\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nconst blockPedantic: Record<BlockKeys, RegExp> = {\n  ...blockNormal,\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', _comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n  heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n  fences: noopTest, // fences not supported\n  lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  paragraph: edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' *#{1,6} *[^\\n]')\n    .replace('lheading', lheading)\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('|fences', '')\n    .replace('|list', '')\n    .replace('|html', '')\n    .replace('|tag', '')\n    .getRegex(),\n};\n\n/**\n * Inline-Level Grammar\n */\n\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = /[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\nconst punctuation = edit(/^((?![*_])punctSpace)/, 'u')\n  .replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n\n// GFM allows ~ inside strong and em for strikethrough\nconst _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n\n// GFM allows * and _ inside strikethrough\nconst _punctuationGfmDel = /(?![*_])[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpaceGfmDel = /(?![*_])[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpaceGfmDel = /(?:[^\\s\\p{P}\\p{S}]|[*_])/u;\n\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = edit(/link|precode-code|html/, 'g')\n  .replace('link', /\\[(?:[^\\[\\]`]|(?<a>`+)[^`]+\\k<a>(?!`))*?\\]\\((?:\\\\[\\s\\S]|[^\\\\\\(\\)]|\\((?:\\\\[\\s\\S]|[^\\\\\\(\\)])*\\))*\\)/)\n  .replace('precode-', supportsLookbehind ? '(?<!`)()' : '(^^|[^`])')\n  .replace('code', /(?<b>`+)[^`]+\\k<b>(?!`)/)\n  .replace('html', /<(?! )[^<>]*?>/)\n  .getRegex();\n\nconst emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\n\nconst emStrongLDelim = edit(emStrongLDelimCore, 'u')\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')\n  .replace(/punct/g, _punctuationGfmStrongEm)\n  .getRegex();\n\nconst emStrongRDelimAstCore =\n  '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n+ '|[^*]+(?=[^*])' // Consume to delim\n+ '|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n+ '|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter\n+ '|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter\n+ '|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)' // (4) ***# can only be Left Delimiter\n+ '|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter\n+ '|notPunctSpace(\\\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter\n\nconst emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n  .replace(/punctSpace/g, _punctuationOrSpace)\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)\n  .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)\n  .replace(/punct/g, _punctuationGfmStrongEm)\n  .getRegex();\n\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit(\n  '^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n+ '|[^_]+(?=[^_])' // Consume to delim\n+ '|(?!_)punct(_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n+ '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter\n+ '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter\n+ '|[\\\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter\n+ '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter\n  .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n  .replace(/punctSpace/g, _punctuationOrSpace)\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\n// Tilde left delimiter for strikethrough (similar to emStrongLDelim for asterisk)\nconst delLDelim = edit(/^~~?(?:((?!~)punct)|[^\\s~])/, 'u')\n  .replace(/punct/g, _punctuationGfmDel)\n  .getRegex();\n\n// Tilde delimiter patterns for strikethrough (similar to asterisk)\nconst delRDelimCore =\n  '^[^~]+(?=[^~])' // Consume to delim\n+ '|(?!~)punct(~~?)(?=[\\\\s]|$)' // (1) #~~ can only be a Right Delimiter\n+ '|notPunctSpace(~~?)(?!~)(?=punctSpace|$)' // (2) a~~#, a~~ can only be a Right Delimiter\n+ '|(?!~)punctSpace(~~?)(?=notPunctSpace)' // (3) #~~a, ~~a can only be Left Delimiter\n+ '|[\\\\s](~~?)(?!~)(?=punct)' // (4) ~~# can only be Left Delimiter\n+ '|(?!~)punct(~~?)(?!~)(?=punct)' // (5) #~~# can be either Left or Right Delimiter\n+ '|notPunctSpace(~~?)(?=notPunctSpace)'; // (6) a~~a can be either Left or Right Delimiter\n\nconst delRDelim = edit(delRDelimCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmDel)\n  .replace(/punctSpace/g, _punctuationOrSpaceGfmDel)\n  .replace(/punct/g, _punctuationGfmDel)\n  .getRegex();\n\nconst anyPunctuation = edit(/\\\\(punct)/, 'gu')\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n  .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n  .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n  .getRegex();\n\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit(\n  '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n  .replace('comment', _inlineComment)\n  .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nconst _inlineLabel = /(?:\\[(?:\\\\[\\s\\S]|[^\\[\\]\\\\])*\\]|\\\\[\\s\\S]|`+[^`]*?`+(?!`)|[^\\[\\]\\\\`])*?/;\n\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:(?:[ \\t]*(?:\\n[ \\t]*)?)(title))?\\s*\\)/)\n  .replace('label', _inlineLabel)\n  .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^ \\t\\n\\x00-\\x1f]*/)\n  .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n  .getRegex();\n\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n  .replace('label', _inlineLabel)\n  .replace('ref', _blockLabel)\n  .getRegex();\n\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n  .replace('ref', _blockLabel)\n  .getRegex();\n\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n  .replace('reflink', reflink)\n  .replace('nolink', nolink)\n  .getRegex();\n\nconst _caseInsensitiveProtocol = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/;\n\n/**\n * Normal Inline Grammar\n */\n\nconst inlineNormal = {\n  _backpedal: noopTest, // only used for GFM url\n  anyPunctuation,\n  autolink,\n  blockSkip,\n  br,\n  code: inlineCode,\n  del: noopTest,\n  delLDelim: noopTest,\n  delRDelim: noopTest,\n  emStrongLDelim,\n  emStrongRDelimAst,\n  emStrongRDelimUnd,\n  escape,\n  link,\n  nolink,\n  punctuation,\n  reflink,\n  reflinkSearch,\n  tag,\n  text: inlineText,\n  url: noopTest,\n};\n\ntype InlineKeys = keyof typeof inlineNormal;\n\n/**\n * Pedantic Inline Grammar\n */\n\nconst inlinePedantic: Record<InlineKeys, RegExp> = {\n  ...inlineNormal,\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', _inlineLabel)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', _inlineLabel)\n    .getRegex(),\n};\n\n/**\n * GFM Inline Grammar\n */\n\nconst inlineGfm: Record<InlineKeys, RegExp> = {\n  ...inlineNormal,\n  emStrongRDelimAst: emStrongRDelimAstGfm,\n  emStrongLDelim: emStrongLDelimGfm,\n  delLDelim,\n  delRDelim,\n  url: edit(/^((?:protocol):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/)\n    .replace('protocol', _caseInsensitiveProtocol)\n    .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n    .getRegex(),\n  _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n  del: /^(~~?)(?=[^\\s~])((?:\\\\[\\s\\S]|[^\\\\])*?(?:\\\\[\\s\\S]|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n  text: edit(/^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|protocol:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/)\n    .replace('protocol', _caseInsensitiveProtocol)\n    .getRegex(),\n};\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\nconst inlineBreaks: Record<InlineKeys, RegExp> = {\n  ...inlineGfm,\n  br: edit(br).replace('{2,}', '*').getRegex(),\n  text: edit(inlineGfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex(),\n};\n\n/**\n * exports\n */\n\nexport const block = {\n  normal: blockNormal,\n  gfm: blockGfm,\n  pedantic: blockPedantic,\n};\n\nexport const inline = {\n  normal: inlineNormal,\n  gfm: inlineGfm,\n  breaks: inlineBreaks,\n  pedantic: inlinePedantic,\n};\n\nexport interface Rules {\n  other: typeof other\n  block: Record<BlockKeys, RegExp>\n  inline: Record<InlineKeys, RegExp>\n}\n","import { other } from './rules.ts';\n\n/**\n * Helpers\n */\nconst escapeReplacements: { [index: string]: string } = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch: string) => escapeReplacements[ch];\n\nexport function escape(html: string, encode?: boolean) {\n  if (encode) {\n    if (other.escapeTest.test(html)) {\n      return html.replace(other.escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (other.escapeTestNoEncode.test(html)) {\n      return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n\nexport function unescape(html: string) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(other.unescapeTest, (_, n) => {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nexport function cleanUrl(href: string) {\n  try {\n    href = encodeURI(href).replace(other.percentDecode, '%');\n  } catch {\n    return null;\n  }\n  return href;\n}\n\nexport function splitCells(tableRow: string, count?: number) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(other.findPipe, (match, offset, str) => {\n      let escaped = false;\n      let curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(other.splitPipe);\n  let i = 0;\n\n  // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n  if (!cells[0].trim()) {\n    cells.shift();\n  }\n  if (cells.length > 0 && !cells.at(-1)?.trim()) {\n    cells.pop();\n  }\n\n  if (count) {\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) cells.push('');\n    }\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(other.slashPipe, '|');\n  }\n  return cells;\n}\n\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nexport function rtrim(str: string, c: string, invert?: boolean) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.slice(0, l - suffLen);\n}\n\nexport function findClosingBracket(str: string, b: string) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n\n  let level = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  if (level > 0) {\n    return -2;\n  }\n\n  return -1;\n}\n\nexport function expandTabs(line: string, indent = 0) {\n  let col = indent;\n  let expanded = '';\n  for (const char of line) {\n    if (char === '\\t') {\n      const added = 4 - (col % 4);\n      expanded += ' '.repeat(added);\n      col += added;\n    } else {\n      expanded += char;\n      col++;\n    }\n  }\n\n  return expanded;\n}\n","import { _defaults } from './defaults.ts';\nimport {\n  rtrim,\n  splitCells,\n  findClosingBracket,\n  expandTabs,\n} from './helpers.ts';\nimport type { Rules } from './rules.ts';\nimport type { _Lexer } from './Lexer.ts';\nimport type { Links, Tokens, Token } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\nfunction outputLink(cap: string[], link: Pick<Tokens.Link, 'href' | 'title'>, raw: string, lexer: _Lexer, rules: Rules): Tokens.Link | Tokens.Image {\n  const href = link.href;\n  const title = link.title || null;\n  const text = cap[1].replace(rules.other.outputLinkReplace, '$1');\n\n  lexer.state.inLink = true;\n  const token: Tokens.Link | Tokens.Image = {\n    type: cap[0].charAt(0) === '!' ? 'image' : 'link',\n    raw,\n    href,\n    title,\n    text,\n    tokens: lexer.inlineTokens(text),\n  };\n  lexer.state.inLink = false;\n  return token;\n}\n\nfunction indentCodeCompensation(raw: string, text: string, rules: Rules) {\n  const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n\n  if (matchIndentToCode === null) {\n    return text;\n  }\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(rules.other.beginningSpace);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nexport class _Tokenizer<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  rules!: Rules; // set by the lexer\n  lexer!: _Lexer<ParserOutput, RendererOutput>; // set by the lexer\n\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n  }\n\n  space(src: string): Tokens.Space | undefined {\n    const cap = this.rules.block.newline.exec(src);\n    if (cap && cap[0].length > 0) {\n      return {\n        type: 'space',\n        raw: cap[0],\n      };\n    }\n  }\n\n  code(src: string): Tokens.Code | undefined {\n    const cap = this.rules.block.code.exec(src);\n    if (cap) {\n      const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');\n      return {\n        type: 'code',\n        raw: cap[0],\n        codeBlockStyle: 'indented',\n        text: !this.options.pedantic\n          ? rtrim(text, '\\n')\n          : text,\n      };\n    }\n  }\n\n  fences(src: string): Tokens.Code | undefined {\n    const cap = this.rules.block.fences.exec(src);\n    if (cap) {\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '', this.rules);\n\n      return {\n        type: 'code',\n        raw,\n        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n        text,\n      };\n    }\n  }\n\n  heading(src: string): Tokens.Heading | undefined {\n    const cap = this.rules.block.heading.exec(src);\n    if (cap) {\n      let text = cap[2].trim();\n\n      // remove trailing #s\n      if (this.rules.other.endingHash.test(text)) {\n        const trimmed = rtrim(text, '#');\n        if (this.options.pedantic) {\n          text = trimmed.trim();\n        } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim();\n        }\n      }\n\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[1].length,\n        text,\n        tokens: this.lexer.inline(text),\n      };\n    }\n  }\n\n  hr(src: string): Tokens.Hr | undefined {\n    const cap = this.rules.block.hr.exec(src);\n    if (cap) {\n      return {\n        type: 'hr',\n        raw: rtrim(cap[0], '\\n'),\n      };\n    }\n  }\n\n  blockquote(src: string): Tokens.Blockquote | undefined {\n    const cap = this.rules.block.blockquote.exec(src);\n    if (cap) {\n      let lines = rtrim(cap[0], '\\n').split('\\n');\n      let raw = '';\n      let text = '';\n      const tokens: Token[] = [];\n\n      while (lines.length > 0) {\n        let inBlockquote = false;\n        const currentLines = [];\n\n        let i;\n        for (i = 0; i < lines.length; i++) {\n          // get lines up to a continuation\n          if (this.rules.other.blockquoteStart.test(lines[i])) {\n            currentLines.push(lines[i]);\n            inBlockquote = true;\n          } else if (!inBlockquote) {\n            currentLines.push(lines[i]);\n          } else {\n            break;\n          }\n        }\n        lines = lines.slice(i);\n\n        const currentRaw = currentLines.join('\\n');\n        const currentText = currentRaw\n          // precede setext continuation with 4 spaces so it isn't a setext\n          .replace(this.rules.other.blockquoteSetextReplace, '\\n    $1')\n          .replace(this.rules.other.blockquoteSetextReplace2, '');\n        raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n        text = text ? `${text}\\n${currentText}` : currentText;\n\n        // parse blockquote lines as top level tokens\n        // merge paragraphs if this is a continuation\n        const top = this.lexer.state.top;\n        this.lexer.state.top = true;\n        this.lexer.blockTokens(currentText, tokens, true);\n        this.lexer.state.top = top;\n\n        // if there is no continuation then we are done\n        if (lines.length === 0) {\n          break;\n        }\n\n        const lastToken = tokens.at(-1);\n\n        if (lastToken?.type === 'code') {\n          // blockquote continuation cannot be preceded by a code block\n          break;\n        } else if (lastToken?.type === 'blockquote') {\n          // include continuation in nested blockquote\n          const oldToken = lastToken as Tokens.Blockquote;\n          const newText = oldToken.raw + '\\n' + lines.join('\\n');\n          const newToken = this.blockquote(newText)!;\n          tokens[tokens.length - 1] = newToken;\n\n          raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n          text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n          break;\n        } else if (lastToken?.type === 'list') {\n          // include continuation in nested list\n          const oldToken = lastToken as Tokens.List;\n          const newText = oldToken.raw + '\\n' + lines.join('\\n');\n          const newToken = this.list(newText)!;\n          tokens[tokens.length - 1] = newToken;\n\n          raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n          text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n          lines = newText.substring(tokens.at(-1)!.raw.length).split('\\n');\n          continue;\n        }\n      }\n\n      return {\n        type: 'blockquote',\n        raw,\n        tokens,\n        text,\n      };\n    }\n  }\n\n  list(src: string): Tokens.List | undefined {\n    let cap = this.rules.block.list.exec(src);\n    if (cap) {\n      let bull = cap[1].trim();\n      const isordered = bull.length > 1;\n\n      const list: Tokens.List = {\n        type: 'list',\n        raw: '',\n        ordered: isordered,\n        start: isordered ? +bull.slice(0, -1) : '',\n        loose: false,\n        items: [],\n      };\n\n      bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\n      if (this.options.pedantic) {\n        bull = isordered ? bull : '[*+-]';\n      }\n\n      // Get next list item\n      const itemRegex = this.rules.other.listItemRegex(bull);\n      let endsWithBlankLine = false;\n      // Check if current bullet point can start a new List Item\n      while (src) {\n        let endEarly = false;\n        let raw = '';\n        let itemContents = '';\n        if (!(cap = itemRegex.exec(src))) {\n          break;\n        }\n\n        if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n          break;\n        }\n\n        raw = cap[0];\n        src = src.substring(raw.length);\n\n        let line = expandTabs(cap[2].split('\\n', 1)[0], cap[1].length);\n        let nextLine = src.split('\\n', 1)[0];\n        let blankLine = !line.trim();\n\n        let indent = 0;\n        if (this.options.pedantic) {\n          indent = 2;\n          itemContents = line.trimStart();\n        } else if (blankLine) {\n          indent = cap[1].length + 1;\n        } else {\n          indent = line.search(this.rules.other.nonSpaceChar); // Find first non-space char\n          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n          itemContents = line.slice(indent);\n          indent += cap[1].length;\n        }\n\n        if (blankLine && this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line\n          raw += nextLine + '\\n';\n          src = src.substring(nextLine.length + 1);\n          endEarly = true;\n        }\n\n        if (!endEarly) {\n          const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n          const hrRegex = this.rules.other.hrRegex(indent);\n          const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n          const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n          const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n          const blockquoteBeginRegex = this.rules.other.blockquoteBeginRegex(indent);\n\n          // Check if following lines should be included in List Item\n          while (src) {\n            const rawLine = src.split('\\n', 1)[0];\n            let nextLineWithoutTabs;\n            nextLine = rawLine;\n\n            // Re-align to follow commonmark nesting rules\n            if (this.options.pedantic) {\n              nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');\n              nextLineWithoutTabs = nextLine;\n            } else {\n              nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');\n            }\n\n            // End list item if found code fences\n            if (fencesBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new heading\n            if (headingBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of html block\n            if (htmlBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of blockquote\n            if (blockquoteBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new bullet\n            if (nextBulletRegex.test(nextLine)) {\n              break;\n            }\n\n            // Horizontal rule found\n            if (hrRegex.test(nextLine)) {\n              break;\n            }\n\n            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) { // Dedent if possible\n              itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n            } else {\n              // not enough indentation\n              if (blankLine) {\n                break;\n              }\n\n              // paragraph continuation unless last line was a different block level element\n              if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) { // indented code block\n                break;\n              }\n              if (fencesBeginRegex.test(line)) {\n                break;\n              }\n              if (headingBeginRegex.test(line)) {\n                break;\n              }\n              if (hrRegex.test(line)) {\n                break;\n              }\n\n              itemContents += '\\n' + nextLine;\n            }\n\n            blankLine = !nextLine.trim();\n\n            raw += rawLine + '\\n';\n            src = src.substring(rawLine.length + 1);\n            line = nextLineWithoutTabs.slice(indent);\n          }\n        }\n\n        if (!list.loose) {\n          // If the previous item ended with a blank line, the list is loose\n          if (endsWithBlankLine) {\n            list.loose = true;\n          } else if (this.rules.other.doubleBlankLine.test(raw)) {\n            endsWithBlankLine = true;\n          }\n        }\n\n        list.items.push({\n          type: 'list_item',\n          raw,\n          task: !!this.options.gfm && this.rules.other.listIsTask.test(itemContents),\n          loose: false,\n          text: itemContents,\n          tokens: [],\n        });\n\n        list.raw += raw;\n      }\n\n      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n      const lastItem = list.items.at(-1);\n      if (lastItem) {\n        lastItem.raw = lastItem.raw.trimEnd();\n        lastItem.text = lastItem.text.trimEnd();\n      } else {\n        // not a list since there were no items\n        return;\n      }\n      list.raw = list.raw.trimEnd();\n\n      // Item child tokens handled here at end because we needed to have the final item to trim it first\n      for (const item of list.items) {\n        this.lexer.state.top = false;\n        item.tokens = this.lexer.blockTokens(item.text, []);\n        if (item.task) {\n          // Remove checkbox markdown from item tokens\n          item.text = item.text.replace(this.rules.other.listReplaceTask, '');\n          if (item.tokens[0]?.type === 'text' || item.tokens[0]?.type === 'paragraph') {\n            item.tokens[0].raw = item.tokens[0].raw.replace(this.rules.other.listReplaceTask, '');\n            item.tokens[0].text = item.tokens[0].text.replace(this.rules.other.listReplaceTask, '');\n            for (let i = this.lexer.inlineQueue.length - 1; i >= 0; i--) {\n              if (this.rules.other.listIsTask.test(this.lexer.inlineQueue[i].src)) {\n                this.lexer.inlineQueue[i].src = this.lexer.inlineQueue[i].src.replace(this.rules.other.listReplaceTask, '');\n                break;\n              }\n            }\n          }\n\n          const taskRaw = this.rules.other.listTaskCheckbox.exec(item.raw);\n          if (taskRaw) {\n            const checkboxToken: Tokens.Checkbox = {\n              type: 'checkbox',\n              raw: taskRaw[0] + ' ',\n              checked: taskRaw[0] !== '[ ]',\n            };\n            item.checked = checkboxToken.checked;\n            if (list.loose) {\n              if (item.tokens[0] && ['paragraph', 'text'].includes(item.tokens[0].type) && 'tokens' in item.tokens[0] && item.tokens[0].tokens) {\n                item.tokens[0].raw = checkboxToken.raw + item.tokens[0].raw;\n                item.tokens[0].text = checkboxToken.raw + item.tokens[0].text;\n                item.tokens[0].tokens.unshift(checkboxToken);\n              } else {\n                item.tokens.unshift({\n                  type: 'paragraph',\n                  raw: checkboxToken.raw,\n                  text: checkboxToken.raw,\n                  tokens: [checkboxToken],\n                });\n              }\n            } else {\n              item.tokens.unshift(checkboxToken);\n            }\n          }\n        }\n\n        if (!list.loose) {\n          // Check if list should be loose\n          const spacers = item.tokens.filter(t => t.type === 'space');\n          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));\n\n          list.loose = hasMultipleLineBreaks;\n        }\n      }\n\n      // Set all items to loose if list is loose\n      if (list.loose) {\n        for (const item of list.items) {\n          item.loose = true;\n          for (const token of item.tokens) {\n            if (token.type === 'text') {\n              token.type = 'paragraph';\n            }\n          }\n        }\n      }\n\n      return list;\n    }\n  }\n\n  html(src: string): Tokens.HTML | undefined {\n    const cap = this.rules.block.html.exec(src);\n    if (cap) {\n      const token: Tokens.HTML = {\n        type: 'html',\n        block: true,\n        raw: cap[0],\n        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n        text: cap[0],\n      };\n      return token;\n    }\n  }\n\n  def(src: string): Tokens.Def | undefined {\n    const cap = this.rules.block.def.exec(src);\n    if (cap) {\n      const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');\n      const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n      return {\n        type: 'def',\n        tag,\n        raw: cap[0],\n        href,\n        title,\n      };\n    }\n  }\n\n  table(src: string): Tokens.Table | undefined {\n    const cap = this.rules.block.table.exec(src);\n    if (!cap) {\n      return;\n    }\n\n    if (!this.rules.other.tableDelimiter.test(cap[2])) {\n      // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n      return;\n    }\n\n    const headers = splitCells(cap[1]);\n    const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');\n    const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\\n') : [];\n\n    const item: Tokens.Table = {\n      type: 'table',\n      raw: cap[0],\n      header: [],\n      align: [],\n      rows: [],\n    };\n\n    if (headers.length !== aligns.length) {\n      // header and align columns must be equal, rows can be different.\n      return;\n    }\n\n    for (const align of aligns) {\n      if (this.rules.other.tableAlignRight.test(align)) {\n        item.align.push('right');\n      } else if (this.rules.other.tableAlignCenter.test(align)) {\n        item.align.push('center');\n      } else if (this.rules.other.tableAlignLeft.test(align)) {\n        item.align.push('left');\n      } else {\n        item.align.push(null);\n      }\n    }\n\n    for (let i = 0; i < headers.length; i++) {\n      item.header.push({\n        text: headers[i],\n        tokens: this.lexer.inline(headers[i]),\n        header: true,\n        align: item.align[i],\n      });\n    }\n\n    for (const row of rows) {\n      item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n        return {\n          text: cell,\n          tokens: this.lexer.inline(cell),\n          header: false,\n          align: item.align[i],\n        };\n      }));\n    }\n\n    return item;\n  }\n\n  lheading(src: string): Tokens.Heading | undefined {\n    const cap = this.rules.block.lheading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[2].charAt(0) === '=' ? 1 : 2,\n        text: cap[1],\n        tokens: this.lexer.inline(cap[1]),\n      };\n    }\n  }\n\n  paragraph(src: string): Tokens.Paragraph | undefined {\n    const cap = this.rules.block.paragraph.exec(src);\n    if (cap) {\n      const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n        ? cap[1].slice(0, -1)\n        : cap[1];\n      return {\n        type: 'paragraph',\n        raw: cap[0],\n        text,\n        tokens: this.lexer.inline(text),\n      };\n    }\n  }\n\n  text(src: string): Tokens.Text | undefined {\n    const cap = this.rules.block.text.exec(src);\n    if (cap) {\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        tokens: this.lexer.inline(cap[0]),\n      };\n    }\n  }\n\n  escape(src: string): Tokens.Escape | undefined {\n    const cap = this.rules.inline.escape.exec(src);\n    if (cap) {\n      return {\n        type: 'escape',\n        raw: cap[0],\n        text: cap[1],\n      };\n    }\n  }\n\n  tag(src: string): Tokens.Tag | undefined {\n    const cap = this.rules.inline.tag.exec(src);\n    if (cap) {\n      if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n        this.lexer.state.inLink = true;\n      } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n        this.lexer.state.inLink = false;\n      }\n      if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n        this.lexer.state.inRawBlock = true;\n      } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n        this.lexer.state.inRawBlock = false;\n      }\n\n      return {\n        type: 'html',\n        raw: cap[0],\n        inLink: this.lexer.state.inLink,\n        inRawBlock: this.lexer.state.inRawBlock,\n        block: false,\n        text: cap[0],\n      };\n    }\n  }\n\n  link(src: string): Tokens.Link | Tokens.Image | undefined {\n    const cap = this.rules.inline.link.exec(src);\n    if (cap) {\n      const trimmedUrl = cap[2].trim();\n      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n        // commonmark requires matching angle brackets\n        if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n          return;\n        }\n\n        // ending angle bracket cannot be escaped\n        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n          return;\n        }\n      } else {\n        // find closing parenthesis\n        const lastParenIndex = findClosingBracket(cap[2], '()');\n        if (lastParenIndex === -2) {\n          // more open parens than closed\n          return;\n        }\n\n        if (lastParenIndex > -1) {\n          const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          const linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n      }\n      let href = cap[2];\n      let title = '';\n      if (this.options.pedantic) {\n        // split pedantic href and title\n        const link = this.rules.other.pedanticHrefTitle.exec(href);\n\n        if (link) {\n          href = link[1];\n          title = link[3];\n        }\n      } else {\n        title = cap[3] ? cap[3].slice(1, -1) : '';\n      }\n\n      href = href.trim();\n      if (this.rules.other.startAngleBracket.test(href)) {\n        if (this.options.pedantic && !(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n          // pedantic allows starting angle bracket without ending angle bracket\n          href = href.slice(1);\n        } else {\n          href = href.slice(1, -1);\n        }\n      }\n      return outputLink(cap, {\n        href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n        title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n      }, cap[0], this.lexer, this.rules);\n    }\n  }\n\n  reflink(src: string, links: Links): Tokens.Link | Tokens.Image | Tokens.Text | undefined {\n    let cap;\n    if ((cap = this.rules.inline.reflink.exec(src))\n      || (cap = this.rules.inline.nolink.exec(src))) {\n      const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');\n      const link = links[linkString.toLowerCase()];\n      if (!link) {\n        const text = cap[0].charAt(0);\n        return {\n          type: 'text',\n          raw: text,\n          text,\n        };\n      }\n      return outputLink(cap, link, cap[0], this.lexer, this.rules);\n    }\n  }\n\n  emStrong(src: string, maskedSrc: string, prevChar = ''): Tokens.Em | Tokens.Strong | undefined {\n    let match = this.rules.inline.emStrongLDelim.exec(src);\n    if (!match) return;\n\n    // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n    if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;\n\n    const nextChar = match[1] || match[2] || '';\n\n    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n      // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n      const lLength = [...match[0]].length - 1;\n      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\n      const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n      endReg.lastIndex = 0;\n\n      // Clip maskedSrc to same section of string as src (move to lexer?)\n      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n        if (!rDelim) continue; // skip single * in __abc*abc__\n\n        rLength = [...rDelim].length;\n\n        if (match[3] || match[4]) { // found another Left Delim\n          delimTotal += rLength;\n          continue;\n        } else if (match[5] || match[6]) { // either Left or Right Delim\n          if (lLength % 3 && !((lLength + rLength) % 3)) {\n            midDelimTotal += rLength;\n            continue; // CommonMark Emphasis Rules 9-10\n          }\n        }\n\n        delimTotal -= rLength;\n\n        if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n\n        // Remove extra characters. *a*** -> *a*\n        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n        // char length can be >1 for unicode characters;\n        const lastCharLength = [...match[0]][0].length;\n        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n\n        // Create `em` if smallest delimiter has odd char count. *a***\n        if (Math.min(lLength, rLength) % 2) {\n          const text = raw.slice(1, -1);\n          return {\n            type: 'em',\n            raw,\n            text,\n            tokens: this.lexer.inlineTokens(text),\n          };\n        }\n\n        // Create 'strong' if smallest delimiter has even char count. **a***\n        const text = raw.slice(2, -2);\n        return {\n          type: 'strong',\n          raw,\n          text,\n          tokens: this.lexer.inlineTokens(text),\n        };\n      }\n    }\n  }\n\n  codespan(src: string): Tokens.Codespan | undefined {\n    const cap = this.rules.inline.code.exec(src);\n    if (cap) {\n      let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');\n      const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n      const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n        text = text.substring(1, text.length - 1);\n      }\n      return {\n        type: 'codespan',\n        raw: cap[0],\n        text,\n      };\n    }\n  }\n\n  br(src: string): Tokens.Br | undefined {\n    const cap = this.rules.inline.br.exec(src);\n    if (cap) {\n      return {\n        type: 'br',\n        raw: cap[0],\n      };\n    }\n  }\n\n  del(src: string, maskedSrc: string, prevChar = ''): Tokens.Del | undefined {\n    let match = this.rules.inline.delLDelim.exec(src);\n    if (!match) return;\n\n    const nextChar = match[1] || '';\n\n    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n      // unicode Regex counts emoji as 1 char; spread into array for proper count\n      const lLength = [...match[0]].length - 1;\n      let rDelim, rLength, delimTotal = lLength;\n\n      const endReg = this.rules.inline.delRDelim;\n      endReg.lastIndex = 0;\n\n      // Clip maskedSrc to same section of string as src\n      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n        if (!rDelim) continue;\n\n        rLength = [...rDelim].length;\n\n        if (rLength !== lLength) continue;\n\n        if (match[3] || match[4]) { // found another Left Delim\n          delimTotal += rLength;\n          continue;\n        }\n\n        delimTotal -= rLength;\n\n        if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n\n        // Remove extra characters\n        rLength = Math.min(rLength, rLength + delimTotal);\n        // char length can be >1 for unicode characters\n        const lastCharLength = [...match[0]][0].length;\n        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n\n        // Create del token - only single ~ or double ~~ supported\n        const text = raw.slice(lLength, -lLength);\n        return {\n          type: 'del',\n          raw,\n          text,\n          tokens: this.lexer.inlineTokens(text),\n        };\n      }\n    }\n  }\n\n  autolink(src: string): Tokens.Link | undefined {\n    const cap = this.rules.inline.autolink.exec(src);\n    if (cap) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = cap[1];\n        href = 'mailto:' + text;\n      } else {\n        text = cap[1];\n        href = text;\n      }\n\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text,\n          },\n        ],\n      };\n    }\n  }\n\n  url(src: string): Tokens.Link | undefined {\n    let cap;\n    if (cap = this.rules.inline.url.exec(src)) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = cap[0];\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        let prevCapZero;\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n        } while (prevCapZero !== cap[0]);\n        text = cap[0];\n        if (cap[1] === 'www.') {\n          href = 'http://' + cap[0];\n        } else {\n          href = cap[0];\n        }\n      }\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text,\n          },\n        ],\n      };\n    }\n  }\n\n  inlineText(src: string): Tokens.Text | undefined {\n    const cap = this.rules.inline.text.exec(src);\n    if (cap) {\n      const escaped = this.lexer.state.inRawBlock;\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        escaped,\n      };\n    }\n  }\n}\n","import { _Tokenizer } from './Tokenizer.ts';\nimport { _defaults } from './defaults.ts';\nimport { other, block, inline } from './rules.ts';\nimport type { Token, TokensList, Tokens } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Block Lexer\n */\nexport class _Lexer<ParserOutput = string, RendererOutput = string> {\n  tokens: TokensList;\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  state: {\n    inLink: boolean;\n    inRawBlock: boolean;\n    top: boolean;\n  };\n\n  public inlineQueue: { src: string, tokens: Token[] }[];\n\n  private tokenizer: _Tokenizer<ParserOutput, RendererOutput>;\n\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    // TokenList cannot be created in one go\n    this.tokens = [] as unknown as TokensList;\n    this.tokens.links = Object.create(null);\n    this.options = options || _defaults;\n    this.options.tokenizer = this.options.tokenizer || new _Tokenizer<ParserOutput, RendererOutput>();\n    this.tokenizer = this.options.tokenizer;\n    this.tokenizer.options = this.options;\n    this.tokenizer.lexer = this;\n    this.inlineQueue = [];\n    this.state = {\n      inLink: false,\n      inRawBlock: false,\n      top: true,\n    };\n\n    const rules = {\n      other,\n      block: block.normal,\n      inline: inline.normal,\n    };\n\n    if (this.options.pedantic) {\n      rules.block = block.pedantic;\n      rules.inline = inline.pedantic;\n    } else if (this.options.gfm) {\n      rules.block = block.gfm;\n      if (this.options.breaks) {\n        rules.inline = inline.breaks;\n      } else {\n        rules.inline = inline.gfm;\n      }\n    }\n    this.tokenizer.rules = rules;\n  }\n\n  /**\n   * Expose Rules\n   */\n  static get rules() {\n    return {\n      block,\n      inline,\n    };\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex<ParserOutput = string, RendererOutput = string>(src: string, options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const lexer = new _Lexer<ParserOutput, RendererOutput>(options);\n    return lexer.lex(src);\n  }\n\n  /**\n   * Static Lex Inline Method\n   */\n  static lexInline<ParserOutput = string, RendererOutput = string>(src: string, options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const lexer = new _Lexer<ParserOutput, RendererOutput>(options);\n    return lexer.inlineTokens(src);\n  }\n\n  /**\n   * Preprocessing\n   */\n  lex(src: string) {\n    src = src.replace(other.carriageReturn, '\\n');\n\n    this.blockTokens(src, this.tokens);\n\n    for (let i = 0; i < this.inlineQueue.length; i++) {\n      const next = this.inlineQueue[i];\n      this.inlineTokens(next.src, next.tokens);\n    }\n    this.inlineQueue = [];\n\n    return this.tokens;\n  }\n\n  /**\n   * Lexing\n   */\n  blockTokens(src: string, tokens?: Token[], lastParagraphClipped?: boolean): Token[];\n  blockTokens(src: string, tokens?: TokensList, lastParagraphClipped?: boolean): TokensList;\n  blockTokens(src: string, tokens: Token[] = [], lastParagraphClipped = false) {\n    if (this.options.pedantic) {\n      src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');\n    }\n\n    while (src) {\n      let token: Tokens.Generic | undefined;\n\n      if (this.options.extensions?.block?.some((extTokenizer) => {\n        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          return true;\n        }\n        return false;\n      })) {\n        continue;\n      }\n\n      // newline\n      if (token = this.tokenizer.space(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (token.raw.length === 1 && lastToken !== undefined) {\n          // if there's a single \\n as a spacer, it's terminating the last line,\n          // so move it there so that we don't get unnecessary paragraph tags\n          lastToken.raw += '\\n';\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.code(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // fences\n      if (token = this.tokenizer.fences(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // heading\n      if (token = this.tokenizer.heading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // hr\n      if (token = this.tokenizer.hr(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // blockquote\n      if (token = this.tokenizer.blockquote(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // list\n      if (token = this.tokenizer.list(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // html\n      if (token = this.tokenizer.html(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // def\n      if (token = this.tokenizer.def(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.raw;\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else if (!this.tokens.links[token.tag]) {\n          this.tokens.links[token.tag] = {\n            href: token.href,\n            title: token.title,\n          };\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (token = this.tokenizer.table(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // lheading\n      if (token = this.tokenizer.lheading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // top-level paragraph\n      // prevent paragraph consuming extensions by clipping 'src' to extension start\n      let cutSrc = src;\n      if (this.options.extensions?.startBlock) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startBlock.forEach((getStartIndex) => {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) {\n            startIndex = Math.min(startIndex, tempStart);\n          }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n        const lastToken = tokens.at(-1);\n        if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        lastParagraphClipped = cutSrc.length !== src.length;\n        src = src.substring(token.raw.length);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.text(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'text') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    this.state.top = true;\n    return tokens;\n  }\n\n  inline(src: string, tokens: Token[] = []) {\n    this.inlineQueue.push({ src, tokens });\n    return tokens;\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  inlineTokens(src: string, tokens: Token[] = []): Token[] {\n    // String with links masked to avoid interference with em and strong\n    let maskedSrc = src;\n    let match: RegExpExecArray | null = null;\n\n    // Mask out reflinks\n    if (this.tokens.links) {\n      const links = Object.keys(this.tokens.links);\n      if (links.length > 0) {\n        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n            maskedSrc = maskedSrc.slice(0, match.index)\n              + '[' + 'a'.repeat(match[0].length - 2) + ']'\n              + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n          }\n        }\n      }\n    }\n\n    // Mask out escaped characters\n    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n    }\n\n    // Mask out other blocks\n    let offset;\n    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n      offset = match[2] ? match[2].length : 0;\n      maskedSrc = maskedSrc.slice(0, match.index + offset) + '[' + 'a'.repeat(match[0].length - offset - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n    }\n\n    // Mask out blocks from extensions\n    maskedSrc = this.options.hooks?.emStrongMask?.call({ lexer: this }, maskedSrc) ?? maskedSrc;\n\n    let keepPrevChar = false;\n    let prevChar = '';\n    while (src) {\n      if (!keepPrevChar) {\n        prevChar = '';\n      }\n      keepPrevChar = false;\n\n      let token: Tokens.Generic | undefined;\n\n      // extensions\n      if (this.options.extensions?.inline?.some((extTokenizer) => {\n        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          return true;\n        }\n        return false;\n      })) {\n        continue;\n      }\n\n      // escape\n      if (token = this.tokenizer.escape(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // tag\n      if (token = this.tokenizer.tag(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // link\n      if (token = this.tokenizer.link(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // reflink, nolink\n      if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (token.type === 'text' && lastToken?.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // em & strong\n      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.codespan(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // br\n      if (token = this.tokenizer.br(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // del (gfm)\n      if (token = this.tokenizer.del(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // autolink\n      if (token = this.tokenizer.autolink(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      // prevent inlineText consuming extensions by clipping 'src' to extension start\n      let cutSrc = src;\n      if (this.options.extensions?.startInline) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startInline.forEach((getStartIndex) => {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) {\n            startIndex = Math.min(startIndex, tempStart);\n          }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (token = this.tokenizer.inlineText(cutSrc)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n          prevChar = token.raw.slice(-1);\n        }\n        keepPrevChar = true;\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n}\n","import { _defaults } from './defaults.ts';\nimport {\n  cleanUrl,\n  escape,\n} from './helpers.ts';\nimport { other } from './rules.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\nimport type { Tokens } from './Tokens.ts';\nimport type { _Parser } from './Parser.ts';\n\n/**\n * Renderer\n */\nexport class _Renderer<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  parser!: _Parser<ParserOutput, RendererOutput>; // set by the parser\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n  }\n\n  space(token: Tokens.Space): RendererOutput {\n    return '' as RendererOutput;\n  }\n\n  code({ text, lang, escaped }: Tokens.Code): RendererOutput {\n    const langString = (lang || '').match(other.notSpaceStart)?.[0];\n\n    const code = text.replace(other.endingNewline, '') + '\\n';\n\n    if (!langString) {\n      return '<pre><code>'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>\\n' as RendererOutput;\n    }\n\n    return '<pre><code class=\"language-'\n      + escape(langString)\n      + '\">'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>\\n' as RendererOutput;\n  }\n\n  blockquote({ tokens }: Tokens.Blockquote): RendererOutput {\n    const body = this.parser.parse(tokens);\n    return `<blockquote>\\n${body}</blockquote>\\n` as RendererOutput;\n  }\n\n  html({ text }: Tokens.HTML | Tokens.Tag): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  def(token: Tokens.Def): RendererOutput {\n    return '' as RendererOutput;\n  }\n\n  heading({ tokens, depth }: Tokens.Heading): RendererOutput {\n    return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n` as RendererOutput;\n  }\n\n  hr(token: Tokens.Hr): RendererOutput {\n    return '<hr>\\n' as RendererOutput;\n  }\n\n  list(token: Tokens.List): RendererOutput {\n    const ordered = token.ordered;\n    const start = token.start;\n\n    let body = '';\n    for (let j = 0; j < token.items.length; j++) {\n      const item = token.items[j];\n      body += this.listitem(item);\n    }\n\n    const type = ordered ? 'ol' : 'ul';\n    const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n    return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n' as RendererOutput;\n  }\n\n  listitem(item: Tokens.ListItem): RendererOutput {\n    return `<li>${this.parser.parse(item.tokens)}</li>\\n` as RendererOutput;\n  }\n\n  checkbox({ checked }: Tokens.Checkbox): RendererOutput {\n    return '<input '\n      + (checked ? 'checked=\"\" ' : '')\n      + 'disabled=\"\" type=\"checkbox\"> ' as RendererOutput;\n  }\n\n  paragraph({ tokens }: Tokens.Paragraph): RendererOutput {\n    return `<p>${this.parser.parseInline(tokens)}</p>\\n` as RendererOutput;\n  }\n\n  table(token: Tokens.Table): RendererOutput {\n    let header = '';\n\n    // header\n    let cell = '';\n    for (let j = 0; j < token.header.length; j++) {\n      cell += this.tablecell(token.header[j]);\n    }\n    header += this.tablerow({ text: cell as ParserOutput });\n\n    let body = '';\n    for (let j = 0; j < token.rows.length; j++) {\n      const row = token.rows[j];\n\n      cell = '';\n      for (let k = 0; k < row.length; k++) {\n        cell += this.tablecell(row[k]);\n      }\n\n      body += this.tablerow({ text: cell as ParserOutput });\n    }\n    if (body) body = `<tbody>${body}</tbody>`;\n\n    return '<table>\\n'\n      + '<thead>\\n'\n      + header\n      + '</thead>\\n'\n      + body\n      + '</table>\\n' as RendererOutput;\n  }\n\n  tablerow({ text }: Tokens.TableRow<ParserOutput>): RendererOutput {\n    return `<tr>\\n${text}</tr>\\n` as RendererOutput;\n  }\n\n  tablecell(token: Tokens.TableCell): RendererOutput {\n    const content = this.parser.parseInline(token.tokens);\n    const type = token.header ? 'th' : 'td';\n    const tag = token.align\n      ? `<${type} align=\"${token.align}\">`\n      : `<${type}>`;\n    return tag + content + `</${type}>\\n` as RendererOutput;\n  }\n\n  /**\n   * span level renderer\n   */\n  strong({ tokens }: Tokens.Strong): RendererOutput {\n    return `<strong>${this.parser.parseInline(tokens)}</strong>` as RendererOutput;\n  }\n\n  em({ tokens }: Tokens.Em): RendererOutput {\n    return `<em>${this.parser.parseInline(tokens)}</em>` as RendererOutput;\n  }\n\n  codespan({ text }: Tokens.Codespan): RendererOutput {\n    return `<code>${escape(text, true)}</code>` as RendererOutput;\n  }\n\n  br(token: Tokens.Br): RendererOutput {\n    return '<br>' as RendererOutput;\n  }\n\n  del({ tokens }: Tokens.Del): RendererOutput {\n    return `<del>${this.parser.parseInline(tokens)}</del>` as RendererOutput;\n  }\n\n  link({ href, title, tokens }: Tokens.Link): RendererOutput {\n    const text = this.parser.parseInline(tokens) as string;\n    const cleanHref = cleanUrl(href);\n    if (cleanHref === null) {\n      return text as RendererOutput;\n    }\n    href = cleanHref;\n    let out = '<a href=\"' + href + '\"';\n    if (title) {\n      out += ' title=\"' + (escape(title)) + '\"';\n    }\n    out += '>' + text + '</a>';\n    return out as RendererOutput;\n  }\n\n  image({ href, title, text, tokens }: Tokens.Image): RendererOutput {\n    if (tokens) {\n      text = this.parser.parseInline(tokens, this.parser.textRenderer) as string;\n    }\n    const cleanHref = cleanUrl(href);\n    if (cleanHref === null) {\n      return escape(text) as RendererOutput;\n    }\n    href = cleanHref;\n\n    let out = `<img src=\"${href}\" alt=\"${text}\"`;\n    if (title) {\n      out += ` title=\"${escape(title)}\"`;\n    }\n    out += '>';\n    return out as RendererOutput;\n  }\n\n  text(token: Tokens.Text | Tokens.Escape): RendererOutput {\n    return 'tokens' in token && token.tokens\n      ? this.parser.parseInline(token.tokens) as unknown as RendererOutput\n      : ('escaped' in token && token.escaped ? token.text as RendererOutput : escape(token.text) as RendererOutput);\n  }\n}\n","import type { Tokens } from './Tokens.ts';\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nexport class _TextRenderer<RendererOutput = string> {\n  // no need for block level renderers\n  strong({ text }: Tokens.Strong): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  em({ text }: Tokens.Em): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  codespan({ text }: Tokens.Codespan): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  del({ text }: Tokens.Del): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  html({ text }: Tokens.HTML | Tokens.Tag): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  text({ text }: Tokens.Text | Tokens.Escape | Tokens.Tag): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  link({ text }: Tokens.Link): RendererOutput {\n    return '' + text as RendererOutput;\n  }\n\n  image({ text }: Tokens.Image): RendererOutput {\n    return '' + text as RendererOutput;\n  }\n\n  br(): RendererOutput {\n    return '' as RendererOutput;\n  }\n\n  checkbox({ raw }: Tokens.Checkbox): RendererOutput {\n    return raw as RendererOutput;\n  }\n}\n","import { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _defaults } from './defaults.ts';\nimport type { MarkedToken, Token, Tokens } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Parsing & Compiling\n */\nexport class _Parser<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  renderer: _Renderer<ParserOutput, RendererOutput>;\n  textRenderer: _TextRenderer<RendererOutput>;\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n    this.options.renderer = this.options.renderer || new _Renderer<ParserOutput, RendererOutput>();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.renderer.parser = this;\n    this.textRenderer = new _TextRenderer<RendererOutput>();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse<ParserOutput = string, RendererOutput = string>(tokens: Token[], options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const parser = new _Parser<ParserOutput, RendererOutput>(options);\n    return parser.parse(tokens);\n  }\n\n  /**\n   * Static Parse Inline Method\n   */\n  static parseInline<ParserOutput = string, RendererOutput = string>(tokens: Token[], options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const parser = new _Parser<ParserOutput, RendererOutput>(options);\n    return parser.parseInline(tokens);\n  }\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens: Token[]): ParserOutput {\n    let out = '';\n\n    for (let i = 0; i < tokens.length; i++) {\n      const anyToken = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions?.renderers?.[anyToken.type]) {\n        const genericToken = anyToken as Tokens.Generic;\n        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'def', 'paragraph', 'text'].includes(genericToken.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      const token = anyToken as MarkedToken;\n\n      switch (token.type) {\n        case 'space': {\n          out += this.renderer.space(token);\n          break;\n        }\n        case 'hr': {\n          out += this.renderer.hr(token);\n          break;\n        }\n        case 'heading': {\n          out += this.renderer.heading(token);\n          break;\n        }\n        case 'code': {\n          out += this.renderer.code(token);\n          break;\n        }\n        case 'table': {\n          out += this.renderer.table(token);\n          break;\n        }\n        case 'blockquote': {\n          out += this.renderer.blockquote(token);\n          break;\n        }\n        case 'list': {\n          out += this.renderer.list(token);\n          break;\n        }\n        case 'checkbox': {\n          out += this.renderer.checkbox(token);\n          break;\n        }\n        case 'html': {\n          out += this.renderer.html(token);\n          break;\n        }\n        case 'def': {\n          out += this.renderer.def(token);\n          break;\n        }\n        case 'paragraph': {\n          out += this.renderer.paragraph(token);\n          break;\n        }\n        case 'text': {\n          out += this.renderer.text(token);\n          break;\n        }\n\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return '' as ParserOutput;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n\n    return out as ParserOutput;\n  }\n\n  /**\n   * Parse Inline Tokens\n   */\n  parseInline(tokens: Token[], renderer: _Renderer<ParserOutput, RendererOutput> | _TextRenderer<RendererOutput> = this.renderer): ParserOutput {\n    let out = '';\n\n    for (let i = 0; i < tokens.length; i++) {\n      const anyToken = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions?.renderers?.[anyToken.type]) {\n        const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      const token = anyToken as MarkedToken;\n\n      switch (token.type) {\n        case 'escape': {\n          out += renderer.text(token);\n          break;\n        }\n        case 'html': {\n          out += renderer.html(token);\n          break;\n        }\n        case 'link': {\n          out += renderer.link(token);\n          break;\n        }\n        case 'image': {\n          out += renderer.image(token);\n          break;\n        }\n        case 'checkbox': {\n          out += renderer.checkbox(token);\n          break;\n        }\n        case 'strong': {\n          out += renderer.strong(token);\n          break;\n        }\n        case 'em': {\n          out += renderer.em(token);\n          break;\n        }\n        case 'codespan': {\n          out += renderer.codespan(token);\n          break;\n        }\n        case 'br': {\n          out += renderer.br(token);\n          break;\n        }\n        case 'del': {\n          out += renderer.del(token);\n          break;\n        }\n        case 'text': {\n          out += renderer.text(token);\n          break;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return '' as ParserOutput;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n    return out as ParserOutput;\n  }\n}\n","import { _defaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, TokensList } from './Tokens.ts';\n\nexport class _Hooks<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  block?: boolean;\n\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n  }\n\n  static passThroughHooks = new Set([\n    'preprocess',\n    'postprocess',\n    'processAllTokens',\n    'emStrongMask',\n  ]);\n\n  static passThroughHooksRespectAsync = new Set([\n    'preprocess',\n    'postprocess',\n    'processAllTokens',\n  ]);\n\n  /**\n   * Process markdown before marked\n   */\n  preprocess(markdown: string) {\n    return markdown;\n  }\n\n  /**\n   * Process HTML after marked is finished\n   */\n  postprocess(html: ParserOutput) {\n    return html;\n  }\n\n  /**\n   * Process all tokens before walk tokens\n   */\n  processAllTokens(tokens: Token[] | TokensList) {\n    return tokens;\n  }\n\n  /**\n   * Mask contents that should not be interpreted as em/strong delimiters\n   */\n  emStrongMask(src: string) {\n    return src;\n  }\n\n  /**\n   * Provide function to tokenize markdown\n   */\n  provideLexer() {\n    return this.block ? _Lexer.lex : _Lexer.lexInline;\n  }\n\n  /**\n   * Provide function to parse tokens\n   */\n  provideParser() {\n    return this.block ? _Parser.parse<ParserOutput, RendererOutput> : _Parser.parseInline<ParserOutput, RendererOutput>;\n  }\n}\n","import { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { Marked } from './Instance.ts';\nimport {\n  _getDefaults,\n  changeDefaults,\n  _defaults,\n} from './defaults.ts';\nimport type { MarkedExtension, MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, TokensList } from './Tokens.ts';\nimport type { MaybePromise } from './Instance.ts';\n\nconst markedInstance = new Marked();\n\n/**\n * Compiles markdown to HTML asynchronously.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options, having async: true\n * @return Promise of string of compiled HTML\n */\nexport function marked(src: string, options: MarkedOptions & { async: true }): Promise<string>;\n\n/**\n * Compiles markdown to HTML.\n *\n * @param src String of markdown source to be compiled\n * @param options Optional hash of options\n * @return String of compiled HTML. Will be a Promise of string if async is set to true by any extensions.\n */\nexport function marked(src: string, options: MarkedOptions & { async: false }): string;\nexport function marked(src: string, options: MarkedOptions & { async: true }): Promise<string>;\nexport function marked(src: string, options?: MarkedOptions | null): string | Promise<string>;\nexport function marked(src: string, opt?: MarkedOptions | null): string | Promise<string> {\n  return markedInstance.parse(src, opt);\n}\n\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n  marked.setOptions = function(options: MarkedOptions) {\n    markedInstance.setOptions(options);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n  };\n\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\n\nmarked.defaults = _defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function(...args: MarkedExtension[]) {\n  markedInstance.use(...args);\n  marked.defaults = markedInstance.defaults;\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n  return markedInstance.walkTokens(tokens, callback);\n};\n\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\n\nexport const options = marked.options;\nexport const setOptions = marked.setOptions;\nexport const use = marked.use;\nexport const walkTokens = marked.walkTokens;\nexport const parseInline = marked.parseInline;\nexport const parse = marked;\nexport const parser = _Parser.parse;\nexport const lexer = _Lexer.lex;\nexport { _defaults as defaults, _getDefaults as getDefaults } from './defaults.ts';\nexport { _Lexer as Lexer } from './Lexer.ts';\nexport { _Parser as Parser } from './Parser.ts';\nexport { _Tokenizer as Tokenizer } from './Tokenizer.ts';\nexport { _Renderer as Renderer } from './Renderer.ts';\nexport { _TextRenderer as TextRenderer } from './TextRenderer.ts';\nexport { _Hooks as Hooks } from './Hooks.ts';\nexport { Marked } from './Instance.ts';\nexport type * from './MarkedOptions.ts';\nexport type * from './Tokens.ts';\n","import { _getDefaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { escape } from './helpers.ts';\nimport type { MarkedExtension, MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, Tokens, TokensList } from './Tokens.ts';\n\nexport type MaybePromise = void | Promise<void>;\n\ntype UnknownFunction = (...args: unknown[]) => unknown;\ntype GenericRendererFunction = (...args: unknown[]) => string | false;\n\nexport class Marked<ParserOutput = string, RendererOutput = string> {\n  defaults = _getDefaults<ParserOutput, RendererOutput>();\n  options = this.setOptions;\n\n  parse = this.parseMarkdown(true);\n  parseInline = this.parseMarkdown(false);\n\n  Parser = _Parser<ParserOutput, RendererOutput>;\n  Renderer = _Renderer<ParserOutput, RendererOutput>;\n  TextRenderer = _TextRenderer<RendererOutput>;\n  Lexer = _Lexer;\n  Tokenizer = _Tokenizer<ParserOutput, RendererOutput>;\n  Hooks = _Hooks<ParserOutput, RendererOutput>;\n\n  constructor(...args: MarkedExtension<ParserOutput, RendererOutput>[]) {\n    this.use(...args);\n  }\n\n  /**\n   * Run callback for every token\n   */\n  walkTokens(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n    let values: MaybePromise[] = [];\n    for (const token of tokens) {\n      values = values.concat(callback.call(this, token));\n      switch (token.type) {\n        case 'table': {\n          const tableToken = token as Tokens.Table;\n          for (const cell of tableToken.header) {\n            values = values.concat(this.walkTokens(cell.tokens, callback));\n          }\n          for (const row of tableToken.rows) {\n            for (const cell of row) {\n              values = values.concat(this.walkTokens(cell.tokens, callback));\n            }\n          }\n          break;\n        }\n        case 'list': {\n          const listToken = token as Tokens.List;\n          values = values.concat(this.walkTokens(listToken.items, callback));\n          break;\n        }\n        default: {\n          const genericToken = token as Tokens.Generic;\n          if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n              const tokens = genericToken[childTokens].flat(Infinity) as Token[] | TokensList;\n              values = values.concat(this.walkTokens(tokens, callback));\n            });\n          } else if (genericToken.tokens) {\n            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n          }\n        }\n      }\n    }\n    return values;\n  }\n\n  use(...args: MarkedExtension<ParserOutput, RendererOutput>[]) {\n    const extensions: MarkedOptions<ParserOutput, RendererOutput>['extensions'] = this.defaults.extensions || { renderers: {}, childTokens: {} };\n\n    args.forEach((pack) => {\n      // copy options to new object\n      const opts = { ...pack } as MarkedOptions<ParserOutput, RendererOutput>;\n\n      // set async to true if it was set to true before\n      opts.async = this.defaults.async || opts.async || false;\n\n      // ==-- Parse \"addon\" extensions --== //\n      if (pack.extensions) {\n        pack.extensions.forEach((ext) => {\n          if (!ext.name) {\n            throw new Error('extension name required');\n          }\n          if ('renderer' in ext) { // Renderer extensions\n            const prevRenderer = extensions.renderers[ext.name];\n            if (prevRenderer) {\n              // Replace extension with func to run new extension but fall back if false\n              extensions.renderers[ext.name] = function(...args) {\n                let ret = ext.renderer.apply(this, args);\n                if (ret === false) {\n                  ret = prevRenderer.apply(this, args);\n                }\n                return ret;\n              };\n            } else {\n              extensions.renderers[ext.name] = ext.renderer;\n            }\n          }\n          if ('tokenizer' in ext) { // Tokenizer Extensions\n            if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n              throw new Error(\"extension level must be 'block' or 'inline'\");\n            }\n            const extLevel = extensions[ext.level];\n            if (extLevel) {\n              extLevel.unshift(ext.tokenizer);\n            } else {\n              extensions[ext.level] = [ext.tokenizer];\n            }\n            if (ext.start) { // Function to check for start of token\n              if (ext.level === 'block') {\n                if (extensions.startBlock) {\n                  extensions.startBlock.push(ext.start);\n                } else {\n                  extensions.startBlock = [ext.start];\n                }\n              } else if (ext.level === 'inline') {\n                if (extensions.startInline) {\n                  extensions.startInline.push(ext.start);\n                } else {\n                  extensions.startInline = [ext.start];\n                }\n              }\n            }\n          }\n          if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n            extensions.childTokens[ext.name] = ext.childTokens;\n          }\n        });\n        opts.extensions = extensions;\n      }\n\n      // ==-- Parse \"overwrite\" extensions --== //\n      if (pack.renderer) {\n        const renderer = this.defaults.renderer || new _Renderer<ParserOutput, RendererOutput>(this.defaults);\n        for (const prop in pack.renderer) {\n          if (!(prop in renderer)) {\n            throw new Error(`renderer '${prop}' does not exist`);\n          }\n          if (['options', 'parser'].includes(prop)) {\n            // ignore options property\n            continue;\n          }\n          const rendererProp = prop as Exclude<keyof _Renderer<ParserOutput, RendererOutput>, 'options' | 'parser'>;\n          const rendererFunc = pack.renderer[rendererProp] as GenericRendererFunction;\n          const prevRenderer = renderer[rendererProp] as GenericRendererFunction;\n          // Replace renderer with func to run extension, but fall back if false\n          renderer[rendererProp] = (...args: unknown[]) => {\n            let ret = rendererFunc.apply(renderer, args);\n            if (ret === false) {\n              ret = prevRenderer.apply(renderer, args);\n            }\n            return (ret || '') as RendererOutput;\n          };\n        }\n        opts.renderer = renderer;\n      }\n      if (pack.tokenizer) {\n        const tokenizer = this.defaults.tokenizer || new _Tokenizer<ParserOutput, RendererOutput>(this.defaults);\n        for (const prop in pack.tokenizer) {\n          if (!(prop in tokenizer)) {\n            throw new Error(`tokenizer '${prop}' does not exist`);\n          }\n          if (['options', 'rules', 'lexer'].includes(prop)) {\n            // ignore options, rules, and lexer properties\n            continue;\n          }\n          const tokenizerProp = prop as Exclude<keyof _Tokenizer<ParserOutput, RendererOutput>, 'options' | 'rules' | 'lexer'>;\n          const tokenizerFunc = pack.tokenizer[tokenizerProp] as UnknownFunction;\n          const prevTokenizer = tokenizer[tokenizerProp] as UnknownFunction;\n          // Replace tokenizer with func to run extension, but fall back if false\n          // @ts-expect-error cannot type tokenizer function dynamically\n          tokenizer[tokenizerProp] = (...args: unknown[]) => {\n            let ret = tokenizerFunc.apply(tokenizer, args);\n            if (ret === false) {\n              ret = prevTokenizer.apply(tokenizer, args);\n            }\n            return ret;\n          };\n        }\n        opts.tokenizer = tokenizer;\n      }\n\n      // ==-- Parse Hooks extensions --== //\n      if (pack.hooks) {\n        const hooks = this.defaults.hooks || new _Hooks<ParserOutput, RendererOutput>();\n        for (const prop in pack.hooks) {\n          if (!(prop in hooks)) {\n            throw new Error(`hook '${prop}' does not exist`);\n          }\n          if (['options', 'block'].includes(prop)) {\n            // ignore options and block properties\n            continue;\n          }\n          const hooksProp = prop as Exclude<keyof _Hooks<ParserOutput, RendererOutput>, 'options' | 'block'>;\n          const hooksFunc = pack.hooks[hooksProp] as UnknownFunction;\n          const prevHook = hooks[hooksProp] as UnknownFunction;\n          if (_Hooks.passThroughHooks.has(prop)) {\n            // @ts-expect-error cannot type hook function dynamically\n            hooks[hooksProp] = (arg: unknown) => {\n              if (this.defaults.async && _Hooks.passThroughHooksRespectAsync.has(prop)) {\n                return (async() => {\n                  const ret = await hooksFunc.call(hooks, arg);\n                  return prevHook.call(hooks, ret);\n                })();\n              }\n\n              const ret = hooksFunc.call(hooks, arg);\n              return prevHook.call(hooks, ret);\n            };\n          } else {\n            // @ts-expect-error cannot type hook function dynamically\n            hooks[hooksProp] = (...args: unknown[]) => {\n              if (this.defaults.async) {\n                return (async() => {\n                  let ret = await hooksFunc.apply(hooks, args);\n                  if (ret === false) {\n                    ret = await prevHook.apply(hooks, args);\n                  }\n                  return ret;\n                })();\n              }\n\n              let ret = hooksFunc.apply(hooks, args);\n              if (ret === false) {\n                ret = prevHook.apply(hooks, args);\n              }\n              return ret;\n            };\n          }\n        }\n        opts.hooks = hooks;\n      }\n\n      // ==-- Parse WalkTokens extensions --== //\n      if (pack.walkTokens) {\n        const walkTokens = this.defaults.walkTokens;\n        const packWalktokens = pack.walkTokens;\n        opts.walkTokens = function(token) {\n          let values: MaybePromise[] = [];\n          values.push(packWalktokens.call(this, token));\n          if (walkTokens) {\n            values = values.concat(walkTokens.call(this, token));\n          }\n          return values;\n        };\n      }\n\n      this.defaults = { ...this.defaults, ...opts };\n    });\n\n    return this;\n  }\n\n  setOptions(opt: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.defaults = { ...this.defaults, ...opt };\n    return this;\n  }\n\n  lexer(src: string, options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    return _Lexer.lex(src, options ?? this.defaults);\n  }\n\n  parser(tokens: Token[], options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    return _Parser.parse<ParserOutput, RendererOutput>(tokens, options ?? this.defaults);\n  }\n\n  private parseMarkdown(blockType: boolean) {\n    type overloadedParse = {\n      (src: string, options: MarkedOptions<ParserOutput, RendererOutput> & { async: true }): Promise<ParserOutput>;\n      (src: string, options: MarkedOptions<ParserOutput, RendererOutput> & { async: false }): ParserOutput;\n      (src: string, options?: MarkedOptions<ParserOutput, RendererOutput> | null): ParserOutput | Promise<ParserOutput>;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const parse: overloadedParse = (src: string, options?: MarkedOptions<ParserOutput, RendererOutput> | null): any => {\n      const origOpt = { ...options };\n      const opt = { ...this.defaults, ...origOpt };\n\n      const throwError = this.onError(!!opt.silent, !!opt.async);\n\n      // throw error if an extension set async to true but parse was called with async: false\n      if (this.defaults.async === true && origOpt.async === false) {\n        return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n      }\n\n      // throw error in case of non string input\n      if (typeof src === 'undefined' || src === null) {\n        return throwError(new Error('marked(): input parameter is undefined or null'));\n      }\n      if (typeof src !== 'string') {\n        return throwError(new Error('marked(): input parameter is of type '\n          + Object.prototype.toString.call(src) + ', string expected'));\n      }\n\n      if (opt.hooks) {\n        opt.hooks.options = opt;\n        opt.hooks.block = blockType;\n      }\n\n      if (opt.async) {\n        return (async() => {\n          const processedSrc = opt.hooks ? await opt.hooks.preprocess(src) : src;\n          const lexer = opt.hooks ? await opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n          const tokens = await lexer(processedSrc, opt);\n          const processedTokens = opt.hooks ? await opt.hooks.processAllTokens(tokens) : tokens;\n          if (opt.walkTokens) {\n            await Promise.all(this.walkTokens(processedTokens, opt.walkTokens));\n          }\n          const parser = opt.hooks ? await opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n          const html = await parser(processedTokens, opt);\n          return opt.hooks ? await opt.hooks.postprocess(html) : html;\n        })().catch(throwError);\n      }\n\n      try {\n        if (opt.hooks) {\n          src = opt.hooks.preprocess(src) as string;\n        }\n        const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n        let tokens = lexer(src, opt);\n        if (opt.hooks) {\n          tokens = opt.hooks.processAllTokens(tokens);\n        }\n        if (opt.walkTokens) {\n          this.walkTokens(tokens, opt.walkTokens);\n        }\n        const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n        let html = parser(tokens, opt);\n        if (opt.hooks) {\n          html = opt.hooks.postprocess(html);\n        }\n        return html;\n      } catch(e) {\n        return throwError(e as Error);\n      }\n    };\n\n    return parse;\n  }\n\n  private onError(silent: boolean, async: boolean) {\n    return (e: Error): string | Promise<string> => {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (silent) {\n        const msg = '<p>An error occurred:</p><pre>'\n          + escape(e.message + '', true)\n          + '</pre>';\n        if (async) {\n          return Promise.resolve(msg);\n        }\n        return msg;\n      }\n\n      if (async) {\n        return Promise.reject(e);\n      }\n      throw e;\n    };\n  }\n}\n","/*\n * Copyright (C) 2025 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport emojiRegex from \"emoji-regex\";\nimport { marked } from \"marked\";\n\nconst regex = emojiRegex();\n\nexport function renderEmojis(content) {\n  const newContent = content.replace(regex, (match) => {\n      let hexCode = \"\";\n      for (const codePoint of match) {\n          hexCode += codePoint.codePointAt(0).toString(16) + \"-\";\n      }\n      hexCode = hexCode.slice(0, -1);\n      return `<img class=\"emoji\" alt=\"${match}\" src=\"img/emoji/${hexCode}.png\" />`;\n  });\n  return newContent;\n}\n\nexport function render(content) {\n    const html = marked.parse(content);\n    return renderEmojis(html);\n}\n","export default () => {\n\t// https://mths.be/emoji\n\treturn /[#*0-9]\\uFE0F?\\u20E3|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26AA\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C8\\u26CF\\u26D1\\u26E9\\u26F0-\\u26F5\\u26F7\\u26F8\\u26FA\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2757\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B55\\u3030\\u303D\\u3297\\u3299]\\uFE0F?|[\\u261D\\u270C\\u270D](?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?|[\\u270A\\u270B](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u2693\\u26A1\\u26AB\\u26C5\\u26CE\\u26D4\\u26EA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2795-\\u2797\\u27B0\\u27BF\\u2B50]|\\u26D3\\uFE0F?(?:\\u200D\\uD83D\\uDCA5)?|\\u26F9(?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\u2764\\uFE0F?(?:\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79))?|\\uD83C(?:[\\uDC04\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]\\uFE0F?|[\\uDF85\\uDFC2\\uDFC7](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDFC4\\uDFCA](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDFCB\\uDFCC](?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF43\\uDF45-\\uDF4A\\uDF4C-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uDDE6\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF]|\\uDDE7\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF]|\\uDDE8\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF7\\uDDFA-\\uDDFF]|\\uDDE9\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF]|\\uDDEA\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA]|\\uDDEB\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7]|\\uDDEC\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE]|\\uDDED\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA]|\\uDDEE\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9]|\\uDDEF\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5]|\\uDDF0\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF]|\\uDDF1\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE]|\\uDDF2\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF]|\\uDDF3\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF]|\\uDDF4\\uD83C\\uDDF2|\\uDDF5\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE]|\\uDDF6\\uD83C\\uDDE6|\\uDDF7\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC]|\\uDDF8\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF]|\\uDDF9\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF]|\\uDDFA\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF]|\\uDDFB\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA]|\\uDDFC\\uD83C[\\uDDEB\\uDDF8]|\\uDDFD\\uD83C\\uDDF0|\\uDDFE\\uD83C[\\uDDEA\\uDDF9]|\\uDDFF\\uD83C[\\uDDE6\\uDDF2\\uDDFC]|\\uDF44(?:\\u200D\\uD83D\\uDFEB)?|\\uDF4B(?:\\u200D\\uD83D\\uDFE9)?|\\uDFC3(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?|\\uDFF3\\uFE0F?(?:\\u200D(?:\\u26A7\\uFE0F?|\\uD83C\\uDF08))?|\\uDFF4(?:\\u200D\\u2620\\uFE0F?|\\uDB40\\uDC67\\uDB40\\uDC62\\uDB40(?:\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F)?)|\\uD83D(?:[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3]\\uFE0F?|[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC6E-\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4\\uDEB5](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD74\\uDD90](?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?|[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC25\\uDC27-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE41\\uDE43\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED8\\uDEDC-\\uDEDF\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB\\uDFF0]|\\uDC08(?:\\u200D\\u2B1B)?|\\uDC15(?:\\u200D\\uD83E\\uDDBA)?|\\uDC26(?:\\u200D(?:\\u2B1B|\\uD83D\\uDD25))?|\\uDC3B(?:\\u200D\\u2744\\uFE0F?)?|\\uDC41\\uFE0F?(?:\\u200D\\uD83D\\uDDE8\\uFE0F?)?|\\uDC68(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDC68\\uDC69]\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFC-\\uDFFF])|\\uD83E(?:[\\uDD1D\\uDEEF]\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFC-\\uDFFF]|[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83E(?:[\\uDD1D\\uDEEF]\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFD-\\uDFFF]|[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83E(?:[\\uDD1D\\uDEEF]\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF]|[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83E(?:[\\uDD1D\\uDEEF]\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFD\\uDFFF]|[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFE])|\\uD83E(?:[\\uDD1D\\uDEEF]\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFE]|[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3])))?))?|\\uDC69(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?[\\uDC68\\uDC69]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?|\\uDC69\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?))|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83D\\uDC69\\uD83C[\\uDFFC-\\uDFFF])|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFC-\\uDFFF]|\\uDEEF\\u200D\\uD83D\\uDC69\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83D\\uDC69\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFD-\\uDFFF]|\\uDEEF\\u200D\\uD83D\\uDC69\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83D\\uDC69\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF]|\\uDEEF\\u200D\\uD83D\\uDC69\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83D\\uDC69\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFD\\uDFFF]|\\uDEEF\\u200D\\uD83D\\uDC69\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83D\\uDC69\\uD83C[\\uDFFB-\\uDFFE])|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFE]|\\uDEEF\\u200D\\uD83D\\uDC69\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDD75(?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDE2E(?:\\u200D\\uD83D\\uDCA8)?|\\uDE35(?:\\u200D\\uD83D\\uDCAB)?|\\uDE36(?:\\u200D\\uD83C\\uDF2B\\uFE0F?)?|\\uDE42(?:\\u200D[\\u2194\\u2195]\\uFE0F?)?|\\uDEB6(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?)|\\uD83E(?:[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5\\uDEC3-\\uDEC5\\uDEF0\\uDEF2-\\uDEF8](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3C-\\uDD3E\\uDDB8\\uDDB9\\uDDCD\\uDDCF\\uDDD4\\uDDD6-\\uDDDD](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDDDE\\uDDDF](?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCC\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE7C\\uDE80-\\uDE8A\\uDE8E-\\uDEC2\\uDEC6\\uDEC8\\uDECD-\\uDEDC\\uDEDF-\\uDEEA\\uDEEF]|\\uDDCE(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?|\\uDDD1(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3\\uDE70]|\\uDD1D\\u200D\\uD83E\\uDDD1|\\uDDD1\\u200D\\uD83E\\uDDD2(?:\\u200D\\uD83E\\uDDD2)?|\\uDDD2(?:\\u200D\\uD83E\\uDDD2)?))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFC-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFC-\\uDFFF])|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3\\uDE70]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF]|\\uDEEF\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFD-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3\\uDE70]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF]|\\uDEEF\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3\\uDE70]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF]|\\uDEEF\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFD\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3\\uDE70]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF]|\\uDEEF\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFE]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC30\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFE])|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3\\uDE70]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF]|\\uDEEF\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDEF1(?:\\uD83C(?:\\uDFFB(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFC-\\uDFFF])?|\\uDFFC(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])?|\\uDFFD(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])?|\\uDFFE(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])?|\\uDFFF(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFE])?))?)/g;\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","M","async","breaks","extensions","gfm","hooks","pedantic","renderer","silent","tokenizer","walkTokens","T","H","u","_","exec","k","e","t","source","n","replace","r","i","s","m","caret","getRegex","RegExp","Re","codeRemoveIndent","outputLinkReplace","indentCodeCompensation","beginningSpace","endingHash","startingSpaceChar","endingSpaceChar","nonSpaceChar","newLineCharGlobal","tabCharGlobal","multipleSpaceGlobal","blankLine","doubleBlankLine","blockquoteStart","blockquoteSetextReplace","blockquoteSetextReplace2","listReplaceNesting","listIsTask","listReplaceTask","listTaskCheckbox","anyLine","hrefBrackets","tableDelimiter","tableAlignChars","tableRowBlankLine","tableAlignRight","tableAlignCenter","tableAlignLeft","startATag","endATag","startPreScriptTag","endPreScriptTag","startAngleBracket","endAngleBracket","pedanticHrefTitle","unicodeAlphaNumeric","escapeTest","escapeReplace","escapeTestNoEncode","escapeReplaceNoEncode","unescapeTest","percentDecode","findPipe","splitPipe","slashPipe","carriageReturn","spaceLine","notSpaceStart","endingNewline","listItemRegex","nextBulletRegex","Math","min","hrRegex","fencesBeginRegex","headingBeginRegex","htmlBeginRegex","blockquoteBeginRegex","I","N","re","se","Pe","Q","F","$e","_e","q","j","Le","ie","U","blockquote","code","def","fences","heading","hr","html","lheading","list","newline","paragraph","table","text","te","ze","Ce","oe","v","K","ae","Be","le","ue","He","pe","Ze","Ne","ce","Qe","Fe","je","Ue","We","Xe","Je","Ve","Ye","D","et","he","ke","ne","W","_backpedal","anyPunctuation","autolink","blockSkip","br","del","delLDelim","delRDelim","emStrongLDelim","emStrongRDelimAst","emStrongRDelimUnd","escape","link","nolink","punctuation","reflink","reflinkSearch","tag","url","nt","Z","rt","E","normal","z","st","de","O","test","X","encodeURI","J","a","l","split","trim","shift","length","at","pop","splice","push","C","charAt","slice","fe","repeat","me","href","title","other","state","inLink","type","raw","tokens","inlineTokens","w","options","rules","lexer","constructor","this","space","block","codeBlockStyle","match","map","join","it","lang","inline","depth","p","c","d","top","blockTokens","h","R","f","S","substring","ordered","start","loose","items","trimStart","search","V","Y","ee","xe","be","A","G","task","trimEnd","inlineQueue","src","checked","includes","unshift","filter","some","pre","toLowerCase","header","align","rows","inRawBlock","indexOf","ge","emStrong","lastIndex","index","codespan","inlineText","escaped","x","links","create","lex","lexInline","endsWith","startBlock","forEach","charCodeAt","console","error","Error","keys","lastIndexOf","emStrongMask","startInline","y","parser","parse","parseInline","listitem","checkbox","tablecell","tablerow","strong","em","image","textRenderer","$","b","renderers","P","static","Set","preprocess","postprocess","processAllTokens","provideLexer","provideParser","L","defaults","setOptions","parseMarkdown","Parser","Renderer","TextRenderer","Lexer","Tokenizer","Hooks","use","concat","childTokens","flat","name","apply","level","passThroughHooks","has","passThroughHooksRespectAsync","onError","toString","Promise","all","catch","message","resolve","reject","g","getDefaults","regex","renderEmojis","content","hexCode","codePoint","codePointAt","render","marked"],"sourceRoot":""}